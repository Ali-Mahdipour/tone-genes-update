---
title: 'Tone and genes: new cross-linguistic data and methods support the negative effect of the "derived" allele of *ASPM* on tone, but probably not of *Microcephalin*'
subtitle: "Full statistical analyses and plots"
author: "Dan Dediu (dan.dediu@univ-lyon2.fr)"
date: '`r date()`'
output:
  html_document: 
    df_print: default
    fig_caption: yes
    highlight: textmate
    theme: readable
    toc: yes
    toc_depth: 6
    toc_float: yes
  word_document: default
editor_options: 
  chunk_output_type: console
bibliography: bibliography.bib
csl: apa-6th-edition.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE);
```

```{r libraries and setup stuff}
library(knitr);
library(pander);
library(stringr);
library(ggplot2);
library(gridExtra);
library(parallel);
library(performance);
library(lmerTest);
library(dplyr);
library(reshape2);
library(data.table);
library(glmmTMB);
library(ggnewscale);
library(sjPlot);
library(pbapply);
library(DiagrammeR);
library(mediation);
library(rsample);
library(partykit);
library(caret);
library(randomForest);
library(lavaan);
library(lavaanPlot);
library(maps);
library(cowplot);
library(e1071);
library(dagitty);

#if( !require(rethinking) )
#{
#  # Attempt to install rethinking
#  install.packages(c("coda","mvtnorm","devtools","loo","dagitty"));
#  devtools::install_github("rmcelreath/rethinking");
#  library(rethinking);
#}
library(brms);
brms_ncores  <- max(detectCores(all.tests=TRUE, logical=FALSE), 4, na.rm=TRUE); # try to use multiple cores, if present
library(bayestestR);
library(DiagrammeR); # box and arrow diagramns
library(grid); # assemble multiple plots
library(tidybayes);

# The working path is the path of this document!


# Random seed for reproducibility:
set.seed(1331);


# For (g)lmer, use more iterations with bobyqa:
glmer_ctrl = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=1e8));
lmer_ctrl  = lmerControl( optimizer="bobyqa", optCtrl=list(maxfun=1e8));

# For parallel processing:
mclapply_ncores = max(detectCores(all.tests=TRUE, logical=FALSE), 1, na.rm=TRUE);

# Cache the intermediary results:
if( !dir.exists("./cache-results") ) dir.create("./cache-results", showWarnings=FALSE);

# Make sure the figures directory exists:
if( !dir.exists("./figures") ) dir.create("./figures", showWarnings=FALSE);

## Auxiliary functions: 

# Figure and Table caption adapted from https://stackoverflow.com/questions/37116632/rmarkdown-html-number-figures: 
outputFormat = opts_knit$get("rmarkdown.pandoc.to"); # determine the output format of the document
if( is.null(outputFormat) ) outputFormat = ""; # probably not run within knittr
capTabNo = 1; capFigNo = 1; # figure and table caption numbering, for HTML do it manually
#Function to add the Table Number
capTab = function(x){
  if(outputFormat == 'html'){
    x = paste0("***Table ",capTabNo,".*** _",x,"_")
    capTabNo <<- capTabNo + 1
  }; x
}
#Function to add the Figure Number
capFig = function(x){
  if(outputFormat == 'html'){
    x = paste0("***Figure ",capFigNo,".*** _",x,"_")
    capFigNo <<- capFigNo + 1
  }; x
}

# The world maps (for plotting):
mapWorld <- map_data("world");

# For pairs plots:
panel.cor <- function(x, y){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- cor.test(x, y, method="pearson");
    rho <- cor.test(x, y, method="spearman");
    txt <- sprintf("r=%.2f, p=%.4g\nrho=%.2f, p=%.4g", 
                   r$estimate, r$p.value, rho$estimate, rho$p.value)
    cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex=1.0)
}
upper.panel<-function(x, y){
  points(x,y, pch = 21, bg="lightgray")
}
panel.hist <- function(x, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks; nB <- length(breaks)
    y <- h$counts; y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, col = "lightgray", ...)
}

# Extract the legend from a ggplot:
# https://github.com/larmarange/JLutils/blob/master/R/get_legend.R
# http://larmarange.github.io/JLutils/reference/get_legend.html
get_legend <- function(p) {
  tmp <- ggplot_gtable(ggplot_build(p))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}


# For brms:
# Verbal interpretation of Bayes factors (BF):
BF_interpretation <- function(BF, model1_name="m1", model2_name="m2")
{
  if( BF > 100 )   return (paste0("extreme evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 30 )    return (paste0("very strong evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 10 )    return (paste0("strong evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 3 )     return (paste0("moderate evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 1 )     return (paste0("anecdotal evidence for ",model1_name," against ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF == 1 )    return (paste0("no evidence for ",model1_name," nor ",model2_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.33 )  return (paste0("anecdotal evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.10 )  return (paste0("moderate evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.033 ) return (paste0("strong evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  if( BF > 0.010 ) return (paste0("very strong evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
  return (paste0("extreme evidence for ",model2_name," against ",model1_name, " (BF=",sprintf("%.3g",BF),")"));
}

# Short symbolic interpretation of Bayes factors (BF):
BF_interpretation_short <- function(BF)
{
  if( BF > 100 )   return (">>");
  if( BF > 30 )    return (">>");
  if( BF > 10 )    return (">>");
  if( BF > 3 )     return (">");
  if( BF > 1 )     return ("=");
  if( BF == 1 )    return ("=");
  if( BF > 0.33 )  return ("=");
  if( BF > 0.10 )  return ("<");
  if( BF > 0.033 ) return ("<<");
  if( BF > 0.010 ) return ("<<");
  return ("<<");
}

# Here I hack brms' kfold code to make it run in parallel using good old mclapply instead of futures
# this avoid random crashes which seem to be due to future, but works only on *NIX (which, for me here, is not an issue)
# Adapted the code from https://github.com/paul-buerkner/brms/blob/master/R/loo.R and https://github.com/paul-buerkner/brms/blob/master/R/kfold.R
if( Sys.info()['sysname'] == "Windows" )
{
  # In Windows, fall back to the stadard implementation in brms:
  add_criterion_kfold_parallel <- function(model, K=10, chains=1)
  {
    return (add_criterion(model, criterion="kfold", K=K, chains=chains));
  }
} else
{
  # On anything else, try to use maclapply:
  add_criterion_kfold_parallel <- function(model, K=10, chains=1)
  {
    model <- restructure(model);
  
    mf <- model.frame(model); 
    attributes(mf)[c("terms", "brmsframe")] <- NULL;
    N <- nrow(mf);
    fold_type <- "random"; folds <- loo::kfold_split_random(K, N);
    Ksub <- seq_len(K);
  
    kfold_results <- mclapply(Ksub, function(k) 
    {
      omitted <- predicted <- which(folds == k);
      mf_omitted <- mf[-omitted, , drop=FALSE];
      
      if( exists("subset_data2", envir=asNamespace("brms")) )
      {
        # Newer versions of brms:
        model_updated <- base::suppressWarnings(update(model, newdata=mf_omitted, data2=brms:::subset_data2(model$data2, -omitted), refresh=0, chains=chains));
        
        lppds <- log_lik(model_updated, newdata=mf[predicted, , drop=FALSE], newdata2=brms:::subset_data2(model$data2, predicted), 
                         allow_new_levels=TRUE, resp=NULL, combine=TRUE, chains=chains);
      } else if( exists("subset_autocor", envir=asNamespace("brms")) )
      {
        # Older versions of brms:
        model2 <- brms:::subset_autocor(model, -omitted, incl_car=TRUE);
        model_updated <- base::suppressWarnings(update(model2, newdata=mf_omitted, refresh=0, chains=chains));
        
        lppds <- log_lik(model_updated, newdata=mf[predicted, , drop=FALSE], allow_new_levels=TRUE, resp=NULL, combine=TRUE, chains=chains);
      } else
      {
        stop("Unknown version of brms!");
      }
  
      return (list("obs_order"=predicted, "lppds"=lppds));
    }, mc.cores=ifelse(exists("brms_ncores"), brms_ncores, detectCores()));
    
    # Put them back in the form expected by the the following unmodifed code:
    obs_order <- lapply(kfold_results, function(x) x$obs_order);
    lppds     <- lapply(kfold_results, function(x) x$lppds);
    
    elpds <- brms:::ulapply(lppds, function(x) apply(x, 2, brms:::log_mean_exp))
    # make sure elpds are put back in the right order
    elpds <- elpds[order(unlist(obs_order))]
    elpd_kfold <- sum(elpds)
    se_elpd_kfold <- sqrt(length(elpds) * var(elpds))
    rnames <- c("elpd_kfold", "p_kfold", "kfoldic")
    cnames <- c("Estimate", "SE")
    estimates <- matrix(nrow = 3, ncol = 2, dimnames = list(rnames, cnames))
    estimates[1, ] <- c(elpd_kfold, se_elpd_kfold)
    estimates[3, ] <- c(-2 * elpd_kfold, 2 * se_elpd_kfold)
    out <- brms:::nlist(estimates, pointwise = cbind(elpd_kfold = elpds))
    atts <- brms:::nlist(K, Ksub, NULL, folds, fold_type)
    attributes(out)[names(atts)] <- atts
    out <- structure(out, class = c("kfold", "loo"))
    
    attr(out, "yhash") <- brms:::hash_response(model, newdata=NULL, resp=NULL);
    attr(out, "model_name") <- "";
    
    model$criteria$kfold <- out;
    model;
  }
}

# Bayesian fit indices for a given model:
brms_fit_indices <- function(model, indices=c("bayes_R2", "loo", "waic", "kfold"), K=10, verbose=TRUE)
{
  if( "bayes_R2" %in% indices )
  {
    if( verbose) cat("R^2...\n");
    #attr(model, "R2") <- bayes_R2(model); 
    model <- add_criterion(model, "bayes_R2"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "bayes_R2" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "bayes_R2") ]] <- NULL;
  }
  
  if( "loo" %in% indices )
  {
    if( verbose) cat("LOO...\n");
    model <- add_criterion(model, "loo"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "loo" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "loo") ]] <- NULL;
  }
  
  if( "waic" %in% indices )
  {
    if( verbose) cat("WAIC...\n");
    model <- add_criterion(model, "waic"); 
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "waic" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "waic") ]] <- NULL;
  }
  
  if( "kfold" %in% indices )
  {
    if( verbose) cat(paste0("KFOLD (K=",K,")...\n"));
    #model <- add_criterion(model, "kfold", K=K, chains=1);
    model <- add_criterion_kfold_parallel(model, K=K, chains=1);
  } else
  {
    # Remove the criterion (if already there):
    if( !is.null(model$criteria) && "kfold" %in% names(model$criteria) ) model$criteria[[ which(names(model$criteria) == "kfold") ]] <- NULL;
  }

  gc();
  
  return (model);
}

# Bayesian model comparison:
brms_compare_models <- function(model1, model2, name1=NA, name2=NA, bayes_factor=TRUE, print_results=TRUE)
{
  if( !is.null(model1$criteria) && "bayes_R2" %in% names(model1$criteria) && !is.null(model1$criteria$bayes_R2) &&
      !is.null(model2$criteria) && "bayes_R2" %in% names(model2$criteria) && !is.null(model2$criteria$bayes_R2) )
  {
    R2_1_2 <- (mean(model1$criteria$bayes_R2) - mean(model2$criteria$bayes_R2));
  } else
  {
    R2_1_2 <- NA;
  }
  
  if( bayes_factor )
  {
    invisible(capture.output(bf_1_2 <- brms::bayes_factor(model1, model2)$bf));
    bf_interpret_1_2 <- BF_interpretation(bf_1_2, ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")); 
  }
  else
  {
    bf_1_2 <- NULL; bf_interpret_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "loo" %in% names(model1$criteria) && !is.null(model1$criteria$loo) &&
      !is.null(model2$criteria) && "loo" %in% names(model2$criteria) && !is.null(model2$criteria$loo) )
  {
    loo_1_2 <- loo_compare(model1, model2, criterion="loo", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    loo_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "waic" %in% names(model1$criteria) && !is.null(model1$criteria$waic) &&
      !is.null(model2$criteria) && "waic" %in% names(model2$criteria) && !is.null(model2$criteria$waic) )
  {
    waic_1_2 <- loo_compare(model1, model2, criterion="waic", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
    mw_1_2 <- model_weights(model1, model2, weights="waic", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    waic_1_2 <- NA; 
    mw_1_2 <- NA;
  }
  
  if( !is.null(model1$criteria) && "kfold" %in% names(model1$criteria) && !is.null(model1$criteria$kfold) &&
      !is.null(model2$criteria) && "kfold" %in% names(model2$criteria) && !is.null(model2$criteria$kfold) )
  {
    kfold_1_2 <- loo_compare(model1, model2, criterion="kfold", model_names=c(ifelse(!is.na(name1), name1, "model1"), ifelse(!is.na(name2), name2, "model2")));
  } else
  {
    kfold_1_2 <- NA;
  }
  
  if( print_results )
  {
    cat(paste0("\nComparing models '",ifelse(!is.na(name1), name1, "model1"),"' and '",ifelse(!is.na(name2), name2, "model2"),"':\n\n"));
    cat(paste0("\ndelta R^2 = ",sprintf("%.1f%%",100*R2_1_2),"\n\n"));
    cat(bf_interpret_1_2,"\n\n");
    cat("\nLOO:\n"); print(loo_1_2);
    cat("\nWAIC:\n"); print(waic_1_2);
    cat("\nKFOLD:\n"); print(kfold_1_2);
    cat("\nModel weights (WAIC):\n"); print(mw_1_2);
    cat("\n");
  }
  
  gc();
  
  return (list("model1"=ifelse(!is.na(name1), name1, "model1"), "model2"=ifelse(!is.na(name2), name2, "model2"), 
               "R2"=R2_1_2, "BF"=bf_1_2, "BF_interpretation"=bf_interpret_1_2, "LOO"=loo_1_2, "WAIC"=waic_1_2, "KFOLD"=kfold_1_2, "model_weights_WAIC"=mw_1_2));
}

print_brms_model_comparison <- function(brms_comp, reference=brms_comp$model1)
{
  if( length(ref_loo_idx <- which(rownames(brms_comp$LOO) == reference)) == 1 ){if(ref_loo_idx==2) ref_loo_elpd <- brms_comp$LOO[2,] else ref_loo_elpd <- c(-1,1)*brms_comp$LOO[2,]}
  if( length(ref_waic_idx <- which(rownames(brms_comp$WAIC) == reference)) == 1 ){if(ref_waic_idx==2) ref_waic_elpd <- brms_comp$WAIC[2,] else ref_waic_elpd <- c(-1,1)*brms_comp$WAIC[2,]}
  if( length(ref_kfold_idx <- which(rownames(brms_comp$KFOLD) == reference)) == 1 ){if(ref_kfold_idx==2) ref_kfold_elpd <- brms_comp$KFOLD[2,] else ref_kfold_elpd <- c(-1,1)*brms_comp$KFOLD[2,]}
  sprintf("'%s' vs '%s': [B%s L%s W%s(%.0f%%:%.0f%%) K%s]: %s, LOO=%.2f [SE=%.2f], WAIC=%.2f [SE=%.2f], KFOLD=%.2f [SE=%.2f]", 
          brms_comp$model1, brms_comp$model2,
          BF_interpretation_short(brms_comp$BF),
          ifelse(abs(ref_loo_elpd["elpd_diff"]) <= ref_loo_elpd["se_diff"],   
                 "=", 
                 ifelse(ref_loo_elpd["elpd_diff"] < 0, 
                        ifelse(abs(ref_loo_elpd["elpd_diff"]) > 2*ref_loo_elpd["se_diff"], "<<", "<"), 
                        ifelse(abs(ref_loo_elpd["elpd_diff"]) > 2*ref_loo_elpd["se_diff"], ">>", ">"))),
          ifelse(abs(ref_waic_elpd["elpd_diff"]) <= ref_waic_elpd["se_diff"],   
                 "=", 
                 ifelse(ref_waic_elpd["elpd_diff"] < 0, 
                        ifelse(abs(ref_waic_elpd["elpd_diff"]) > 2*ref_waic_elpd["se_diff"], "<<", "<"), 
                        ifelse(abs(ref_waic_elpd["elpd_diff"]) > 2*ref_waic_elpd["se_diff"], ">>", ">"))),
          100*brms_comp$model_weights_WAIC[brms_comp$model1], 100*brms_comp$model_weights_WAIC[brms_comp$model2],
          ifelse(abs(ref_kfold_elpd["elpd_diff"]) <= ref_kfold_elpd["se_diff"],   
                 "=", 
                 ifelse(ref_kfold_elpd["elpd_diff"] < 0, 
                        ifelse(abs(ref_kfold_elpd["elpd_diff"]) > 2*ref_kfold_elpd["se_diff"], "<<", "<"), 
                        ifelse(abs(ref_kfold_elpd["elpd_diff"]) > 2*ref_kfold_elpd["se_diff"], ">>", ">"))),          
          brms_comp$BF_interpretation, 
          ref_loo_elpd["elpd_diff"],   ref_loo_elpd["se_diff"],
          ref_waic_elpd["elpd_diff"],  ref_waic_elpd["se_diff"],
          ref_kfold_elpd["elpd_diff"], ref_kfold_elpd["se_diff"]);
}


## Mediation:

## Draw diagrams:

# Draw an edge depending on its regression estimate
.gr_edge <- function(model, iv, precision=2, col_neg="blue", lty_neg="solid", col_pos="red", lty_pos="solid", col_null="gray", lty_null="dashed")
{
  if( is.null(model) )
  {
    paste0('[label = "ns", style = "',lty_null,'", color = "',col_null,'"]');
  } else
  {
    v <- fixef(model)[iv, "Estimate"];
    if( is.null(v) )
    {
      paste0('[label = "ns", style = "',lty_null,'", color = "',col_null,'"]');
    } else
    {
      paste0('[label = "',round(v, precision),'", style = "',ifelse(v<0,lty_neg,lty_pos),'", color = "',ifelse(v<0,col_neg,col_pos),'"]');
    }
  }
}


# Generalise the code in sjstats:::mediation.brmsfit() for more than one mediator:
.mediation_multiple_mediators_brms <- function(model, response, treatment, mediators, prob=0.95, typical="median", rope.range="default")
{
  # Get the DVs, the treatment and the mediation models:
  dv <- insight::find_response(model, combine = TRUE);
  treatment <- sjstats:::fix_factor_name(model, treatment);
  mediator.models <- which(dv %in% mediators); treatment.model <- which(!(dv %in% mediators));
  mediators <- vapply(mediators, function(x) sjstats:::fix_factor_name(model, x), character(1));
  dv <- names(dv);
  
  # Get the coefficient for the treatment and the direct effect:
  coef_treatment <- sprintf("b_%s_%s", dv[treatment.model], treatment);
  eff.direct <- model %>% brms::posterior_samples(pars=coef_treatment, fixed=TRUE) %>% dplyr::pull(1);
  eff.direct_HDI <- bayestestR::hdi(eff.direct, ci=prob);
  
  # Get the coefficients for the mediators and their effects:
  coef_mediators <- sprintf("b_%s_%s", dv[treatment.model], mediators);
  eff.mediators <- lapply(coef_mediators, function(x) model %>% brms::posterior_samples(pars=x, fixed=TRUE) %>% dplyr::pull(1)); names(eff.mediators) <- coef_mediators;
  
  # Get the coefficients for the indirect effects and their estimates:
  coef_indirects <- sprintf("b_%s_%s", dv[mediator.models], treatment);
  tmp.indirects <- lapply(seq_along(coef_indirects), function(i) brms::posterior_samples(model, pars=c(coef_indirects[i], coef_mediators[i]), fixed=TRUE)); names(tmp.indirects) <- coef_indirects;
  eff.indirects <- do.call(cbind, lapply(tmp.indirects, function(x) x[,1] * x[,2]));
  eff.indirects_HDI <- do.call(rbind, lapply(1:ncol(eff.indirects), function(i) bayestestR::hdi(eff.indirects[,i], ci=prob)));
  
  # Get the total effect:
  eff.total <- rowSums(eff.indirects) + eff.direct;
  eff.total_HDI <- bayestestR::hdi(eff.total, ci=prob);
  
  # The proportion mediated:
  prop.mediated <- apply(eff.indirects, 2, function(x) sjmisc::typical_value(x, fun=typical)) / sjmisc::typical_value(eff.total, fun=typical);
  
  # The HDI and standard errors:
  hdi_eff <- lapply(1:ncol(eff.indirects), function(i) bayestestR::hdi(eff.indirects[,i] / eff.total, ci=prob)); names(hdi_eff) <- colnames(eff.indirects);
  prop.se <- vapply(hdi_eff, function(x) (x$CI_high - x$CI_low)/2, numeric(1));
  prop.hdi <- do.call(rbind, lapply(1:length(prop.se), function(i) prop.mediated[i] + c(-1, 1) * prop.se[i]));
  
  # The return value as a data.frame that contains all the important info:
  ret_val <- data.frame("effect"  =c("total",                             # total  
                                     "direct",                            # direct  
                                     rep("indirect", length(mediators))), # indirect
                        "mediator"=c(NA,         # total 
                                     NA,         # direct       
                                     mediators), # indirect
                        "estimate"=c(sjmisc::typical_value(eff.total, fun=typical),                                                                 # total 
                                     sjmisc::typical_value(eff.direct, fun=typical),                                                                # direct
                                     vapply(1:ncol(eff.indirects), function(i) sjmisc::typical_value(eff.indirects[,i], fun=typical), numeric(1))), # indirect
                        "estimate_HDI_low" =c(eff.total_HDI$CI_low[1],   # total  
                                              eff.direct_HDI$CI_low[1],  # direct 
                                              eff.indirects_HDI$CI_low), # indirect
                        "estimate_HDI_high"=c(eff.total_HDI$CI_high[1],   # total 
                                              eff.direct_HDI$CI_high[1],  # direct 
                                              eff.indirects_HDI$CI_high), # indirect
                        "p_ROPE"=c(rope(eff.total, range=rope.range, ci=prob)$ROPE_Percentage[1],                                                                 # total
                                   rope(eff.direct, range=rope.range, ci=prob)$ROPE_Percentage[1],                                                                # direct
                                   vapply(1:ncol(eff.indirects), function(i) rope(eff.indirects[,i], range=rope.range, ci=prob)$ROPE_Percentage[1], numeric(1))), # indirect
                        "proportion"=c(1.00,                      # total  
                                       1.00 - sum(prop.mediated), # direct
                                       prop.mediated),            # indirect
                        "proportion_HDI_low" =c(1.00,                     # total  
                                                1.00 - sum(prop.hdi[,2]), # direct
                                                prop.hdi[,1]),            # indirect
                        "proportion_HDI_high"=c(1.00,                     # total  
                                                1.00 - sum(prop.hdi[,1]), # direct
                                                prop.hdi[,2])             # indirect
  );
  attr(ret_val, "response") <- response;
  attr(ret_val, "treatment") <- treatment;
  attr(ret_val, "mediators") <- mediators;
  attr(ret_val, "prob") <- prob;
  attr(ret_val, "typical") <- typical;
  attr(ret_val, "rope.range") <- rope.range;
  
  return (ret_val);
}

# Pretty print mediation results (as a data.frame):
.print_multiple_mediators_brms <- function(x)
{
  ret_val <- data.frame("outcome"=attr(x,"response"),
                        "mediators"=paste0(attr(x,"mediators"), collapse=" "),
                        "effect"=paste0(x$effect, ifelse(x$effect == "indirect", paste0(" (",x$mediator,")") ,"")),
                        "size"=sprintf("%.2f; %.0f%%HDI [%.2f, %.2f]; p=%.2g%s", 
                                       x$estimate, attr(x,"prob")*100, x$estimate_HDI_low, x$estimate_HDI_high, x$p_ROPE, gtools::stars.pval(x$p_ROPE)),
                        "proportion"=sprintf("%.1f%% [%.1f%%, %.1f%%]",
                                             100*x$proportion, 100*x$proportion_HDI_low, 100*x$proportion_HDI_high));
  ret_val$effect <- gsub("se_v_redYes", "vowel reduction", ret_val$effect);
  ret_val$effect <- gsub("se_v_delYes", "vowel deletion",  ret_val$effect);
  ret_val$effect <- gsub("se_v_devYes", "vowel devoicing", ret_val$effect);
  ret_val;
}

# Fit mediation analysis T -> M -> O
.fit_mediation_model <- function(d=d_colors, 
                                 outcome="exists_blue", outcome_name="blue", 
                                 treatment="latitude_r", treatment_name="latitude", 
                                 mediator="UVB_r", mediator_name="UVB", 
                                 family_mediator=gaussian(), family_outcome=bernoulli("logit"), ranefs="(1 | glottocode_family) + (1 | macroarea)",
                                 cores=brms_ncores, iter=6000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                 save_model=FALSE, show_results=FALSE)
{
  # Mediation with brms:
  f_mediator <- bf(formula(paste0(mediator," ~ ",treatment," + ",                ranefs)), family=family_mediator);
  f_outcome  <- bf(formula(paste0(outcome, " ~ ",mediator, " + ",treatment," + ",ranefs)), family=family_outcome);
  model <- brm(f_mediator + f_outcome + set_rescor(FALSE), # uncorrelated residuals
               save_pars=save_pars(all=TRUE), # needed for Bayes factors
               sample_prior=TRUE,  # needed for hypotheses tests
               data=d, cores=cores, iter=iter, warmup=warmup, thin=thin, control=control);
  #model <- brms_fit_indices(model);
  model_summary <- summary(model); if(show_results) { print(model_summary); mcmc_plot(model, type="trace"); mcmc_plot(model); }
  #if( show_results) { sjstats::mediation(model); }
  model_mediation <- .mediation_multiple_mediators_brms(model, response=outcome, treatment=treatment, mediators=c(mediator)); if( show_results) { print(model_mediation); }
  #.print_multiple_mediators_brms(model_mediation);

  # Return and possibly save the results:
  ret_val <- list("outcome"=outcome, "outcome_name"=outcome_name,
                  "treatment"=treatment, "treatment_name"=treatment_name,
                  "mediator"=mediator, "mediator_name"=mediator_name,
                  "formulas"=c("mediator"=paste0(mediator," ~ ",treatment," + ",ranefs), "outcome"=paste0(outcome, " ~ ",mediator, " + ",treatment," + ",ranefs)),
                  "brms_param"=list("cores"=cores, "iter"=iter, "warmup"=warmup, "thin"=thin, "control"=control),
                  "model"=if(save_model){ model } else { NULL }, "summary"=list("fixed"=model_summary$fixed), "mediation"=model_mediation);
  return (ret_val);
}

# Plot the results of a mediation analysis T -> M -> O using DiagrammeR:
.plot_mediation_model <- function(model_summary, model_mediation, 
                                  outcome=NA,   outcome_name="",   outcome_col="gray95",
                                  treatment=NA, treatment_name="", treatment_col="gray95",
                                  mediator=NA,  mediator_name="",  mediator_col="gray95",
                                  edge_ns_col="gray80", edge_neg_col="blue", edge_pos_col="red",
                                  summary_col_ns="gray50", summary_col_neg="blue", summary_col_pos="red",
                                  highlight.ns=FALSE, show.p.values=FALSE)
{
  .edge_col <- function(edge_estim, edge_lo, edge_hi)
  {
    if(highlight.ns && edge_lo < 0 && 0 < edge_hi)
      return (edge_ns_col) # ns
    else if( edge_estim < 0 )
      return (edge_neg_col) # < 0
    else
      return (edge_pos_col); # > 0
  }
  
  .eff_col <- function(eff_estim, eff_p)
  {
    if(highlight.ns && eff_p >= 0.05)
      return (summary_col_ns) # ns
    else if( eff_estim < 0 )
      return (summary_col_neg) # < 0
    else
      return (summary_col_pos); # > 0
  }
  
  T_O <- model_summary$fixed[grep(paste0(gsub("_","",outcome,fixed=TRUE), "_", treatment), rownames(model_summary$fixed), fixed=TRUE),];
  T_O_0in <- as.numeric(highlight.ns && T_O["l-95% CI"] < 0 && 0 < T_O["u-95% CI"])+1;
  T_O_col <- .edge_col(T_O["Estimate"], T_O["l-95% CI"], T_O["u-95% CI"]);
  T_M <- model_summary$fixed[grep(paste0(gsub("_","",mediator,fixed=TRUE), "_", treatment), rownames(model_summary$fixed), fixed=TRUE),];
  T_M_0in <- as.numeric(highlight.ns && T_M["l-95% CI"] < 0 && 0 < T_M["u-95% CI"])+1;
  T_M_col <- .edge_col(T_M["Estimate"], T_M["l-95% CI"], T_M["u-95% CI"]);
  M_O <- model_summary$fixed[grep(paste0(gsub("_","",outcome,fixed=TRUE), "_", mediator), rownames(model_summary$fixed), fixed=TRUE),];
  M_O_0in <- as.numeric(highlight.ns && M_O["l-95% CI"] < 0 && 0 < M_O["u-95% CI"])+1;
  M_O_col <- .edge_col(M_O["Estimate"], M_O["l-95% CI"], M_O["u-95% CI"]);
  TotEf <-  model_mediation[model_mediation$effect == "total",];
  Tot_col <- .eff_col(TotEf["estimate"], TotEf["p_ROPE"]);
  DirEf <-  model_mediation[model_mediation$effect == "direct",];
  Dir_col <- .eff_col(DirEf["estimate"], DirEf["p_ROPE"]);
  IndEf <-  model_mediation[model_mediation$effect == "indirect",];
  Ind_col <- .eff_col(IndEf["estimate"], IndEf["p_ROPE"]);
  
  DiagrammeR::grViz(paste0('
    digraph mediation_d2l_lat {
  
    # the graph:
    graph [overlap = true]
    rankdir="LR";
  
    # the nodes:
    node [shape = box, style = "filled"]
    T    [label = "',treatment_name,'", tooltip = "treatment", fillcolor = "',treatment_col,'"]; 
    M    [label = "',mediator_name,'",  tooltip = "mediator",  fillcolor = "',outcome_col,'"]; 
    R    [label = "',outcome_name,'",   tooltip = "outcome",   fillcolor = "',mediator_col,'"]; 
  
    # the edges:
    edge [style = "solid", color = "black"]
    T -> R [label="',sprintf("%.2f [%.2f, %.2f]", T_O["Estimate"], T_O["l-95% CI"], T_O["u-95% CI"]),'", tooltip="treatment -> outcome", 
            style="',c("solid","dashed")[T_O_0in],'", color="',T_O_col,'", fontcolor="',T_O_col,'"]
    T -> M [label="',sprintf("%.2f [%.2f, %.2f]", T_M["Estimate"], T_M["l-95% CI"], T_M["u-95% CI"]),'", tooltip="treatment -> mediator", 
            style="',c("solid","dashed")[T_M_0in],'", color="',T_M_col,'", fontcolor="',T_M_col,'"]
    M -> R [label="',sprintf("%.2f [%.2f, %.2f]", M_O["Estimate"], M_O["l-95% CI"], M_O["u-95% CI"]),'", tooltip="mediator -> outcome", 
            style="',c("solid","dashed")[M_O_0in],'", color="',M_O_col,'", fontcolor="',M_O_col,'"]
    
    # summary:
    te [shape="none", style="empty", fontcolor="',Tot_col,'", 
        tooltip="Total effect", label="',sprintf(paste0("Total effect = %.2f [%.2f, %.2f]",ifelse(show.p.values,", p = %.4g","")), 
                                                 TotEf["estimate"], TotEf["estimate_HDI_low"], TotEf["estimate_HDI_high"], TotEf["p_ROPE"]),'"]
    de [shape="none", style="empty", fontcolor="',Dir_col,'", 
        tooltip="Direct effect", label="',sprintf(paste0("Direct effect = %.2f [%.2f, %.2f]",ifelse(show.p.values,", p = %.4g","")), 
                                                 DirEf["estimate"], DirEf["estimate_HDI_low"], DirEf["estimate_HDI_high"], DirEf["p_ROPE"]),'"]
    ie [shape="none", style="empty", fontcolor="',Ind_col,'", 
        tooltip="Indirect effect", label="',sprintf(paste0("Indirect effect = %.2f [%.2f, %.2f]",ifelse(show.p.values,", p = %.4g","")), 
                                                 IndEf["estimate"], IndEf["estimate_HDI_low"], IndEf["estimate_HDI_high"], IndEf["p_ROPE"]),'"]
    # trick for aligning them:
    te -> de [style = "none", color = "none"]
    de -> ie [style = "none", color = "none"]
  }
  '));
}


# Nice plot of a confusion matrix (from https://stackoverflow.com/a/53235386):
draw_confusion_matrix <- function(cm) {

  total <- sum(cm$table)
  res <- as.numeric(cm$table)

  # Generate color gradients. Palettes come from RColorBrewer.
  greenPalette <- c("#F7FCF5","#E5F5E0","#C7E9C0","#A1D99B","#74C476","#41AB5D","#238B45","#006D2C","#00441B")
  redPalette <- c("#FFF5F0","#FEE0D2","#FCBBA1","#FC9272","#FB6A4A","#EF3B2C","#CB181D","#A50F15","#67000D")
  getColor <- function (greenOrRed = "green", amount = 0) {
    if (amount == 0)
      return("#FFFFFF")
    palette <- greenPalette
    if (greenOrRed == "red")
      palette <- redPalette
    colorRampPalette(palette)(100)[10 + ceiling(90 * amount / total)]
  }

  # set the basic layout
  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)

  # create the matrix 
  classes = colnames(cm$table)
  rect(150, 430, 240, 370, col=getColor("green", res[1]))
  text(195, 435, classes[1], cex=1.2)
  rect(250, 430, 340, 370, col=getColor("red", res[3]))
  text(295, 435, classes[2], cex=1.2)
  text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
  text(245, 450, 'Actual', cex=1.3, font=2)
  rect(150, 305, 240, 365, col=getColor("red", res[2]))
  rect(250, 305, 340, 365, col=getColor("green", res[4]))
  text(140, 400, classes[1], cex=1.2, srt=90)
  text(140, 335, classes[2], cex=1.2, srt=90)

  # add in the cm results
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')

  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)

  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}


```


# Introduction

This `Rmarkdown` script contains the full results supporting the main paper (but very little interpretation).
As described in detail in the `README.md` document, this script uses various types of input data (linguistic and genetic) and multiple methods of analysis.


# Data 

## Tone

```{r load language data, results='hide'}
if( !file.exists("../data/language/output/language_data.RData") )
{
  # Pre-process the data:
  cur_wd <- getwd();
  setwd("../");
  source("./data/language/code/00_preprocess_language.R");
  setwd(cur_wd);
}
# Load the pre-processed and pre-scaled language data:
load("../data/language/output/language_data.RData");
```


### The data sources

#### *WALS*

WALS uses a **categorical** classification with `r length(levels(language_data$wa_tone))` ordered categories `r paste0("'",levels(language_data$wa_tone),"'", collapse=" < ")`.
There are `r sum(!is.na(language_data$wa_tone))` languages with data.

```{r fig.cap=capFig("Distribution of tone in WALS.")}
d <- unique(language_data[ !is.na(language_data$wa_tone), ]);

pander(table(d$wa_tone));

ggplot(d[ !is.na(d$wa_tone), ], aes(x=wa_tone, fill=wa_tone)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

#### *LAPSyD*

LAPSyD gives both a **categorical** classification with `r length(levels(language_data$la_tone))` ordered categories `r paste0("'",levels(language_data$wa_tone),"'", collapse=" < ")`, and the actual **count** of tones.
There are `r sum(!is.na(language_data$la_tone))` languages with data.

```{r fig.cap=capFig("Distribution of tone in LAPSyD.")}
d <- unique(language_data[ !is.na(language_data$la_tone), ]);

pander(table(d$la_tone));

ggplot(d[ !is.na(d$la_tone), ], aes(x=la_tone, fill=la_tone)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

```{r fig.cap=capFig("Distribution of tone counts in LAPSyD.")}
ggplot(d[ !is.na(d$la_n_tones), ], aes(x=la_n_tones)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));

#ggplot(d[ !is.na(d$la_n_tones), ], aes(x=la_n_tones)) + geom_density() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

#### *Dediu & Ladd (2007)*

This uses a **categorical** classification with `r length(levels(language_data$dl_tone))` (presence/absence) categories `r paste0("'",levels(language_data$dl_tone),"'", collapse=" and ")`.
There are `r sum(!is.na(language_data$dl_tone))` languages with data.

```{r fig.cap=capFig("Distribution of tone in Dediu & Ladd (2007)'s database.")}
d <- unique(language_data[ !is.na(language_data$dl_tone), ]);

pander(table(d$dl_tone));

ggplot(d[ !is.na(d$dl_tone), ], aes(x=dl_tone, fill=dl_tone)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

#### *PHOIBLE*

PHOIBLE gives the actual **count** in `r sum(!is.na(language_data$ph_n_tones))` languages with data.

```{r fig.cap=capFig("Distribution of tone in PHOIBLE.")}
d <- unique(language_data[ !is.na(language_data$ph_n_tones), ]);

pander(table(d$ph_n_tones));

ggplot(d[ !is.na(d$ph_n_tones), ], aes(x=ph_n_tones)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));

#ggplot(d[ !is.na(d$ph_n_tones), ], aes(x=ph_n_tones)) + geom_density() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

#### *WPHON*

WPHON gives the actual **count** in `r sum(!is.na(language_data$wp_tone))` languages with data.

```{r fig.cap=capFig("Distribution of tone in WPHON")}
d <- unique(language_data[ !is.na(language_data$wp_tone), ]);

pander(table(d$wp_tone));

ggplot(d[ !is.na(d$wp_tone), ], aes(x=wp_tone)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1));

#ggplot(d[ !is.na(d$wp_tone), ], aes(x=wp_tone)) + geom_density() + theme(axis.text.x=element_text(angle=45, hjust=1));
```


### Relationships between data sources

#### *WALS* - *LAPSyD*

```{r}
d <- unique(language_data[ !is.na(language_data$wa_tone) | !is.na(language_data$la_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wa_tone) & !is.na(d$la_tone))`
- language with values *only in WALS*: `r sum(!is.na(d$wa_tone) & is.na(d$la_tone))`
- language with values *only in LAPSyD*: `r sum(is.na(d$wa_tone) & !is.na(d$la_tone))`

```{r fig.cap=capFig("Relationship between tone in WALS and LAPSyD.")}
cooc_tab <- table(d$wa_tone, d$la_tone);

pander(cooc_tab);

tone_agreement_wa_la <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("LAPSyD") + ylab("WALS") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wa_la;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

#### *WALS* - *Dediu & Ladd (2007)*

```{r}
d <- unique(language_data[ !is.na(language_data$wa_tone) | !is.na(language_data$dl_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wa_tone) & !is.na(d$dl_tone))`
- language with values *only in WALS*: `r sum(!is.na(d$wa_tone) & is.na(d$dl_tone))`
- language with values *only in Dediu & Ladd (2007)*: `r sum(is.na(d$wa_tone) & !is.na(d$dl_tone))`

```{r fig.cap=capFig("Relationship between tone in WALS and Dediu & Ladd (2007)'s database.")}
cooc_tab <- table(d$wa_tone, d$dl_tone);

pander(cooc_tab);

tone_agreement_wa_dl <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Dediu & Ladd (2007)") + ylab("WALS") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wa_dl;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

#### *LAPSyD* - *Dediu & Ladd (2007)*

```{r}
d <- unique(language_data[ !is.na(language_data$la_tone) | !is.na(language_data$dl_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$la_tone) & !is.na(d$dl_tone))`
- language with values *only in LAPSyD*: `r sum(!is.na(d$la_tone) & is.na(d$dl_tone))`
- language with values *only in Dediu & Ladd (2007)*: `r sum(is.na(d$la_tone) & !is.na(d$dl_tone))`

```{r fig.cap=capFig("Relationship between tone in LAPSyD and Dediu & Ladd (2007)'s database.")}
cooc_tab <- table(d$la_tone, d$dl_tone);

pander(cooc_tab);

tone_agreement_dl_la <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Dediu & Ladd (2007)") + ylab("LAPSyD") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_dl_la;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

#### *PHOIBLE* - *WALS*

```{r}
d <- unique(language_data[ !is.na(language_data$ph_n_tones) | !is.na(language_data$wa_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$ph_n_tones) & !is.na(d$wa_tone))`
- language with values *only in PHOIBLE*: `r sum(!is.na(d$ph_n_tones) & is.na(d$wa_tone))`
- language with values *only in WALS*: `r sum(is.na(d$ph_n_tones) & !is.na(d$wa_tone))`

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and WALS (barplot).")}
cooc_tab <- table(d$ph_n_tones, d$wa_tone);

pander(cooc_tab);

tone_agreement_ph_wa <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("WALS") + ylab("PHOIBLE") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_ph_wa;
```

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and WALS (boxplots).")}
ggplot(d, aes(x=wa_tone, y=ph_n_tones, color=wa_tone)) + 
  geom_boxplot() + xlab("WALS") + ylab("PHOIBLE") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

m <- aov(ph_n_tones ~ wa_tone, data=d); 
pander(summary(m)); cat("\n");

pander(TukeyHSD(m)$wa_tone);
```

#### *PHOIBLE* - *LAPSyD*

```{r}
d <- unique(language_data[ !is.na(language_data$ph_n_tones) | !is.na(language_data$la_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$ph_n_tones) & !is.na(d$la_tone))`
- language with values *only in PHOIBLE*: `r sum(!is.na(d$ph_n_tones) & is.na(d$la_tone))`
- language with values *only in LAPSyD*: `r sum(is.na(d$ph_n_tones) & !is.na(d$la_tone))`

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and LAPSyD (barplot).")}
cooc_tab <- table(d$ph_n_tones, d$la_tone);

pander(cooc_tab);

tone_agreement_ph_la <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("LAPSyD") + ylab("PHOIBLE") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_ph_la;
```

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and LAPSyD (boxplots).")}
ggplot(d, aes(x=la_tone, y=ph_n_tones, color=la_tone)) + 
  geom_boxplot() + xlab("LAPSyD") + ylab("PHOIBLE") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

m <- aov(ph_n_tones ~ la_tone, data=d); 
pander(summary(m)); cat("\n");

pander(TukeyHSD(m)$la_tone);
```

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and number of tones in LAPSyD (jittered for increased visibility).")}
ggplot(d, aes(x=la_n_tones, y=ph_n_tones, color=la_tone)) + 
  xlab("LAPSyD") + ylab("PHOIBLE") + 
  geom_jitter() + 
  geom_smooth(data=d, aes(x=la_n_tones, y=ph_n_tones), color="blue", method="lm") +
  geom_smooth(data=d, aes(x=la_n_tones, y=ph_n_tones), color="red", method="loess") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ la_n_tones + ph_n_tones, data=d, method="pearson"));
pander(cor.test(~ la_n_tones + ph_n_tones, data=d, method="spearman"));
```

#### *PHOIBLE* - *Dediu & Ladd (2007)*

```{r}
d <- unique(language_data[ !is.na(language_data$ph_n_tones) | !is.na(language_data$dl_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$ph_n_tones) & !is.na(d$dl_tone))`
- language with values *only in PHOIBLE*: `r sum(!is.na(d$ph_n_tones) & is.na(d$dl_tone))`
- language with values *only in Dediu & Ladd (2007)*: `r sum(is.na(d$ph_n_tones) & !is.na(d$dl_tone))`

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and Dediu & Ladd (2007)'s database (barplot).")}
cooc_tab <- table(d$ph_n_tones, d$dl_tone);

pander(cooc_tab);

tone_agreement_ph_dl <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Dediu & Ladd (2007)") + ylab("PHOIBLE") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_ph_dl;
```

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and Dediu & Ladd (2007)'s database (boxplots).")}
ggplot(d, aes(x=dl_tone, y=ph_n_tones, color=dl_tone)) + 
  geom_boxplot() + xlab("Dediu & Ladd (2007)") + ylab("PHOIBLE") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(t.test(ph_n_tones ~ dl_tone, data=d)); cat("\n");
```

#### *WPHON* - *WALS*

```{r}
d <- unique(language_data[ !is.na(language_data$wp_tone) | !is.na(language_data$wa_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wp_tone) & !is.na(d$wa_tone))`
- language with values *only in WPHON*: `r sum(!is.na(d$wp_tone) & is.na(d$wa_tone))`
- language with values *only in WALS*: `r sum(is.na(d$wp_tone) & !is.na(d$wa_tone))`

```{r fig.cap=capFig("Relationship between tone in WPHON and WALS (barplot).")}
cooc_tab <- table(d$wp_tone, d$wa_tone);

pander(cooc_tab);

tone_agreement_wp_wa <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("WALS") + ylab("WPHON") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wp_wa;
```

```{r fig.cap=capFig("Relationship between tone in WPHON and WALS (boxplots).")}
ggplot(d, aes(x=wa_tone, y=wp_tone, color=wa_tone)) + 
  geom_boxplot() + xlab("WALS") + ylab("WPHON") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

m <- aov(wp_tone ~ wa_tone, data=d); 
pander(summary(m)); cat("\n");

pander(TukeyHSD(m)$wa_tone);
```

#### *WPHON* - *LAPSyD*

```{r}
d <- unique(language_data[ !is.na(language_data$wp_tone) | !is.na(language_data$la_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wp_tone) & !is.na(d$la_tone))`
- language with values *only in WPHON*: `r sum(!is.na(d$wp_tone) & is.na(d$la_tone))`
- language with values *only in LAPSyD*: `r sum(is.na(d$wp_tone) & !is.na(d$la_tone))`

```{r fig.cap=capFig("Relationship between tone in WPHON and LAPSyD (barplot).")}
cooc_tab <- table(d$wp_tone, d$la_tone);

pander(cooc_tab);

tone_agreement_wp_la <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("LAPSyD") + ylab("WPHON") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wp_la;
```

```{r fig.cap=capFig("Relationship between tone in WPHON and LAPSyD (boxplots).")}
ggplot(d, aes(x=la_tone, y=wp_tone, color=la_tone)) + 
  geom_boxplot() + xlab("LAPSyD") + ylab("WPHON") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

m <- aov(wp_tone ~ la_tone, data=d); 
pander(summary(m)); cat("\n");

pander(TukeyHSD(m)$la_tone);
```

```{r fig.cap=capFig("Relationship between tone in WPHON and number of tones in LAPSyD (jittered for increased visibility).")}
ggplot(d, aes(x=la_n_tones, y=wp_tone, color=la_tone)) + 
  xlab("LAPSyD") + ylab("WPHON") + 
  geom_jitter() + 
  geom_smooth(data=d, aes(x=la_n_tones, y=wp_tone), color="blue", method="lm") +
  geom_smooth(data=d, aes(x=la_n_tones, y=wp_tone), color="red", method="loess") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ la_n_tones + wp_tone, data=d, method="pearson"));
pander(cor.test(~ la_n_tones + wp_tone, data=d, method="spearman"));
```

#### *WPHON* - *Dediu & Ladd (2007)*

```{r}
d <- unique(language_data[ !is.na(language_data$wp_tone) | !is.na(language_data$dl_tone), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wp_tone) & !is.na(d$dl_tone))`
- language with values *only in WPHON*: `r sum(!is.na(d$wp_tone) & is.na(d$dl_tone))`
- language with values *only in Dediu & Ladd (2007)*: `r sum(is.na(d$wp_tone) & !is.na(d$dl_tone))`

```{r fig.cap=capFig("Relationship between tone in WPHON and Dediu & Ladd (2007)'s database (barplot).")}
cooc_tab <- table(d$wp_tone, d$dl_tone);

pander(cooc_tab);

tone_agreement_wp_dl <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Dediu & Ladd (2007)") + ylab("WPHON") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wp_dl;
```

```{r fig.cap=capFig("Relationship between tone in WPHON and Dediu & Ladd (2007)'s database (boxplots).")}
ggplot(d, aes(x=dl_tone, y=wp_tone, color=dl_tone)) + 
  geom_boxplot() + xlab("Dediu & Ladd (2007)") + ylab("WPHON") + 
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(t.test(wp_tone ~ dl_tone, data=d)); cat("\n");
```

#### *WPHON* - *PHOIBLE*

```{r}
d <- unique(language_data[ !is.na(language_data$wp_tone) | !is.na(language_data$ph_n_tones), ]);
```

- languages with values in *at least one* classification: `r nrow(d)`
- *shared* languages: `r sum(!is.na(d$wp_tone) & !is.na(d$ph_n_tones))`
- language with values *only in WPHON*: `r sum(!is.na(d$wp_tone) & is.na(d$ph_n_tones))`
- language with values *only in PHOIBLE*: `r sum(is.na(d$wp_tone) & !is.na(d$ph_n_tones))`

```{r fig.cap=capFig("Relationship between tone in WPHON and PHOIBLE (barplot).")}
cooc_tab <- table(d$wp_tone, d$ph_n_tones);

pander(cooc_tab);

tone_agreement_wp_ph <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("PHOIBLE") + ylab("WPHON") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agreement_wp_ph;
```

```{r fig.cap=capFig("Relationship between tone in WPHON and PHOIBLE (scatterplot).")}
ggplot(d, aes(x=wp_tone, y=ph_n_tones)) + 
  geom_jitter(shape=21, aes(color=wp_tone, fill=ph_n_tones)) + xlab("PHOIBLE") + ylab("WPHON") + 
  geom_smooth(data=d, color="blue", method="lm") + geom_smooth(data=d, color="red", method="loess") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ wp_tone + ph_n_tones, data=d, method="pearson")); cat("\n");
pander(cor.test(~ wp_tone + ph_n_tones, data=d, method="spearman")); cat("\n");
```


```{r include=FALSE}
# Plot for paper
cairo_pdf("./figures/tone_agreement_sources.pdf", width=4*3.5, height=4*3.5);
grid.arrange(tone_agreement_dl_la + theme(legend.position = "none"), 
             nullGrob(),           
             nullGrob(),           
             nullGrob(),
             tone_agreement_wa_la + theme(legend.position = "none"), 
             tone_agreement_wa_dl + theme(legend.position = "none"), 
             nullGrob(),           
             nullGrob(),
             tone_agreement_ph_la + theme(legend.position = "none"), 
             tone_agreement_ph_dl + theme(legend.position = "none"), 
             tone_agreement_ph_wa + theme(legend.position = "none"), 
             nullGrob(),
             tone_agreement_wp_la + theme(legend.position = "none"), 
             tone_agreement_wp_dl + theme(legend.position = "none"), 
             tone_agreement_wp_wa + theme(legend.position = "none"), 
             tone_agreement_wp_ph + theme(legend.position = "none"), 
             nrow=4);
dev.off();

```


### Reconciliating the sources

#### Collapse *LAPSyD* 4-way

The 5-level coding in *LAPSyD* is too fine-grained, especially "Marginal" is very rare, and seemingly quite similar with "Simple" (rather than "None") in its behaviour in the other data sets.
On the other hand, "Moderately complex", while quite similar with "Complex" (but not "Simple"), seems to have an identity of its own.
Thus, I collapsed "Marginal" into "Simple", resulting in a 4-way classification: "None" < "Simple" < "Moderately complex" < "Complex".
  
```{r}
# Collapse the 5-way LAPSyD classification to a 4-way one by collapsing "Marginal" --> "Simple":
levels(language_data$la_tone) <- c("None", "Simple", "Simple", "Moderately complex", "Complex");
```

#### The reconciliation rules

I designed a set of rules for deciding on a set of two "agreement" **categorical** classifications, based on a precedence of the sources and the patterns of (dis)agreement between them: 

- a *binary* classification: no tone ("No") vs any form of tone ("Yes"), and
- a *3-way* classification: "None" < "Simple" < "Complex".

More precisely, I preferred to use manually-curated categorical classifications to count sources, resulting in the following (rough) ordering: *LAPSyD* > *WALS* > *Dediu & Ladd (2007)* > *WPHON* > *PHOIBLE*. 

For the sources that give actual numbers (i.e., **counts** of tones or tone symbols), we observe that `1` is very rare, probably signalling coding errors, marginal systems ("pitch-accent") or theoretical arguments, so they can probably be safely collapsed it into `2`, and then move everything "one step down" (i.e., 2 &rarr; 1, 3 &rarr; 2, etc) so we have a continuum of counts from 0 onward.
With this, the pairwise correlations between the count sources become:

```{r}
d <- language_data[ !is.na(language_data$wa_tone) | 
                      !is.na(language_data$la_tone) | 
                      !is.na(language_data$la_n_tones) | 
                      !is.na(language_data$dl_tone) | 
                      !is.na(language_data$ph_n_tones) |
                      !is.na(language_data$wp_tone),
                    c("glottocode", "ph_n_tones", "wa_tone", "la_tone", "la_n_tones", "dl_tone", "wp_tone") ];
d <- unique(d);
d$glottocode <- as.character(d$glottocode);
d$ph_n_tones <- as.numeric(d$ph_n_tones);
s <- !is.na(d$ph_n_tones); d$ph_n_tones[ s & d$ph_n_tones == 1 ] <- 2; d$ph_n_tones[ s & d$ph_n_tones > 0 ] <- d$ph_n_tones[ s & d$ph_n_tones > 0 ] - 1;
d$wa_tone    <- as.character(d$wa_tone);
d$la_tone    <- as.character(d$la_tone);
d$la_n_tones <- as.numeric(d$la_n_tones);
s <- !is.na(d$la_n_tones); d$la_n_tones[ s & d$la_n_tones == 1 ] <- 2; d$la_n_tones[ s & d$la_n_tones > 0 ] <- d$la_n_tones[ s & d$la_n_tones > 0 ] - 1;
d$dl_tone    <- as.character(d$dl_tone);
d$wp_tone    <- as.numeric(d$wp_tone);
s <- !is.na(d$wp_tone); d$wp_tone[ s & d$wp_tone == 1 ] <- 2; d$wp_tone[ s & d$wp_tone > 0 ] <- d$wp_tone[ s & d$wp_tone > 0 ] - 1;
```

```{r fig.cap=capFig("Relationships between counts after merging 1 into 2 and moving everything down by 1."), fig.width=6, fig.height=6}
# Create the plots
pairs(d[,c("ph_n_tones", "la_n_tones", "wp_tone")], lower.panel = panel.cor, diag.panel = panel.hist, upper.panel = upper.panel);
```

```{r include=FALSE}
# Regression of LAPSyD on WPHON (so we can "correct" WPHON where there's no data for LAPSyD): 
reg_la_wp <- lm(la_n_tones ~ wp_tone + I(wp_tone^2), data=d); summary(reg_la_wp);
# and of WPHON on PHOIBLE (so we can "correct" PHOIBLE where there's no data for LAPSyD nor WPHON):
reg_la_ph <- lm(la_n_tones ~ ph_n_tones + I(ph_n_tones^2), data=d); summary(reg_la_ph);
```

Thus, the main idea is to use *LAPSyD* wherever these data exists, followed by *WPHON* and finally *PHOIBLE* (thus with precedence *LAPSyD* > *WPHON* > *PHOIBLE*). 
Please note that the counts in *WPHON* and *PHOIBLE* are "corrected" to better map on those in *LAPSyD* and to "predict" missing data, using quadratic regression (i.e., the "corrected" counts are computed as *WPHON*~corr~ = `r round(reg_la_wp$coefficients["(Intercept)"],3)` +`r round(reg_la_wp$coefficients["wp_tone"],3)`*WPHON* `r round(reg_la_wp$coefficients["I(wp_tone^2)"],3)`*WPHON*^2^, and *PHOIBLE*~corr~ = `r round(reg_la_ph$coefficients["(Intercept)"],3)` +`r round(reg_la_ph$coefficients["ph_n_tones"],3)`*PHOIBLE* `r round(reg_la_ph$coefficients["I(ph_n_tones^2)"],3)`*PHOIBLE*^2^, respectively).


```{r}
# Load the table of conditions and actions to take in each particular combination of conditions:
# Please note that the "S" classification is not used here!
tone_decisions <- read.table(file="./tone_decisions.csv", header=TRUE, sep="\t", quote='"', strip.white=TRUE, stringsAsFactors=FALSE);
tone_decisions <- do.call(rbind, lapply(1:nrow(tone_decisions), function(i)
{
  s <- tone_decisions$cond_PWLSDH[i];
  if( length(grep("[[:blank:]]+", s)) == 0 )
  {
    # Single pattern:
    return (tone_decisions[i,]);
  } else 
  {
    # Several patterns: split them one per row:
    s <- strsplit(s, "[[:blank:]]+")[[1]];
    return (data.frame("cond_PWLSDH"=s, tone_decisions[i, -grep("cond_PWLSDH", names(tone_decisions), fixed=TRUE)], row.names=NULL));
  }
}));
tone_decisions$cond_PWLSDH <- str_replace_all(tone_decisions$cond_PWLSDH, fixed("*"), "."); 
# Find the matching rows in tone_decisions for a given pattern
.match_tone_pattern <- function(pattern) 
{
  pattern <- str_pad(as.character(pattern),6, "left", "0"); # put back any removed initial 0s 
  found_on <- NA;
  for( i in 1:nrow(tone_decisions) )
  {
    if( str_detect(pattern, tone_decisions$cond_PWLSDH[i]) )
    {
      found_on <- i;
      break;
    }
  }
  if( !is.na(found_on) )
  {
    return (found_on);
  } else
  {
    warning(paste0("The pattern '",pattern,"' was not found!"));
    return (NULL);
  }
}
.all_agree <- function(...) return ( length(unique(list(...))) == 1);
d_tone_agreement <- do.call(rbind, lapply(1:nrow(d), function(i) # apply these rules to each row in turn
  {
    # Shortcut notations:
    .TP <- d$ph_n_tones[i]; .TW <- d$wa_tone[i]; .TL <- d$la_tone[i]; .TS <- NA; .TD <- d$dl_tone[i]; .TH <- d$wp_tone[i];
    
    # Apply the action for a given pattern and return its result (must be within this context):
    .a2 <- function(pattern) # binary action
    { 
      return (eval(parse(text=tone_decisions$binary_action[ .match_tone_pattern(pattern) ])));
    }
    .a3 <- function(pattern) # 3-way action
    { 
      return (eval(parse(text=tone_decisions$X3way_action[ .match_tone_pattern(pattern) ])));
    }
    
    # conditional pattern:
    cond_PWLSDH <- paste0(as.numeric(!is.na(.TP)), as.numeric(!is.na(.TW)), as.numeric(!is.na(.TL)), as.numeric(!is.na(.TS)), as.numeric(!is.na(.TD)), as.numeric(!is.na(.TH)));
    
    # Find the matching line in tone_decisions:
    s <- .match_tone_pattern(cond_PWLSDH);
    if( length(s) == 0 )
    {
      warning("No matching entry found for '",cond_PWLSDH,"' (row ",i,"): skipping it!");
      return (NULL);
    } else if( length(s) >  1 )
    {
      warning("More than one matching entry found for '",cond_PWLSDH,"' (row ",i,"): 'tone_decisions' lines: ",paste0(s,collapse=", ")," skipping it!");
      return (NULL);
    } else # length(s) == 1
    {
      # Apply the rules!
      data.frame(d[i,],
                 # Agreement binary classification:
                 "tone_binary"           =eval(parse(text=tone_decisions$binary_action[s])),
                 "tone_binary_decision"  =eval(parse(text=tone_decisions$binary_decision[s])),
                 "tone_binary_confidence"=eval(parse(text=tone_decisions$binary_confidence[s])),
                 # Agreement 3-way classification:
                 "tone_3way"             =eval(parse(text=tone_decisions$X3way_action[s])),
                 "tone_3way_decision"    =eval(parse(text=tone_decisions$X3way_decision[s])),
                 "tone_3way_confidence"  =eval(parse(text=tone_decisions$X3way_confidence[s])),
                 # Agreement count of tones:
                 "n_tones"               =ifelse(!is.na(d$la_n_tones[i]), d$la_n_tones[i], # if available, use LAPSyD
                                                        ifelse(!is.na(d$wp_tone[i]), round(predict(reg_la_wp, newdata=data.frame("wp_tone"=d$wp_tone[i]))), # if available, use the corrected WPHON
                                                          ifelse(!is.na(d$ph_n_tones[i]), round(predict(reg_la_ph, newdata=data.frame("ph_n_tones"=d$ph_n_tones[i]))), # if available, use the corrected PHOIBLE
                                                            NA))));
    }
  }));

# Make sure the factor levels are as they should:
d_tone_agreement$wa_tone <- ordered(d_tone_agreement$wa_tone, levels=c("None", "Simple", "Complex"));
d_tone_agreement$la_tone <- ordered(d_tone_agreement$la_tone, levels=c("None", "Simple", "Moderately complex", "Complex"));
d_tone_agreement$dl_tone <- factor(d_tone_agreement$dl_tone, levels=c("No", "Yes"));
d_tone_agreement$tone_binary <- factor(d_tone_agreement$tone_binary, levels=c("No", "Yes"));
d_tone_agreement$tone_3way <- ordered(d_tone_agreement$tone_3way, levels=c("None", "Simple", "Complex"));
```


#### The "agreement" classifications

##### Distributions

###### Binary classification

```{r fig.cap=capFig("Distribution of the binary agreement classification of tone.")}
pander(table(d_tone_agreement$tone_binary));

ggplot(d_tone_agreement[ !is.na(d_tone_agreement$tone_binary), ], aes(x=tone_binary, fill=tone_binary)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```

###### 3-way classification

```{r fig.cap=capFig("Distribution of the 3-way agreement classification of tone.")}
pander(table(d_tone_agreement$tone_3way));

ggplot(d_tone_agreement[ !is.na(d_tone_agreement$tone_3way), ], aes(x=tone_3way, fill=tone_3way)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```

###### Counts

```{r fig.cap=capFig("Distribution of the agreement counts of tone.")}
pander(table(d_tone_agreement$n_tones));

ggplot(d_tone_agreement[ !is.na(d_tone_agreement$n_tones), ], aes(x=n_tones, fill=n_tones)) + geom_bar() + theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```


##### Relationships with original sources


##### With *WALS*

###### Binary classification

```{r fig.cap=capFig("Relationship between tone in WALS and the agreement binary classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$wa_tone) & !is.na(d_tone_agreement$tone_binary), ];

cooc_tab <- table(d$wa_tone, d$tone_binary);

pander(cooc_tab);

tone_agr_wa_b <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (binary)") + ylab("WALS") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_wa_b;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

###### 3-way classification

```{r fig.cap=capFig("Relationship between tone in WALS and the agreement 3-way classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$wa_tone) & !is.na(d_tone_agreement$tone_3way), ];

cooc_tab <- table(d$wa_tone, d$tone_3way);

pander(cooc_tab);

tone_agr_wa_3 <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (3-way)") + ylab("WALS") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_wa_3;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```


##### With *LAPSyD*

###### Binary classification

```{r fig.cap=capFig("Relationship between tone in LAPSyD and the agreement binary classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$la_tone) & !is.na(d_tone_agreement$tone_binary), ];

cooc_tab <- table(d$la_tone, d$tone_binary);

pander(cooc_tab);

tone_agr_la_b <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (binary)") + ylab("LAPSyD") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_la_b;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

###### 3-way classification

```{r fig.cap=capFig("Relationship between tone in LAPSyD and the agreement 3-way classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$la_tone) & !is.na(d_tone_agreement$tone_3way), ];

cooc_tab <- table(d$la_tone, d$tone_3way);

pander(cooc_tab);

tone_agr_la_3 <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (3-way)") + ylab("LAPSyD") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_la_3;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

###### Counts

```{r fig.cap=capFig("Relationship between tone in LAPSyD and the agreement counts.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$la_n_tones) & !is.na(d_tone_agreement$n_tones), ];

ggplot(d, aes(x=la_n_tones, y=n_tones, color=tone_3way)) + 
  geom_jitter() + xlab("Agreement (counts)") + ylab("LAPSyD") + 
  geom_smooth(data=d, aes(x=la_n_tones, y=n_tones), color="blue", method="lm") +
  geom_smooth(data=d, aes(x=la_n_tones, y=n_tones), color="red", method="gam") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ la_n_tones + n_tones, data=d, method="pearson"));
pander(cor.test(~ la_n_tones + n_tones, data=d, method="spearman"));
```

```{r include=FALSE}
cooc_tab <- table(d$la_n_tones, d$n_tones);

tone_agr_la_c <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (counts)") + ylab("LAPSyD") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```


##### With *Dediu & Ladd (2007)*

###### Binary classification

```{r fig.cap=capFig("Relationship between tone in Dediu & Ladd (2007) and the agreement binary classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$dl_tone) & !is.na(d_tone_agreement$tone_binary), ];

cooc_tab <- table(d$dl_tone, d$tone_binary);

pander(cooc_tab);

tone_agr_dl_b <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (binary)") + ylab("Dediu & Ladd (2007)") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_dl_b;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```

###### 3-way classification

```{r fig.cap=capFig("Relationship between tone in Dediu & Ladd (2007) and the agreement 3-way classification.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$dl_tone) & !is.na(d_tone_agreement$tone_3way), ];

cooc_tab <- table(d$dl_tone, d$tone_3way);

pander(cooc_tab);

tone_agr_dl_3 <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (3-way)") + ylab("Dediu & Ladd (2007)") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
tone_agr_dl_3;

pander(chisq.test(cooc_tab, simulate.p.value=FALSE));
pander(chisq.test(cooc_tab, simulate.p.value=TRUE, B=10000));
```


##### With *PHOIBLE*

###### Counts

```{r fig.cap=capFig("Relationship between tone in PHOIBLE and the agreement counts.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$ph_n_tones) & !is.na(d_tone_agreement$n_tones), ];

ggplot(d, aes(x=ph_n_tones, y=n_tones, color=tone_3way)) + 
  geom_jitter() + xlab("Agreement (counts)") + ylab("PHOIBLE") + 
  geom_smooth(data=d, aes(x=ph_n_tones, y=n_tones), color="blue", method="lm") +
  geom_smooth(data=d, aes(x=ph_n_tones, y=n_tones), color="red", method="gam") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ ph_n_tones + n_tones, data=d, method="pearson"));
pander(cor.test(~ ph_n_tones + n_tones, data=d, method="spearman"));
```

```{r include=FALSE}
cooc_tab <- table(d$ph_n_tones, d$n_tones);

tone_agr_ph_c <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (counts)") + ylab("PHOIBLE") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```


##### With *WPHON*

###### Counts

```{r fig.cap=capFig("Relationship between tone in WPHON and the agreement counts.")}
d <- d_tone_agreement[ !is.na(d_tone_agreement$wp_tone) & !is.na(d_tone_agreement$n_tones), ];

ggplot(d, aes(x=wp_tone, y=n_tones, color=tone_3way)) + 
  geom_jitter() + xlab("Agreement (counts)") + ylab("WPHON") + 
  geom_smooth(data=d, aes(x=wp_tone, y=n_tones), color="blue", method="lm") +
  geom_smooth(data=d, aes(x=wp_tone, y=n_tones), color="red", method="gam") +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));

pander(cor.test(~ wp_tone + n_tones, data=d, method="pearson"));
pander(cor.test(~ wp_tone + n_tones, data=d, method="spearman"));
```

```{r include=FALSE}
cooc_tab <- table(d$wp_tone, d$n_tones);

tone_agr_wp_c <- ggplot(melt(cooc_tab), aes(Var2, Var1, fill=value)) + 
  geom_tile() + xlab("Agreement (counts)") + ylab("WPHON") + 
  scale_fill_gradient(low="white") +
  geom_text(aes(label=value)) +
  theme(axis.text.x=element_text(angle=45, hjust=1), axis.text.y=element_text(angle=45, hjust=1));
```



```{r include=FALSE}
# Plot for paper
cairo_pdf("./figures/tone_agreement_with_sources_binary.pdf", width=3*3.5, height=1*3.5);
grid.arrange(tone_agr_wa_b + theme(legend.position = "none"), 
             tone_agr_la_b + theme(legend.position = "none"), 
             tone_agr_dl_b + theme(legend.position = "none"),
             ncol=3);
dev.off();

cairo_pdf("./figures/tone_agreement_with_sources_3way.pdf", width=3*3.5, height=1*3.5);
grid.arrange(tone_agr_wa_3 + theme(legend.position = "none"),           
             tone_agr_la_3 + theme(legend.position = "none"), 
             tone_agr_dl_3 + theme(legend.position = "none"), 
             ncol=3);
dev.off();

cairo_pdf("./figures/tone_agreement_with_sources_counts.pdf", width=3*3.5, height=1*3.5);
grid.arrange(tone_agr_la_c + theme(legend.position = "none"),
             tone_agr_ph_c + theme(legend.position = "none"), 
             tone_agr_wp_c + theme(legend.position = "none"), 
             ncol=3);
dev.off();

```



### Conclusions about tone

```{r}
# Put these agreement (and modified) tone data back into language_data:
language_data <- merge(language_data, unique(d_tone_agreement[,c("glottocode", "ph_n_tones", "la_n_tones", "wp_tone", "tone_binary", "tone_3way", "n_tones")]), 
                       by="glottocode", suffixes=c("_original",""), all=TRUE);
```

Thus, I used 5 primary sources:

- *WALS*: categorical with `r length(levels(language_data$wa_tone))` ordered categories `r paste0("'",levels(language_data$wa_tone),"'", collapse=" < ")`,
- *LAPSYD*: categorical, recoded with `r length(levels(language_data$la_tone))` ordered categories `r paste0("'",levels(language_data$la_tone),"'", collapse=" < ")` by collapsing 'Marginal' into 'Simple', and count, from `r min(language_data$la_n_tones, na.rm=TRUE)` to `r max(language_data$la_n_tones, na.rm=TRUE)` tones (mean `r round(mean(language_data$la_n_tones, na.rm=TRUE),2)` and median `r median(language_data$la_n_tones, na.rm=TRUE)`), by collapsing the original `1` tone into the original `2` tones and moving all tones one step down (i.e., original `2` tones become `1` tone),
- *Dediu & Ladd (2007)*: categorical with `r length(levels(language_data$dl_tone))` (presence/absence) categories `r paste0("'",levels(language_data$dl_tone),"'", collapse=" and ")`,
- *WPHON*: count, from `r min(language_data$wp_tone, na.rm=TRUE)` to `r max(language_data$wp_tone, na.rm=TRUE)` tones (mean `r round(mean(language_data$wp_tone, na.rm=TRUE),2)` and median `r median(language_data$wp_tone, na.rm=TRUE)`), by collapsing the original `1` tone into the original `2` tones and moving all tones one step down (i.e., original `2` tones become `1` tone), and
- *PHOIBLE*: count, from `r min(language_data$ph_n_tones, na.rm=TRUE)` to `r max(language_data$ph_n_tones, na.rm=TRUE)` tones (mean `r round(mean(language_data$ph_n_tones, na.rm=TRUE),2)` and median `r median(language_data$ph_n_tones, na.rm=TRUE)`), by collapsing the original `1` tone into the original `2` tones and moving all tones one step down (i.e., original `2` tones become `1` tone),

From these, I built 3 "agreement" combined and reconciled measures:

- *tone_binary*: a binary (presence/absence) variable with categories `r paste0("'",levels(language_data$tone_binary),"'", collapse=" and ")`,
- *tone_3way*: a categorical variable with `r length(levels(language_data$tone_3way))` ordered categories `r paste0("'",levels(language_data$tone_3way),"'", collapse=" < ")`, and
- *n_tones*: count, from `r min(language_data$n_tones, na.rm=TRUE)` to `r max(language_data$n_tones, na.rm=TRUE)` tones (mean `r round(mean(language_data$n_tones, na.rm=TRUE),2)` and median `r median(language_data$n_tones, na.rm=TRUE)`).

However, for the analyses reported here, I used the following variables:

- *tone1*: this represents directly *tone_binary* and encapsulates the question "does the language use tone?", contrasting no tone ("No") versus any type of tone system ("Yes"),
- *tone2*: this is the dichotomisation of *tone_3way* into the question "does the language use a complex tone system?", contrasting complex tone systems ("Yes") versus no tone and simple tone systems ("No"), and
- tone *counts*: this is the *n_tones*, counting the number of tones/tone symboles in the language.

```{r}
# Add human-readable family name:
glottolog_data <- read.table("../data/language/input/glottolog4.1/languoid.csv", header=TRUE, sep=",", quote='"', stringsAsFactors=FALSE);
language_data <- merge(language_data, glottolog_data[,c("id", "name")], by.x="family", by.y="id", all.x=TRUE, all.y=FALSE, suffixes=c("","_family"));
names(language_data)[ncol(language_data)] <- "family_name";
```

```{r load and add the genetic data, results='hide'}
# Load and add the genetic data:
if( !file.exists("../data/genetics/output/gene_freqs.tsv") )
{
  # Pre-process the data:
  cur_wd <- getwd();
  setwd("../data/genetics/code/");
  source("00_preprocesses_genetics.R");
  setwd(cur_wd);
}
# Load and add the genetic data:
genetic_data <- read.table("../data/genetics/output/gene_freqs.tsv", header=TRUE, sep="\t", quote="", stringsAsFactors=FALSE);
data_all <- merge(language_data, genetic_data, by.x=c("iso"), by.y=c("ISO_639_3"), suffixes=c("_L", "_G"), all=FALSE);
data_all <- unique(data_all);

# z-score the (weighed average) allele frequencies:
data_all$aspm  <- scale(data_all$ASPM_freq_wavg,  center=TRUE, scale=TRUE);
data_all$mcph1 <- scale(data_all$MCPH1_freq_wavg, center=TRUE, scale=TRUE);

# Order row and columns:
data_all <- data_all[ order(data_all$macroarea, data_all$Metapopulation_name, data_all$name, data_all$iso, data_all$Pop_UID) ,
                      c("Metapopulation_name", "Metapopulation_ID", "Pop_UID", # metapopulation population, and sample info
                         "iso", "glottocode", "name", "level", "family", "family_name", # language info
                         "macroarea", "latitude", "longitude", "country", # geographical info
                         "tone_binary", "tone_3way", "n_tones", # agreement tone data
                         "aspm", "mcph1", # ASPM and MCPH1 z-scored frequency (weighed averages)
                         "ph_n_tones_original", "wa_tone", "la_tone", "la_n_tones_original", "la_tone_comments", "dl_tone", "wp_tone_original", # original tone data
                         "ASPM_n_alleles", "ASPM_freq_avg", "ASPM_freq_wavg", "ASPM_n_databases", "MCPH1_n_alleles", "MCPH1_freq_avg", "MCPH1_freq_wavg", "MCPH1_n_databases" # original gene data
                        )];
names(data_all) <- c("metapop", "metapop_ID", "pop_ID", # metapopulation population, and sample info
                     "ISO", "glottocode", "language", "level", "family", "family_name", # language info
                     "macroarea", "latitude", "longitude", "country", # geographical info
                     "tone_binary", "tone_3way", "n_tones", # agreement tone data
                     "ASPM", "MCPH1", # ASPM and MCPH1 z-scored frequency (weighed averages)
                     "ph_n_tones_original", "wa_tone", "la_tone", "la_n_tones_original", "la_tone_comments", "dl_tone", "wp_tone_original", # original tone data
                     "ASPM_n_alleles", "ASPM_freq_avg", "ASPM_freq_wavg", "ASPM_n_databases", "MCPH1_n_alleles", "MCPH1_freq_avg", "MCPH1_freq_wavg", "MCPH1_n_databases" # original gene data
);

# Keep only the unique entries:
data_all <- unique(data_all);

# There are very few samples from the Americas, so let's collapse them:
data_all$macroarea <- factor(data_all$macroarea);
levels(data_all$macroarea) <- c("Africa"="Africa", "Eurasia"="Eurasia", "North America"="America", "Papunesia"="Papunesia", "South America"="America");

# Use sum contrasts for macroarea:
contrasts(data_all$macroarea) <- contr.sum(length(levels(data_all$macroarea))); 

# Prepare for beta regression: 0 -> 1e-7 and 1 -> 1-1e-7:
data_all$ASPM_freq_wavg_4beta  <- ifelse(data_all$ASPM_freq_wavg  == 0.0, 1e-7, ifelse(data_all$ASPM_freq_wavg  == 1.0, 1.0-1e-7, data_all$ASPM_freq_wavg));
data_all$MCPH1_freq_wavg_4beta <- ifelse(data_all$MCPH1_freq_wavg == 0.0, 1e-7, ifelse(data_all$MCPH1_freq_wavg == 1.0, 1.0-1e-7, data_all$MCPH1_freq_wavg));
```


#### Geographic distribution

```{r fig.cap=capFig("Distribution of binary tone.")}
d <- unique(data_all[ !is.na(data_all$tone_binary), c("glottocode", "latitude", "longitude", "tone_binary", "tone_3way", "n_tones")]);

pander(table(d$tone_binary));

inset <- ggplot(d[ !is.na(d$tone_binary), ], aes(x=tone_binary, fill=tone_binary)) + 
  geom_bar(color="black") + 
  theme_bw() + 
  scale_fill_viridis_d() + scale_x_discrete(labels=c("No"="N", "Yes"="Y")) +
  theme(axis.title.x=element_blank(), axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0, size=8, color="deepskyblue1"),
        axis.title.y=element_blank(), axis.text.y=element_text(angle=45, vjust=0.5, size=8, color="deepskyblue1"),
        panel.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA),
        plot.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA), legend.position="none");

map_tone_b <- ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=tone_binary)) +
  draw_plot(inset, 0, -100, 150, 60) +
  theme(legend.position = c(0.23, 0.38), 
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 8), 
        legend.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +  
  scale_fill_viridis_d("Tone (binary)") +
  ggtitle("Tone (binary)") + 
  labs(x="Longitude (°)", y="Latitude (°)");
map_tone_b;
```

```{r fig.cap=capFig("Distribution of 3-way tone.")}
d <- unique(data_all[ !is.na(data_all$tone_3way), c("glottocode", "latitude", "longitude", "tone_binary", "tone_3way", "n_tones")]);

pander(table(d$tone_3way));

inset <- ggplot(d[ !is.na(d$tone_3way), ], aes(x=tone_3way, fill=tone_3way)) + 
  geom_bar(color="black") + 
  theme_bw() + 
  scale_fill_viridis_d() + scale_x_discrete(labels=c("None"="N", "Simple"="S", "Complex"="C")) +
  theme(axis.title.x=element_blank(), axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0, size=8, color="deepskyblue1"),
        axis.title.y=element_blank(), axis.text.y=element_text(angle=45, vjust=0.5, size=8, color="deepskyblue1"),
        panel.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA),
        plot.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA), legend.position="none");

map_tone_3 <- ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=tone_3way)) +
  draw_plot(inset, 0, -100, 150, 60) +
  theme(legend.position = c(0.23, 0.38), 
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 8), 
        legend.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +  
  scale_fill_viridis_d("Tone (3-way)") +
  ggtitle("Tone (3-way)") + 
  labs(x="Longitude (°)", y="Latitude (°)");
map_tone_3;
```

```{r fig.cap=capFig("Distribution of tone counts.")}
d <- unique(data_all[ !is.na(data_all$n_tones), c("glottocode", "latitude", "longitude", "tone_binary", "tone_3way", "n_tones")]);

pander(table(d$n_tones));

inset <- ggplot(d[ !is.na(d$n_tones), ], aes(x=n_tones, fill=n_tones)) + 
  geom_bar(fill = "deepskyblue1", alpha = 0.75, color="blue") + 
  theme_bw() + 
  scale_fill_viridis_c() +
  theme(axis.title.x=element_blank(), axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0, size=8, color="deepskyblue1"),
        axis.title.y=element_blank(), axis.text.y=element_text(angle=45, vjust=0.5, size=8, color="deepskyblue1"),
        panel.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA),
        plot.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA), legend.position="none");

map_tone_c <- ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=n_tones)) +
  draw_plot(inset, 0, -100, 150, 60) +
  theme(legend.position = c(0.23, 0.38), 
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 8), 
        legend.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +  
  scale_fill_viridis_c("Tone (counts)") +
  ggtitle("Tone (counts)") + 
  labs(x="Longitude (°)", y="Latitude (°)");
map_tone_c;
```


```{r include=FALSE}
# Map of tone for the paper:
cairo_pdf("./figures/map_tone.pdf", width=10, height=8); 
grid.arrange(map_tone_b, map_tone_3, map_tone_c, ncol=2);
dev.off();
```


## *ASPM*-D and *MCPH1*-D population frequencyes 

I will denote the "derived" alleles of *ASPM* and *MCPH1* (*Microcephalin*) as *ASPM*-D and *MCPH1*-D, respectively.

### *ASPM*-D

*ASPM*-D this was originally defined in relation to "haplotype 63" and two of its polymorphic nonsynonymous sites in exon 18 in an open reading frame (ORF), *A44871G* and *C45126A* with the ancestral alleles, respectively, A and C, and the derived ones, G and A [@mekel_bobrov_ongoing_2005, p.1720].
Later relevant publications [@wong_derived_2012; @wong_aspm_lexical_2020] however, use SNP [*rs41310927*](https://www.ncbi.nlm.nih.gov/snp/rs41310927) with ancestral allele T and derived allele C.
While most databases do contain info about this SNP, others do not, such that I also collected data about SNPs in very tight LD with it: *rs41308365*, *rs3762271*, *rs41304071*, *rs147068597* and *rs61819087* (the LD data was obtained from [LDlink's "LDproxy Tool"](https://ldlink.nci.nih.gov/?tab=ldproxy) using all populations in that database).

Thus, I collected the following data:

| Locus/SNP        | "derived" allele | Datatbases                              | Position and LD to target          |
|-----------------:|-----------------:|----------------------------------------:|-----------------------------------:|
| "haplotype 63"   | "haplogroup D"   | *MB2005*                                | the target                         |
| *rs41310927*     | C                | *WONG2020*, *LDLink*, *gnomAD*, *dbSNP* | the target                         |
| *rs41308365*     | A                | *LDLink*, *gnomAD*, *dbSNP*             | chr1:197070707; D'=1.00, R^2^=1.00 |
| *rs3762271*      | T                | *LDLink*, *gnomAD*, *dbSNP*, *ALFRED*   | chr1:197070442; D'=1.00, R^2^=1.00 |
| *rs41304071*     | T                | *LDLink*, *dbSNP*                       | chr1:197063352; D'=1.00, R^2^=1.00 |
| *rs147068597*    | A                | *LDLink*                                | chr1:197058136; D'=1.00, R^2^=1.00 |
| *rs61819087*     | G                | *LDLink*, *dbSNP*                       | chr1:197084857; D'=1.00, R^2^=1.00 |

where the databases are identified as:

| Database                   | URL                                                   | Info                                | ID     |
|---------------------------:|------------------------------------------------------:|------------------------------------:|-------:|
| @mekel_bobrov_ongoing_2005 | https://science.sciencemag.org/content/309/5741/1720  | The original source; 59 populations | *MB2005* |
| @wong_aspm_lexical_2020    | https://advances.sciencemag.org/content/6/22/eaba5090 | Massive experimental study in Cantonese speakers; 1 population | *WONG2020* |
| LDLink                     | https://ldlink.nci.nih.gov/?tab=home                  | "[...] a suite of web-based applications designed to easily and efficiently interrogate linkage disequilibrium in population groups"; 1000 genomes data in 32 individual and grouped populations | *LDLink* |
| gnomAD                     | https://gnomad.broadinstitute.org/                    | Genome Aggregation Database v2.1.1; very broad populations | *gnomAD* |
| dbSNP                      | https://www.ncbi.nlm.nih.gov/snp/                     | aggregation of info form multiple databases, mostly using very broad populations | *dbSNP* |
| 1000 genomes               | https://www.internationalgenome.org/                  | this info is included in other databases (gnomAD) so is not specifically used here | *1KG* |
| ALFRED                     | https://alfred.med.yale.edu/alfred/index.asp          | The ALlele FREquency Database; lots of info in many populations; unfortunately, for ASPM only one SNP in strong LD with the target rs41310927 (rs3762271) is available | *ALFRED* |

I ended up with frequency data about these loci in `r length(unique(genetic_data$Pop_UID[ !is.na(genetic_data$ASPM_freq_wavg) ]))` unique samples coming from `r length(unique(genetic_data$Metapopulation_ID[ !is.na(genetic_data$ASPM_freq_wavg) ]))` unique *meta-populations* (such as "Han Chinese", "Italians" or "Finnish").
After making sure the frequencies of these SNPs are very highly correlated (in those samples where they do co-occur), I computed their weigthed average frequency (weighed by the number of sampled individuals).

```{r fig.cap=capFig("Distribution of the frequency of the \"derived\" allele of *ASPM* (possibly the weigthed average across multiple SNPs in some samples).")}
d <- data_all %>%
  group_by(metapop, pop_ID) %>%
  summarise(metapop=metapop[1], metapop_ID=metapop_ID[1], pop_ID[1], ASPM_freq_wavg=ASPM_freq_wavg[1], longitude=longitude[1], latitude=latitude[1]) %>%
  filter(!is.na(ASPM_freq_wavg));

pander(summary(d$ASPM_freq_wavg));

#ggplot(d, aes(x=ASPM_freq_wavg)) + geom_histogram() + theme(axis.text.x=element_text(angle=45, hjust=1)) + xlim(0,1);
```

```{r fig.cap=capFig("Distribution of the frequency of the \"derived\" allele of *ASPM* across the world.")}
inset <- ggplot(d, aes(100*ASPM_freq_wavg)) +
  geom_histogram(fill = "deepskyblue1", alpha = 0.75, color="blue") +
  #scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  scale_x_continuous(labels = function(x) paste0(x, "%")) + xlim(0,100) +
  theme_bw() + 
  theme(axis.title.x=element_blank(), axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0, size=8, color="deepskyblue1"),
        axis.title.y=element_blank(), axis.text.y=element_text(angle=45, vjust=0.5, size=8, color="deepskyblue1"),
        panel.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA),
        plot.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA));

map_aspm <- ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=100*ASPM_freq_wavg)) +
  draw_plot(inset, 0, -100, 150, 60) +
  theme(legend.position = c(0.23, 0.38), 
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 8), 
        legend.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +  
  scale_fill_viridis_c("Frequency", labels = function(x) paste0(x, "%")) + 
  ggtitle(expression("Population frequency of"~italic("ASPM")-D)) + 
  labs(x="Longitude (°)", y="Latitude (°)");
map_aspm;
```


### *MCPH1*-D

*MCPH1*-D was originally defined in relation to *G37995C* in exon 8 in an open reading frame (ORF) with the ancestral allele G, and the derived one C [@evans_microcephalin_2005, p.1717].
Later relevant publications [@wong_aspm_lexical_2020] however, use SNP [*rs930557*](https://www.ncbi.nlm.nih.gov/snp/rs930557) with ancestral allele G and derived allele C.
While most databases do contain info about this SNP, others do not, such that I also collected info about the SNP *rs1129706* which is in very tight LD with it (the linkage data was obtained from [LDlink's "LDproxy Tool"](https://ldlink.nci.nih.gov/?tab=ldproxy) using all populations in that database).

Thus, I obtained the following data:

| Locus/SNP        | "derived" allele | Datatbases                      | Position and LD to target          |
|-----------------:|-----------------:|--------------------------------:|-----------------------------------:|
| *G37995C*        | C                | *MB2005*                        | the target                         |
| *rs930557*       | C                | *WONG2020*, *LDLink*, *dbSNP*   | the target                         |
| *rs1129706*      | G                | *ALFRED*                        | chr8:6304814; D'=0.995, R^2^=0.936 |

I ended up with frequency data about these loci in `r length(unique(genetic_data$Pop_UID[ !is.na(genetic_data$MCPH1_freq_wavg) ]))` unique samples coming from `r length(unique(genetic_data$Metapopulation_ID[ !is.na(genetic_data$MCPH1_freq_wavg) ]))` unique meta-populations.
After making sure the frequencies of these SNPs are very highly correlated (in those samples where they do co-occur), I computed their weigthed average frequency (weighed by the number of sampled individuals).

```{r fig.cap=capFig("Distribution of the frequency of the \"derived\" allele of *MCPH1* (possibly the weigthed average across multiple SNPs in some samples).")}
d <- data_all %>%
  group_by(metapop, pop_ID) %>%
  summarise(metapop=metapop[1], metapop_ID=metapop_ID[1], pop_ID[1], MCPH1_freq_wavg=MCPH1_freq_wavg[1], longitude=longitude[1], latitude=latitude[1]) %>%
  filter(!is.na(MCPH1_freq_wavg));

pander(summary(d$MCPH1_freq_wavg));

#ggplot(d, aes(x=MCPH1_freq_wavg)) + geom_histogram() + theme(axis.text.x=element_text(angle=45, hjust=1));
```

```{r fig.cap=capFig("Distribution of the frequency of the \"derived\" allele of *MCPH1* across the world.")}
inset <- ggplot(d, aes(100*MCPH1_freq_wavg)) +
  geom_histogram(fill = "deepskyblue1", alpha = 0.75, color="blue") +
  #scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  scale_x_continuous(labels = function(x) paste0(x, "%")) + xlim(0,100) +
  theme_bw() + 
  theme(axis.title.x=element_blank(), axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0, size=8, color="deepskyblue1"),
        axis.title.y=element_blank(), axis.text.y=element_text(angle=45, vjust=0.5, size=8, color="deepskyblue1"),
        panel.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA),
        plot.background = element_rect(fill = alpha("lightyellow", 0.50), colour = NA));

map_mcph1 <- ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=100*MCPH1_freq_wavg)) +
  draw_plot(inset, 0, -100, 150, 60) +
  theme(legend.position = c(0.23, 0.38), 
        legend.justification = c(1, 1), 
        legend.title = element_text(size = 8), 
        legend.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title.y = element_blank()) +  
  scale_fill_viridis_c("Frequency", labels = function(x) paste0(x, "%")) + 
  ggtitle(expression("Population frequency of"~italic("MCPH1")-D)) + 
  labs(x="Longitude (°)", y="Latitude (°)");
map_mcph1;
```


```{r include=FALSE}
# Map of "D"-alleles for the paper:
cairo_pdf("./figures/map_alleles.pdf", width=10, height=4);
grid.arrange(map_aspm, map_mcph1, ncol=2);
dev.off();

# Languages per sample:
lgs_per_sample <- rowSums(table(unique(data_all[,c("pop_ID","glottocode")])));
```


```{r include=FALSE, eval=FALSE}
# DAG model:
dag_tone_alleles <- dagitty('dag {
  bb="0,0,1,1"
  freq_d_allele [exposure,pos="0.231,0.602"]
  genetic_drift [latent,pos="0.127,0.448"]
  int_ext_factors [latent,pos="0.806,0.488"]
  contact [pos="0.438,0.161"]
  inheritance [pos="0.450,0.361"]
  tone [outcome,pos="0.707,0.666"]
  freq_d_allele -> tone
  genetic_drift -> freq_d_allele
  int_ext_factors -> tone
  contact -> freq_d_allele
  contact -> tone
  inheritance -> freq_d_allele
  inheritance -> tone
}');

plot(dag_tone_alleles);
impliedConditionalIndependencies(dag_tone_alleles);
```


# Stats


## *tone1* (is there tone?)

```{r}
# Keep only the observation with non-missing data for the relevant variables:
d_tb <- unique(data_all[complete.cases(data_all[, c("tone_binary", 
                                                    "ASPM_freq_wavg", "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta",
                                                    "family_name", "macroarea", "metapop_ID")]), 
                        c("metapop", "metapop_ID", "pop_ID", "glottocode", "family_name", "macroarea", "latitude", "longitude", 
                          "tone_binary", "ASPM_freq_wavg" , "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta")]);
# and only the observations of the same pop_ID that have different tone and gene frequency data:
lgs_to_keep <- d_tb %>% group_by(metapop, pop_ID, tone_binary, ASPM_freq_wavg, MCPH1_freq_wavg) %>%
  summarise("keep_glottocode"=glottocode[1]);
d_tb <- d_tb[ d_tb$glottocode %in% lgs_to_keep$keep_glottocode, ];

# Dichotomise macroarea:
d_tb$Africa <- factor(ifelse(d_tb$macroarea == "Africa", "Yes", "No"), levels=c("No", "Yes"));

# Recode tone and Africa as numeric and ordered:
d_tb$Africa_num   <- as.numeric(d_tb$Africa == "Yes");
d_tb$Africa_ord   <- ordered(d_tb$Africa, levels=c("No", "Yes"));
d_tb$tone_bin_num <- as.numeric(d_tb$tone_binary == "Yes");
d_tb$tone_bin_ord <- ordered(d_tb$tone_binary, levels=c("No", "Yes"));
```

I kept only the entries with non-missing data for the *tone1*, *ASPM*-D and *MCPH1*-D, and if there are more than one possible languages or allele frequencies for a given sample, I only kept those entries that have different tone or allele data.
The resulting dataset has `r nrow(d_tb)` observations, distributed among `r length(unique(d_tb$glottocode))` unique Glottolg codes in `r length(unique(d_tb$family))` families (ranging from a minimum of 1 language per family to a maximum of `r max(tmp <- as.numeric(table(d_tb$family)))`, with a mean `r round(mean(tmp),1)` and median `r round(median(tmp),1)` languages per family) and `r length(unique(d_tb$macroarea))` macroareas.

```{r fig.cap=capFig("Distribution of *tone1*.")}
distrib_all <- ggplot(as.data.frame(table(d_tb$tone_binary)), aes(x="Whole database", y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone") + ylab("Count") + 
  scale_fill_viridis_d("Tone?") + theme(legend.position="top") + 
  NULL;
#distrib_all;

pander(addmargins(tmp <- table(d_tb$tone_binary, d_tb$macroarea)));

distrib_macroarea <- ggplot(as.data.frame(tmp), aes(x=Var2, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone") + ylab("Count") + 
  scale_fill_viridis_d("Tone?") + theme(legend.position="top") + 
  NULL;
#distrib_macroarea;

grid.arrange(distrib_all + ggtitle("Overall distribution") + theme(legend.position="right") + xlab(""), 
             distrib_macroarea + ggtitle("By macroarea") + theme(legend.position="none") + xlab(""),
             nrow=1);
```

```{r fig.cap=capFig("Map of *tone1*.")}
ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d_tb, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=tone_binary)) +
  theme(legend.position = c(0.25, 0.32), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) + 
  scale_fill_viridis_d("Tone?");
```

```{r fig.cap=capFig("Relationship between *tone1*, *ASPM*-D and *MCPH1*-D."), fig.width=2*5, fig.height=2*3.2}
tmp <- d_tb; tmp$macroarea <- "All"; tmp <- rbind(tmp, d_tb); tmp$macroarea <- factor(tmp$macroarea, levels=c("All", "Africa", "America", "Eurasia", "Papunesia"));
plot_tone1_alleles_p1 <- ggplot(tmp, aes(x=ASPM_freq_wavg, y=MCPH1_freq_wavg)) + xlim(0,1) + ylim(0,1) + 
  xlab(expression(italic("ASPM")-"D")) + ylab(expression(italic("MCPH1")-"D")) +
  geom_point(aes(shape=tone_binary, fill=tone_binary), alpha=0.75, color="black") + 
  #geom_smooth(method="lm", formula=y~poly(x,2), color="black", alpha=0.25, size=0.5) + 
  facet_grid(. ~ macroarea) +
  #scale_color_manual("tone1", values=c("Yes"="blue", "No"="red")) + scale_shape("tone1") + 
  scale_fill_viridis_d(expression(italic("tone1"))) + scale_shape_manual(expression(italic("tone1")), values=c("Yes"=24, "No"=21)) + 
  ggtitle(expression(italic("ASPM")-"D, "~italic("MCPH1")-"D & "~italic("tone1")));
plot_tone1_alleles_p2 <- ggplot(tmp, aes(x=ASPM_freq_wavg, fill=tone_binary)) + xlim(0,1) +
  geom_jitter(aes(y=tone_binary, shape=tone_binary), alpha=0.50, color="black") + 
  geom_violin(aes(y=tone_binary), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=tone_binary), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("ASPM")-"D")) + ylab(expression(italic("tone1"))) +
  #scale_fill_manual("tone1", values=c("Yes"="blue", "No"="red")) + scale_shape("tone1") + 
  scale_fill_viridis_d(expression(italic("tone1"))) + scale_shape_manual(expression(italic("tone1")), values=c("Yes"=24, "No"=21)) + 
  ggtitle(expression(italic("tone1")~" vs "~italic("ASPM")-"D"));
plot_tone1_alleles_p3 <- ggplot(tmp, aes(x=MCPH1_freq_wavg, fill=tone_binary)) + xlim(0,1) +
  geom_jitter(aes(y=tone_binary, shape=tone_binary), alpha=0.50, color="black") + 
  geom_violin(aes(y=tone_binary), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=tone_binary), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("MCPH1")-"D")) + ylab(expression(italic("tone1"))) +
  #scale_fill_manual("tone1", values=c("Yes"="blue", "No"="red")) + scale_shape("tone1") + coord_flip() + 
  scale_fill_viridis_d(expression(italic("tone1"))) + scale_shape_manual(expression(italic("tone1")), values=c("Yes"=24, "No"=21)) + coord_flip() + 
  ggtitle(expression(italic("tone1")~" vs "~italic("MCPH1")-"D"));
grid.arrange(plot_tone1_alleles_p1, plot_tone1_alleles_p2, plot_tone1_alleles_p3, nrow=3);
```


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone1_distribution.pdf", width=2*3.5, height=1*3.5);
grid.arrange(distrib_all + ggtitle("Overall distribution") + theme(legend.position="right") + xlab(""), 
             distrib_macroarea + ggtitle("By macroarea") + theme(legend.position="none") + xlab(""),
             nrow=1);
dev.off();

cairo_pdf("./figures/tone1_alleles.pdf", width=5*2.5, height=3*2.75);
grid.arrange(plot_tone1_alleles_p1, plot_tone1_alleles_p2, plot_tone1_alleles_p3, nrow=3);
dev.off();
```


### Regressions

#### All data 

##### `glmer`

```{r include=FALSE}
# The null model:
m_tb_0 <- glmer(tone_binary ~ 1 + # intercept
                  (1 | family_name), # random effects structure
                family=binomial(), data=d_tb, control=glmer_ctrl);
summary(m_tb_0);
performance::icc(m_tb_0); performance::r2(m_tb_0);

# Full model:
m_tb_full <- glmer(tone_binary ~ 1 + # intercept
                     ASPM_freq_wavg + MCPH1_freq_wavg + # the two alleles (and their interaction)
                     macroarea + # macroarea
                     ASPM_freq_wavg:macroarea + MCPH1_freq_wavg:macroarea + # interactions between alleles and macroareas
                     ASPM_freq_wavg:MCPH1_freq_wavg + # interaction between alleles
                     (1 | family_name), # random effects structure
                   family=binomial(), data=d_tb, control=glmer_ctrl);
summary(m_tb_full); # Model is nearly unidentifiable: large eigenvalue ratio -> try to remove interactions:
m_tb_1 <- update(m_tb_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg); 
summary(m_tb_1); anova(m_tb_full, m_tb_1); # p=0.2651
m_tb_2 <- update(m_tb_1, . ~ . - ASPM_freq_wavg:macroarea - MCPH1_freq_wavg:macroarea);
summary(m_tb_2); anova(m_tb_full, m_tb_2); # p=0.1865
# -> ok, so this seems to be the base model... try again the gene-gene interaction:
m_tb_3 <- update(m_tb_2, . ~ . + ASPM_freq_wavg:MCPH1_freq_wavg);
summary(m_tb_3); anova(m_tb_2, m_tb_3); # p=0.9378 -> no interactions!
m_tb_full_old <- m_tb_full; m_tb_full <- m_tb_2;
lattice::dotplot(ranef(m_tb_full, which="family_name", condVar=TRUE));
performance::icc(m_tb_full); performance::r2(m_tb_full);

# Does macroarea matter?
m_tb_nom <- update(m_tb_full, . ~ . - macroarea);
summary(m_tb_nom);
performance::icc(m_tb_nom); performance::r2(m_tb_nom);
anova(m_tb_full, m_tb_nom); # p=0.07781 . -> not really
anova(m_tb_0, m_tb_nom); # p=0.004901 ** -> the alleles add info!

# Do the alleles matter?
m_tb_nog <- update(m_tb_full, . ~ . - ASPM_freq_wavg - MCPH1_freq_wavg);
summary(m_tb_nog);
performance::icc(m_tb_nog); performance::r2(m_tb_nog);
anova(m_tb_full, m_tb_nog); # p=0.6777 -> no
anova(m_tb_0, m_tb_nog); # p=0.0008223 *** -> macroarea adds info!
# ASPM:
m_tb_aspm_m <- update(m_tb_nog, . ~ . + ASPM_freq_wavg);
summary(m_tb_aspm_m); anova(m_tb_nog, m_tb_aspm_m); # p=0.419
m_tb_aspm <- update(m_tb_aspm_m, . ~ . - macroarea);
summary(m_tb_aspm); 
performance::icc(m_tb_aspm); performance::r2(m_tb_aspm);
anova(m_tb_aspm_m, m_tb_aspm); # p=0.02791 * -> macroarea adds to ASPM
anova(m_tb_0, m_tb_aspm); # p=0.004128 ** -> ASPM predicts tone by itself
# MCPH1:
m_tb_mcph1_m <- update(m_tb_nog, . ~ . + MCPH1_freq_wavg);
summary(m_tb_mcph1_m); anova(m_tb_nog, m_tb_mcph1_m); # p=0.5023
m_tb_mcph1 <- update(m_tb_mcph1_m, . ~ . - macroarea);
summary(m_tb_mcph1); 
performance::icc(m_tb_mcph1); performance::r2(m_tb_mcph1);
anova(m_tb_mcph1_m, m_tb_mcph1); # p=0.02135 * -> macroarea adds to MCPH1
anova(m_tb_0, m_tb_mcph1); # p=0.006394 ** -> MCPH1 predicts tone by itself

# -> the affect of ASPM and MCPH1 seems fully accounted for by macroarea, but are predictive for tone!
```

The "null model" (intercept and random effect only) has `r sprintf("ICC = %.1f%%", 100*performance::icc(m_tb_0)$ICC_adjusted)`[^ICC_interpretation] → *tone1* is strongly clustered within families.

The "full model" = mixed-effects logistic regression of *tone1* on *macroarea*, *ASPM*-D and *MCPH1*-D (with their *interactions*) as fixed effects, and language *family* as random effect:

- the *interactions* drop out: interaction between the two alleles (`r sprintf("*p* = %.2g", anova(m_tb_full_old, m_tb_1)[2,"Pr(>Chisq)"])`), between the alleles and macroarea  (`r sprintf("*p* = %.2g", anova(m_tb_full_old, m_tb_2)[2,"Pr(>Chisq)"])`);
- the *macroarea* by itself predicts *tone1* (`r sprintf("*p* = %.2g", anova(m_tb_0, m_tb_nog)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tb_nog)$R2_marginal)`[^R2_interpretation]);
- *ASPM*-D and *MCPH1*-D together predict *tone1* when *macroarea* is not included (`r sprintf("*p* = %.2g", anova(m_tb_0, m_tb_nom)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tb_nom)$R2_marginal)`): 
  + *ASPM*-D by itself has a negative significant effect (`r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_aspm)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_aspm)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tb_0, m_tb_aspm)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tb_aspm)$R2_marginal)`), 
  + *MCPH1*-D by itself has a negative significant effect (`r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_mcph1)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_tb_mcph1)$coefficients["MCPH1_freq_wavg", "Std. Error"], anova(m_tb_0, m_tb_mcph1)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tb_mcph1)$R2_marginal)`);
- but when including *macroarea* they do not:
  + *ASPM*: `r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_aspm_m)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_aspm_m)$coefficients["ASPM_freq_wavg", "Std. Error"], summary(m_tb_aspm_m)$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`
  + *MCPH1*: `r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_mcph1_m)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_tb_mcph1_m)$coefficients["MCPH1_freq_wavg", "Std. Error"], summary(m_tb_mcph1_m)$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"])`.

[^ICC_interpretation]: ICC represents the proportion of the variance explained by the grouping due to the random effects, and varies between 0% (the grouping contains no info) to 100% (basically all individual observations in a given group are identical); the *adjusted* ICC only considers the random effect, while the *conditional* ICC also considers the fixed effects as well; they are equal when there are no fixed effects (i.e., for the null models). Here, we show only the adjusted ICC, as we are interested in the random effects. See `?perfformance::icc` for more details.

[^R2_interpretation]: For mixed-effects models, this is Nakagawa's R^2^ estimate, where the *marginal* estimate considers only the fixed effects, while the *conditional* also considers the random effects as well. Here, we show only the marginal ICC, as we are interested in the fixed effects. See `?perfformance::r2` for more details.


###### Alleles on macroarea

```{r include=FALSE}
# Regress the alleles on macroarea:

# ASPM:
try(m_aspm_0 <- glmmTMB(ASPM_freq_wavg_4beta ~ 1 + (1 | family_name), family=beta_family(), data=d_tb), silent=FALSE);
summary(m_aspm_0);

# Add macroarea:
try(m_aspm_macroarea <- update(m_aspm_0, . ~ . + macroarea), silent=FALSE);
summary(m_aspm_macroarea);
anova(m_aspm_0, m_aspm_macroarea); # p=3.413e-16 ***

# Just Africa vs the rest:
try(m_aspm_africa <- update(m_aspm_0, . ~ . + Africa), silent=FALSE);
summary(m_aspm_africa);
anova(m_aspm_0, m_aspm_africa); # p=2.286e-14 ***


# MCPH1:
try(m_mcph1_0 <- glmmTMB(MCPH1_freq_wavg_4beta ~ 1 + (1 | family_name), family=beta_family(), data=d_tb), silent=FALSE);
summary(m_mcph1_0);

# Add macroarea:
try(m_mcph1_macroarea <- update(m_mcph1_0, . ~ . + macroarea), silent=FALSE);
summary(m_mcph1_macroarea);
anova(m_mcph1_0, m_mcph1_macroarea); # p=3.086e-12 ***

# Just Africa vs the rest:
try(m_mcph1_africa <- update(m_mcph1_0, . ~ . + Africa), silent=FALSE);
summary(m_mcph1_africa);
anova(m_mcph1_0, m_mcph1_africa); # p=3.188e-09 ***

# -> indeed, Africa vs non-Africa seems like the important driver...
```

To better understand this overlap between family, macroarea and the two "derived" alleles, I regressed (separately) the *ASPM*-D and *MCPH1*-D on the *macroarea*, using mixed-effects *beta regression* (after replacing all $0.0$ values by $10^{-7}$ and all $1.0$ by $1.0-10^{-7}$, respectively) with language family as random effect:

- the alleles are very strongly clustered within *families*:
  + *ASPM*: `r sprintf("ICC = %.1f%%", 100*performance::icc(m_aspm_macroarea)$ICC_adjusted)`
  + *MCPH1*: `r sprintf("ICC = %.1f%%", 100*performance::icc(m_mcph1_macroarea)$ICC_adjusted)`
- *macroarea* predicts their distribution very strongly:
  + *ASPM*: `r sprintf("*p* = %.2g", anova(m_aspm_0, m_aspm_macroarea)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_aspm_macroarea)$R2_marginal)`
  + *MCPH1*: `r sprintf("*p* = %.2g", anova(m_mcph1_0, m_mcph1_macroarea)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_mcph1_macroarea)$R2_marginal)` 
- separating Africa vs the rest of the world seems to drive most of this effect (both alleles have lower frequencies in Africa):
  + *ASPM*: `r sprintf("*p* = %.2g", anova(m_aspm_0, m_aspm_africa)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_aspm_africa)$R2_marginal)`
  + *MCPH1*: `r sprintf("*p* = %.2g", anova(m_mcph1_0, m_mcph1_africa)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_mcph1_africa)$R2_marginal)`

Thus, the two "derived" alleles are strongly confounded by *macroarea* (especially Africa vs the rest of the world).
Visually, it seems that the two alleles are positively correlated in all macroareas except Eurasia, and that in Africa and especially in Eurasia *tone1* seems associated with lower frequencies of *ASPM*-D.


###### Separately by macroarea

```{r include=FALSE}
# Just Africa vs non-Africa:
m_tb_africa_rest <- glmer(tone_binary ~ 1 + # intercept
                            ASPM_freq_wavg + MCPH1_freq_wavg + Africa + 
                            ASPM_freq_wavg:MCPH1_freq_wavg + 
                            ASPM_freq_wavg:Africa + MCPH1_freq_wavg:Africa + # the two alleles and the Africa-rest (and their interaction)
                            (1 | family_name), # random effects structure
                          family=binomial(), data=d_tb, control=glmer_ctrl);
summary(m_tb_africa_rest);
# check predictors:
m_tb_africa_rest_1 <- update(m_tb_africa_rest, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg); summary(m_tb_africa_rest_1); anova(m_tb_africa_rest, m_tb_africa_rest_1); # p=0.1572
m_tb_africa_rest_2 <- update(m_tb_africa_rest_1, . ~ . - MCPH1_freq_wavg:Africa); summary(m_tb_africa_rest_2); anova(m_tb_africa_rest_1, m_tb_africa_rest_2); # p=0.9314
m_tb_africa_rest_3 <- update(m_tb_africa_rest_2, . ~ . - MCPH1_freq_wavg); summary(m_tb_africa_rest_3); anova(m_tb_africa_rest_2, m_tb_africa_rest_3); # p=0.6051
anova(m_tb_africa_rest, m_tb_africa_rest_3); # p=0.5173 -> no effect of MCPH1
# check ASPM specifically:
m_tb_africa_rest_4 <- update(m_tb_africa_rest_3, . ~ . - ASPM_freq_wavg - ASPM_freq_wavg:Africa); summary(m_tb_africa_rest_4); anova(m_tb_africa_rest_3, m_tb_africa_rest_4); # p=0.2844
# check Africa specifically:
m_tb_africa_rest_5 <- update(m_tb_africa_rest_3, . ~ . - Africa - ASPM_freq_wavg:Africa); summary(m_tb_africa_rest_5); anova(m_tb_africa_rest_3, m_tb_africa_rest_5); # p=0.01608 *
# -> Africa vs the rest does explain a lot, but ASPM also explains some in the absence of Africa



# Within Africa and Eurasia separately:

# Within Africa:
m_tb_africa_full <- glmer(tone_binary ~ 1 + # intercept
                            ASPM_freq_wavg * MCPH1_freq_wavg + # the two alleles (and their interaction)
                            (1 | family_name), # random effects structure
                          family=binomial(), data=d_tb[ d_tb$macroarea == "Africa", ], control=glmer_ctrl);
summary(m_tb_africa_full); # boundary (singular) fit -> there is no variation between the families
table(d_tb[ d_tb$macroarea == "Africa", c("family_name", "tone_binary") ]);
# -> drop the random effects structure at all:
m_tb_africa_full <- glm(tone_binary ~ 1 + # intercept
                            ASPM_freq_wavg * MCPH1_freq_wavg +  # the two alleles (and their interaction)
                          family_name, # family as fixed effect
                          family=binomial(), data=d_tb[ d_tb$macroarea == "Africa", ]);
summary(m_tb_africa_full);
# family:
m_tb_africa_nofam <- update(m_tb_africa_full, . ~ . - family_name);
summary(m_tb_africa_nofam); anova(m_tb_africa_full, m_tb_africa_nofam, test="Chisq"); # p=0.4107 -> family indeed does not matter
# interaction:
m_tb_africa_noint <- update(m_tb_africa_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg);
m_tb_africa_0     <- update(m_tb_africa_noint, . ~ . - ASPM_freq_wavg - MCPH1_freq_wavg);
summary(m_tb_africa_noint); 
anova(m_tb_africa_full, m_tb_africa_noint, test="Chisq"); # p=0.3181 -> no gene x gene interaction
anova(m_tb_africa_0, m_tb_africa_noint, test="Chisq"); # p=0.1081 -> no effect of the alleles
# ASPM:
m_tb_africa_aspm <- update(m_tb_africa_0, . ~ . + ASPM_freq_wavg);
summary(m_tb_africa_aspm); anova(m_tb_africa_0, m_tb_africa_aspm, test="Chisq"); # p=0.03491 * -> negative effect
# MCPH1:
m_tb_africa_mcph1 <- update(m_tb_africa_0, . ~ . + MCPH1_freq_wavg);
summary(m_tb_africa_mcph1); anova(m_tb_africa_0, m_tb_africa_mcph1, test="Chisq"); # p=0.1941 -> nope
# -> possible effect of ASPM in Africa

# Within Eurasia:
m_tb_eurasia_full <- glmer(tone_binary ~ 1 + # intercept
                            ASPM_freq_wavg * MCPH1_freq_wavg + # the two alleles (and their interaction)
                            (1 | family_name), # random effects structure
                          family=binomial(), data=d_tb[ d_tb$macroarea == "Eurasia", ], control=glmer_ctrl);
summary(m_tb_eurasia_full);
# interaction:
m_tb_eurasia_noint <- update(m_tb_eurasia_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg);
m_tb_eurasia_0     <- update(m_tb_eurasia_noint, . ~ . - ASPM_freq_wavg - MCPH1_freq_wavg);
summary(m_tb_eurasia_noint); performance::r2(m_tb_eurasia_noint); lattice::dotplot(ranef(m_tb_eurasia_noint, which="family_name", condVar=TRUE));
anova(m_tb_eurasia_full, m_tb_eurasia_noint); # p=0.6437 -> no gene x gene interaction
anova(m_tb_eurasia_0, m_tb_eurasia_noint); # p=0.9529 -> no effect of the alleles
# ASPM:
m_tb_eurasia_aspm <- update(m_tb_eurasia_0, . ~ . + ASPM_freq_wavg);
summary(m_tb_eurasia_aspm); anova(m_tb_eurasia_0, m_tb_eurasia_aspm); # p=0.8583 -> nope
# MCPH1:
m_tb_eurasia_mcph1 <- update(m_tb_eurasia_0, . ~ . + MCPH1_freq_wavg);
summary(m_tb_eurasia_mcph1); anova(m_tb_eurasia_0, m_tb_eurasia_mcph1); # p=0.8713 -> nope
# -> no effect within Eurasia

# Within Eurasia (no random effects):
m_tb_eurasia_full_nofam <- glm(tone_binary ~ 1 + # intercept
                                 ASPM_freq_wavg * MCPH1_freq_wavg, # the two alleles (and their interaction)
                               family=binomial(), data=d_tb[ d_tb$macroarea == "Eurasia", ]);
summary(m_tb_eurasia_full_nofam);
# check language family:
AIC(m_tb_eurasia_full_nofam, m_tb_eurasia_full); # Delta(AIC) = -46.8 for family as random effect
m_tb_eurasia_full_fefam <- update(m_tb_eurasia_full_nofam, . ~ . + family_name);
summary(m_tb_eurasia_full_fefam);
anova(m_tb_eurasia_full_fefam, m_tb_eurasia_full_nofam, test="Chisq"); # p=9.004e-10 ***
AIC(m_tb_eurasia_full_fefam, m_tb_eurasia_full); # Delta(AIC) = 2.9 so the two are rather equivalent
# interaction:
m_tb_eurasia_noint_nofam <- update(m_tb_eurasia_full_nofam, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg);
m_tb_eurasia_0_nofam     <- update(m_tb_eurasia_noint_nofam, . ~ . - ASPM_freq_wavg - MCPH1_freq_wavg);
summary(m_tb_eurasia_noint_nofam); 
anova(m_tb_eurasia_full_nofam, m_tb_eurasia_noint_nofam, test="Chisq"); # p=0.4384 -> no gene x gene interaction
anova(m_tb_eurasia_0_nofam, m_tb_eurasia_noint_nofam, test="Chisq"); # p=0.0005152 *** -> clear effect of the alleles
# ASPM:
# - without family:
m_tb_eurasia_aspm_nofam <- update(m_tb_eurasia_0_nofam, . ~ . + ASPM_freq_wavg);
summary(m_tb_eurasia_aspm_nofam); anova(m_tb_eurasia_0_nofam, m_tb_eurasia_aspm_nofam, test="Chisq"); # 0.0001079 *** -> yes
# - with family as fixed effect:
m_tb_eurasia_aspm_fefam <- update(m_tb_eurasia_aspm_nofam, . ~ .  + family_name);
summary(m_tb_eurasia_aspm_fefam); anova(m_tb_eurasia_aspm_fefam, update(m_tb_eurasia_aspm_fefam, . ~ . - ASPM_freq_wavg), test="Chisq"); # 0.702 -> no
# MCPH1:
m_tb_eurasia_mcph1_nofam <- update(m_tb_eurasia_0_nofam, . ~ . + MCPH1_freq_wavg);
summary(m_tb_eurasia_mcph1_nofam); anova(m_tb_eurasia_0_nofam, m_tb_eurasia_mcph1_nofam, test="Chisq"); # p=0.6798 -> nope
# -> there is effect within Eurasia *if* we don't control for language family!
```

Conducting separate analyses in Africa and Eurasia finds a negative effect of *ASPM*-D both in Africa (`r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_africa_aspm)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_africa_aspm)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tb_africa_0, m_tb_africa_aspm, test="Chisq")[2,"Pr(>Chi)"])`) and in Eurasia (`r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_eurasia_aspm_nofam)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_eurasia_aspm_nofam)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tb_eurasia_0_nofam, m_tb_eurasia_aspm_nofam, test="Chisq")[2,"Pr(>Chi)"])`), but only when *not* modelling language *family* as a random effect.
Please note that for Africa, *family* does not work as a random effect due to the almost absent variation between them, and when modelled as fixed effect, *family* does not contribute significantly (`r sprintf("*p* = %.2g", anova(m_tb_africa_full, m_tb_africa_nofam, test="Chisq")[2,"Pr(>Chi)"])`).
For Eurasia, the *family* can be modelled as a random or as a fixed effect (the two are rather similar from an AIC point of view, there being only `r sprintf("%.1f",AIC(m_tb_eurasia_full_fefam) -  AIC(m_tb_eurasia_full))` AIC points between them), and when doing so, the effect of *ASPM*-D becomes non-significant (as random effect: `r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_eurasia_aspm)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_eurasia_aspm)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tb_eurasia_0, m_tb_eurasia_aspm, test="Chisq")[2,"Pr(>Chisq)"])`; as fixed effect: `r sprintf("*β* = %.1f ± %.1f, *p* = %.2g", summary(m_tb_eurasia_aspm_fefam)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tb_eurasia_aspm_fefam)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tb_eurasia_aspm_fefam, update(m_tb_eurasia_aspm_fefam, . ~ . - ASPM_freq_wavg), test="Chisq")[2,"Pr(>Chi)"])`).


##### `brms`

###### Macroarea as raneff

*tone1* on *ASPM*-D and *MCPH1*-D in a mixed-effects Bayesian framework (using `brms`) with *macroarea*, language *family* and *(meta)population* as (nested) random effects.

```{r include=FALSE}
if( file.exists("./cache-results/brms_tb.RData") )
{
  load("./cache-results/brms_tb.RData");
} else
{
  # The null model:
  b_tb_0 <- brm(tone_binary ~ 1 + # intercept
                  (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                family=bernoulli(link="logit"), data=d_tb, 
                prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
                save_pars=save_pars(all=TRUE), # needed for Bayes factors
                sample_prior=TRUE,             # needed for hypotheses tests
                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tb_0); mcmc_plot(b_tb_0, type="trace"); mcmc_plot(b_tb_0, type="areas");
  
  # Full model:
  b_tb_full <- brm(tone_binary ~ 1 + # intercept
                     ASPM_freq_wavg + MCPH1_freq_wavg + # the two alleles (and their interaction)
                     ASPM_freq_wavg:MCPH1_freq_wavg + # interaction between alleles
                     (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                   family=bernoulli(link="logit"), data=d_tb, 
                   prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                           prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                   save_pars=save_pars(all=TRUE), # needed for Bayes factors
                   sample_prior=TRUE,             # needed for hypotheses tests
                   cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tb_full); mcmc_plot(b_tb_full, type="trace"); mcmc_plot(b_tb_full, type="areas");
  # Check interaction:
  brms::hypothesis(b_tb_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.53 -> I can remove the interaction
  b_tb_full <- update(b_tb_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tb_full); mcmc_plot(b_tb_full, type="trace"); mcmc_plot(b_tb_full, type="areas");
  (b_tb_full_hyps <- brms::hypothesis(b_tb_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.76 and 0.72 -> not bad!
  (b_tb_full_hdi <- bayestestR::hdi(b_tb_full, ci=0.95));
  
  #sjPlot::plot_model(b_tb_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(b_tb_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  b_tb_aspm_only <- update(b_tb_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tb_aspm_only); mcmc_plot(b_tb_aspm_only, type="trace"); mcmc_plot(b_tb_aspm_only, type="areas");
  brms::hypothesis(b_tb_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.79 -> not bad!
  # MCPH1:
  b_tb_mcph1_only <- update(b_tb_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tb_mcph1_only); mcmc_plot(b_tb_mcph1_only, type="trace"); mcmc_plot(b_tb_mcph1_only, type="areas");
  brms::hypothesis(b_tb_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.77 -> not bad!
  
  # Formal model comparisons:
  b_tb_0          <- brms_fit_indices(b_tb_0);
  b_tb_full       <- brms_fit_indices(b_tb_full);
  b_tb_aspm_only  <- brms_fit_indices(b_tb_aspm_only);
  b_tb_mcph1_only <- brms_fit_indices(b_tb_mcph1_only);
  (b_tb_cmp_null_full  <- brms_compare_models(b_tb_0, b_tb_full, "null", "full"));
  (b_tb_cmp_null_aspm  <- brms_compare_models(b_tb_0, b_tb_aspm_only, "null", "ASPM"));
  (b_tb_cmp_null_mcph1 <- brms_compare_models(b_tb_0, b_tb_mcph1_only, "null", "MCPH1"));
  (b_tb_cmp_full_aspm  <- brms_compare_models(b_tb_full, b_tb_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (b_tb_cmp_full_mcph1 <- brms_compare_models(b_tb_full, b_tb_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  
  # Save these results to file:
  save(b_tb_full, b_tb_0, b_tb_aspm_only, b_tb_mcph1_only,
       b_tb_full_hyps, b_tb_full_hdi, b_tb_cmp_null_full, b_tb_cmp_null_aspm, b_tb_cmp_null_mcph1, b_tb_cmp_full_aspm, b_tb_cmp_full_mcph1, 
       file="./cache-results/brms_tb.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(b_tb_full, type="areas");
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(b_tb_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(b_tb_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_tb_full_hdi$CI_low[ b_tb_full_hdi$Parameter == "b_ASPM_freq_wavg" ], b_tb_full_hdi$CI_high[ b_tb_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_tb_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(b_tb_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_tb_full_hdi$CI_low[ b_tb_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], b_tb_full_hdi$CI_high[ b_tb_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_tb_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(b_tb_cmp_null_full)`[^intmodcmp].

[^intmodcmp]: This compares two `brms` models, m1 and m2, using Bayes Factors (BF), LOO, WAIC and KFOLD. For the latter three, I show the difference between m1 and m2 (in this order), and the SE of this difference; if the difference is *negative* (<0) then *m1 is worse*, while if it is *positive* (>0) *m1 is better*, but the "significance" of this difference can be interpreted only in the context of the SE. These results are summarized using the [B? L? W?(x%:y%) K?] notation, where the symbol * can be "=" when the models are pretty much *equivalent*, "<" if m1 is *worse* than m2 (and "<<" if this difference is really big), or ">" if m1 is *better* than m2 (and ">>" if this difference is really big); for WAIC ("W") I also give the relative weights of the two models as (x%:y%).

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(b_tb_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(b_tb_cmp_full_aspm)`.

```{r fig.cap=capFig("Plot of the posterior distribution of the macroareas as random effect.")}
# macroarea:
b_tb_full %>%
  spread_draws(b_Intercept, r_macroarea[macroarea,]) %>%
  mutate(macroarea_mean = b_Intercept + r_macroarea) %>%
  ggplot(aes(y = macroarea, x = macroarea_mean)) +
  stat_halfeye(fill="skyblue") + 
  geom_vline(xintercept = 0, linetype = "dashed");
```

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks and confusion-matrix-based measures of the quality of predictions vs the observed data:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(b_tb_0) + ggtitle("null model"),
             pp_check(b_tb_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(b_tb_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(b_tb_full) + ggtitle("full model"), 
             ncol=2);
```

```{r fig.cap=capFig("Confusion matrix for the *null* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_tb_0, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_tb_0$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *ASPM*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_tb_aspm_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_tb_aspm_only$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *MCPH1*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_tb_mcph1_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_tb_mcph1_only$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *full* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_tb_full, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_tb_full$data$tone_binary, positive="Yes"));
```


###### Gaussian process

I also regressed *tone1* on *ASPM*-D and *MCPH1*-D in a mixed-effects Bayesian framework (using `brms`) with language *family* and *(meta)population* as (nested) random effects and using a 2D Gaussian process to model contact (a separate process in each macroarea).

```{r include=FALSE}
if( file.exists("./cache-results/gp_tb.RData") )
{
  load("./cache-results/gp_tb.RData");
} else
{
  # Full model:
  gp_tb_full <- brm(bf(tone_binary ~ 1 +                                  # intercept
                         ASPM_freq_wavg + MCPH1_freq_wavg +               # the two alleles (and their interaction)
                         ASPM_freq_wavg:MCPH1_freq_wavg +                 # interaction between alleles
                         gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                         (1 | family_name / metapop)),                    # family and metapopulation
                    data=d_tb,
                    family=bernoulli(link="logit"),
                    prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), 
                            prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                            prior(normal(1, 0.2), class="sd"),      # try to reduce over-fitting
                            prior(normal(0, 3), class="sdgp")),     # pretty wide prior centered on 0
                    save_pars=save_pars(all=TRUE), # needed for Bayes factors
                    sample_prior=TRUE,  # needed for hypotheses tests
                    chains=4, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_tb_full); mcmc_plot(gp_tb_full, type="trace"); mcmc_plot(gp_tb_full, type="areas");
  # Check interaction:
  brms::hypothesis(gp_tb_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.50 -> I can remove the interaction
  gp_tb_full <- update(gp_tb_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_tb_full); mcmc_plot(gp_tb_full, type="trace"); mcmc_plot(gp_tb_full, type="areas");
  (gp_tb_full_hyps <- brms::hypothesis(gp_tb_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.73, 0.93
  (gp_tb_full_hdi <- bayestestR::hdi(gp_tb_full, ci=0.95));
  
  #sjPlot::plot_model(gp_tb_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(gp_tb_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  gp_tb_aspm_only <- update(gp_tb_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_tb_aspm_only); mcmc_plot(gp_tb_aspm_only, type="trace"); mcmc_plot(gp_tb_aspm_only, type="areas");
  brms::hypothesis(gp_tb_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.75 -> not bad!
  # MCPH1:
  gp_tb_mcph1_only <- update(gp_tb_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_tb_mcph1_only); mcmc_plot(gp_tb_mcph1_only, type="trace"); mcmc_plot(gp_tb_mcph1_only, type="areas");
  brms::hypothesis(gp_tb_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.93 -> not bad!
  
  # Null model:
  gp_tb_0 <- brm(bf(tone_binary ~ 1 +                                  # intercept
                      gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                      (1 | family_name / metapop)),                    # family and metapopulation
                 data=d_tb,
                 family=bernoulli(link="logit"),
                 prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), # pretty wide priors centered on 0
                         prior(normal(1, 0.2), class="sd"),              # try to reduce over-fitting
                         prior(normal(0, 3), class="sdgp")),             # pretty wide prior centered on 0
                 save_pars=save_pars(all=TRUE), # needed for Bayes factors
                 sample_prior=TRUE,  # needed for hypotheses tests
                 chains=4, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  # Formal model comparisons:
  gp_tb_0          <- brms_fit_indices(gp_tb_0);
  gp_tb_full       <- brms_fit_indices(gp_tb_full);
  gp_tb_aspm_only  <- brms_fit_indices(gp_tb_aspm_only);
  gp_tb_mcph1_only <- brms_fit_indices(gp_tb_mcph1_only);
  (gp_tb_cmp_null_full  <- brms_compare_models(gp_tb_0, gp_tb_full, "null", "full"));
  (gp_tb_cmp_null_aspm  <- brms_compare_models(gp_tb_0, gp_tb_aspm_only, "null", "ASPM"));
  (gp_tb_cmp_null_mcph1 <- brms_compare_models(gp_tb_0, gp_tb_mcph1_only, "null", "MCPH1"));
  (gp_tb_cmp_full_aspm  <- brms_compare_models(gp_tb_full, gp_tb_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (gp_tb_cmp_full_mcph1 <- brms_compare_models(gp_tb_full, gp_tb_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  

  # Save these results to file:
  save(gp_tb_full, gp_tb_0, gp_tb_aspm_only, gp_tb_mcph1_only,
       gp_tb_full_hyps, gp_tb_full_hdi, gp_tb_cmp_null_full, gp_tb_cmp_null_aspm, gp_tb_cmp_null_mcph1, gp_tb_cmp_full_aspm, gp_tb_cmp_full_mcph1, 
       file="./cache-results/gp_tb.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression with a 2D Gaussian process results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(gp_tb_full, type="areas", pars=c("b_Intercept", "b_ASPM", "b_MCPH1"));

## TESTS
if(FALSE)
{
  me1 <- conditional_effects(gp_tb_full, nsamples = 500, spaghetti = FALSE, surface = FALSE, prob = 0.95)
  plot(me1, ask = FALSE, points = TRUE)
}
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(gp_tb_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(gp_tb_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_tb_full_hdi$CI_low[ gp_tb_full_hdi$Parameter == "b_ASPM_freq_wavg" ], gp_tb_full_hdi$CI_high[ gp_tb_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_tb_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(gp_tb_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_tb_full_hdi$CI_low[ gp_tb_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], gp_tb_full_hdi$CI_high[ gp_tb_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_tb_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(gp_tb_cmp_null_full)`.

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(gp_tb_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(gp_tb_cmp_full_aspm)`.

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks and confusion-matrix-based measures of the quality of predictions vs the observed data:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(gp_tb_0) + ggtitle("null model"),
             pp_check(gp_tb_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(gp_tb_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(gp_tb_full) + ggtitle("full model"), 
             ncol=2);
```

```{r fig.cap=capFig("Confusion matrix for the *null* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_tb_0, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_tb_0$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *ASPM*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_tb_aspm_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_tb_aspm_only$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *MCPH1*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_tb_mcph1_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_tb_mcph1_only$data$tone_binary, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *full* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_tb_full, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_tb_full$data$tone_binary, positive="Yes"));
```


#### Randomization

For these randomization analyses there are several important parameters:

| Parameter   | Meaning                               | Values                                                                                                                            |
|:------------|:--------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------|
| `permute`   | what to permute?                      | `nothing` = the original data                                                                                                     |
|             |                                       | `tone` = permute the tone variable                                                                                                |
|             |                                       | `alleles-together` = permute the two alleles together                                                                             |
|             |                                       | `alleles-independent` = permute the two alleles separately, i.e., each is independently permuted                                  |
| `within`    | how are the permutations constrained? | `unrestricted` = all the observations are freely permuted (i.e., there are no constraints, no structure in the data is preserved) |
|             |                                       | `families` = only observations within the same language family are permuted (i.e., the structure of the families is preserved)    |
|             |                                       | `macroareas` = only observations within the same macroarea are permuted (i.e., the structure of the macroareas is preserved)      |
| `macroarea` | how do we control for macroareas?     | `none` = no control for macroareas at all                                                                                         |
|             |                                       | `fixef` = as fixed effects                                                                                                        |

```{r include=FALSE}
# Permutations:

# Fit a (possibly permuted) model and return the main results:
.fit_permuted <- function(d, 
                          tone_dv="tone_binary", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                          macroarea=c("none", "fixef", "ranef")[1], 
                          permute=c("nothing", "tone", "alleles-together", "alleles-independent")[1], 
                          within=c("unrestricted", "families", "macroareas")[1],
                          family_as_ranef=TRUE,
                          regression_type=c("logistic", "ordered", "poisson")[1])
{
  # Make sure d is a data.frame to avoid errors:
  d <- as.data.frame(d);

  # Do the permutations (if any):
  .permute_with_restrictions <- function(i, restrictions=NULL)
  {
    if( is.null(restrictions) )
    {
      # Unrestricted permuting:
      return (sample(i));
    } else
    {
      # Permute within the levels of restrictions:
      for(r in unique(restrictions))
      {
        i_r <- which(r == restrictions);
        i[i_r] <- sample(i[i_r]);
      }
      return (i);
    }
  }

  if( within == "unrestricted" )
  {
    permute_restrictions <- NULL;
  } else if( within == "families" )
  {
    permute_restrictions <- d$family_name;
  } else if( within == "macroareas" )
  {
    permute_restrictions <- d$macroarea;
  }

  if( permute == "nothing" )
  {
    # Leave the data as such...
  } else if( permute == "tone" )
  {
    i <- .permute_with_restrictions(1:nrow(d), permute_restrictions);
    d[, tone_dv] <- d[i, tone_dv];
  } else if( permute == "alleles-together" )
  {
    i <- .permute_with_restrictions(1:nrow(d), permute_restrictions);
    d[, c(aspm_iv, mcph1_iv)] <- d[i, c(aspm_iv, mcph1_iv)];
  } else if( permute == "alleles-independent" )
  {
    i_aspm  <- .permute_with_restrictions(1:nrow(d), permute_restrictions); 
    i_mcph1 <- .permute_with_restrictions(1:nrow(d), permute_restrictions);
    d[, aspm_iv]  <- d[i_aspm,  aspm_iv];
    d[, mcph1_iv] <- d[i_mcph1, mcph1_iv];
  }

  f_ivs <- paste0(tone_dv, " ~ 1",
                  " + ", aspm_iv, " + ", mcph1_iv,
                  ifelse(family_as_ranef, " + (1 | family_name)", ""),
                  switch(macroarea, "none"="", "fixef"=" + macroarea", "ranef"=" + (1 | macroarea)")); # the formula
  
  m_ivs <- NULL;
  try(m_ivs <- glmer(formula(f_ivs), 
                     family=switch(regression_type, 
                                   "logistic"=binomial("logit"),
                                   "poisson"=poisson()), 
                     data=d, control=glmer_ctrl), silent=TRUE); # the model
  if( is.null(m_ivs) )
  {
    return (NULL);
  } else
  {
    m_0 <- m_a <- m_m <- NULL;
    try(m_0 <- update(m_ivs, formula(paste0(". ~ . - ",aspm_iv," - ",mcph1_iv))), silent=TRUE);
    try(m_a <- update(m_ivs, formula(paste0(". ~ . - ",aspm_iv))), silent=TRUE);
    try(m_m <- update(m_ivs, formula(paste0(". ~ . - ",mcph1_iv))), silent=TRUE);
    if( is.null(m_0) || is.null(m_a) || is.null(m_m) )
    {
      return (NULL);
    } else
    {
      return  (data.frame("tone"          =tone_dv,
                          "macroarea"     =macroarea,
                          "family_ranef"  =family_as_ranef,
                          "permute"       =permute,
                          "permute_within"=within,
                          "p_anova"       =anova(m_ivs, m_0)[2,"Pr(>Chisq)"],
                          "AIC"           =(m_s <- summary(m_ivs))$AIC["AIC"],
                          "ASPM_b"        =m_s$coefficients["ASPM_freq_wavg", "Estimate"],
                          "ASPM_stderr"   =m_s$coefficients["ASPM_freq_wavg", "Std. Error"],
                          "ASPM_p"        =m_s$coefficients["ASPM_freq_wavg", "Pr(>|z|)"],
                          "ASPM_p_anova"  =anova(m_ivs, m_a)[2,"Pr(>Chisq)"],
                          "MCPH1_b"       =m_s$coefficients["MCPH1_freq_wavg", "Estimate"],
                          "MCPH1_stderr"  =m_s$coefficients["MCPH1_freq_wavg", "Std. Error"],
                          "MCPH1_p"       =m_s$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"],
                          "MCPH1_p_anova" =anova(m_ivs, m_m)[2,"Pr(>Chisq)"],
                          "messages"      =if(!is.null(m_s$optinfo$conv$lme4$messages)){ paste0(m_s$optinfo$conv$lme4$messages,collapse="; ") } else { NA }
      ));
    }
  }
}

# Summarize the permutation results:
.summarize_permuted <- function(d, original, macroarea=NA, permute=NA, permute_within=NA)
{
  if( !is.na(macroarea) && !is.na(permute) && !is.na(permute_within) ) d <- d[ d$macroarea %in% macroarea & d$permute %in% permute & d$permute_within %in% permute_within, ];
  
  s <- data.frame("macroarea"=macroarea, "permute"=permute, "permute_within"=permute_within, "n"=nrow(d),
                  "better_AIC"        =sum(d$AIC <= original$AIC) / nrow(d),
                  "signif_vs_null"    =sum(d$p_anova < 0.05) / nrow(d),
                  "signif_ASPM"       =sum(d$ASPM_p_anova < 0.05) / nrow(d),
                  "smaller_beta_ASPM" =sum(d$ASPM_b <= original$ASPM_b) / nrow(d),
                  "signif_MCPH1"      =sum(d$MCPH1_p_anova < 0.05) / nrow(d),
                  "smaller_beta_MCPH1"=sum(d$MCPH1_b <= original$MCPH1_b) / nrow(d));
  
  return (s);
}

all_conditions <- expand.grid("permute"=c("tone", "alleles-together", "alleles-independent"),
                              "macroarea"=c("none", "fixef"),
                              "within"=c("unrestricted", "macroareas", "families"), 
                              stringsAsFactors=FALSE);
n_permutations <- 1000;
if( file.exists("./cache-results/perm_res_tb_glmer.RData") )
{
  load("./cache-results/perm_res_tb_glmer.RData");
} else
{
  perm_res_tb_glmer <- rbind(
    # Original values:
    do.call(rbind, pblapply(unique(all_conditions$macroarea), function(macroarea)
    {
      r <- NULL;
      capture.output(try(r <- .fit_permuted(d_tb, tone_dv="tone_binary", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                            macroarea=macroarea, permute="nothing", within="unrestricted", regression_type="logistic"),
                         silent=TRUE), type="message");
      if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=0), r)) }
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character),
    # Permute values:
    do.call(rbind, pblapply(1:n_permutations, function(i)
    {
      do.call(rbind, lapply(1:nrow(all_conditions), function(j)
      {
        r <- NULL;
        capture.output(try(r <- .fit_permuted(d_tb, tone_dv="tone_binary", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                              macroarea=all_conditions$macroarea[j], permute=all_conditions$permute[j], within=all_conditions$within[j], regression_type="logistic"),
                           silent=TRUE), type="message");
        if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=i), r)) }
      }));
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character));
  # Save these results to file:
  save(perm_res_tb_glmer, file="./cache-results/perm_res_tb_glmer.RData", compress="xz", compression_level=9);
}
```

I performed `r n_permutations` independent replications of each of these parameter combinations, and below are the distributions of the permuted values versus the original ones (i.e., those obtained on the original, non-permuted data).

```{r}
# Summarize and plot these randomization results:
perm_res_tb_glmer_summary <- do.call(rbind, lapply(1:nrow(all_conditions), function(i) 
  {
    original_results <- perm_res_tb_glmer[ perm_res_tb_glmer$macroarea == all_conditions$macroarea[i] & perm_res_tb_glmer$permute == "nothing", ];
    .summarize_permuted(perm_res_tb_glmer, 
                        original=original_results, macroarea=all_conditions$macroarea[i], permute=all_conditions$permute[i], permute_within=all_conditions$within[i]);
}));
# Column order:
perm_res_tb_glmer_summary <- perm_res_tb_glmer_summary[, c("permute_within", "macroarea", "permute", 
                                                           "better_AIC", "signif_vs_null", "signif_ASPM", "smaller_beta_ASPM", "signif_MCPH1", "smaller_beta_MCPH1")];
# To percent:
perm_res_tb_glmer_summary$better_AIC         <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$better_AIC);
perm_res_tb_glmer_summary$signif_vs_null     <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$signif_vs_null);
perm_res_tb_glmer_summary$signif_ASPM        <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$signif_ASPM);
perm_res_tb_glmer_summary$smaller_beta_ASPM  <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$smaller_beta_ASPM);
perm_res_tb_glmer_summary$signif_MCPH1       <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$signif_MCPH1);
perm_res_tb_glmer_summary$smaller_beta_MCPH1 <- sprintf("%.0f%%",100*perm_res_tb_glmer_summary$smaller_beta_MCPH1);
# SHow it:
knitr::kable(perm_res_tb_glmer_summary,
             col.names=c("Permute within", "Macroarea", "Permute", "AIC", "Signif.", "*p*~*ASPM*-D~", "*&beta;*~*ASPM*-D~", "*p*~*MCPH1*-D~", "*&beta;*~*MCPH1*-D~"), 
             align="r",
             caption=paste0("Regressions on ",n_permutations," permuted data. The first 3 columns show the permutation constraints (if any), how the *macroarea* is considered (if at all), and what is permuted. The next columns show the percent of the permutations that, in order, have a better AIC compared to the original fit, are significantly better than the null model (thus testing the effect of both alleles simultaneously), have a significant effect of *ASPM*-D, have a smaller effect (*&beta;*) of *ASPM*-D than the original fit, and the same for *MCPH1*-D."));
```

```{r fig.cap=paste0("Regressions on ",n_permutations," permuted data. Each plot shows the original result (vertical dashed black line) and the distribution of the permutations for the three possible things to be permuted (colored curves) for each combination of permutation constraints (horizontal panels) and control for *macroarea* (vertical panels) in terms of the effect size *&beta;*; *ASPM*-D is on the left and *MCPH1*-D on the right. The vertical dotted black thin line is at 0.0."), fig.height=2*2+0.5, fig.width=6*2.5}
perm_res_tb_glmer$macroarea      <- factor(as.character(perm_res_tb_glmer$macroarea), levels=c("none", "fixef"));
perm_res_tb_glmer$permute        <- factor(as.character(perm_res_tb_glmer$permute), levels=c("nothing", "tone", "alleles-together", "alleles-independent"));
perm_res_tb_glmer$permute_within <- factor(as.character(perm_res_tb_glmer$permute_within), levels=c("unrestricted", "macroareas", "families"));

# ASPM:
p1 <-ggplot(perm_res_tb_glmer[ perm_res_tb_glmer$permute != "nothing", ], aes(x=ASPM_b)) + xlab("β") + xlim(-10,10) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_tb_glmer[ perm_res_tb_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=ASPM_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "top") + 
  scale_fill_discrete("What is permuted:") + scale_color_discrete("What is permuted:");
# MCPH1:
p2 <- ggplot(perm_res_tb_glmer[ perm_res_tb_glmer$permute != "nothing", ], aes(x=MCPH1_b)) + xlab("β") + xlim(-10,10) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_tb_glmer[ perm_res_tb_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=MCPH1_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "none");
l <- get_legend(p1);
grid.arrange(p1 + theme(legend.position = "none") + ggtitle(expression(italic("ASPM")-"D")), p2 + ggtitle(expression(italic("MCPH1")-"D")), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
```


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone1_regressions_permuted.pdf", width=6*1.25, height=2*1.50+0.15);
grid.arrange(p1 + theme(legend.position = "none") + ggtitle(expression(italic("ASPM")-"D")), p2 + ggtitle(expression(italic("MCPH1")-"D")), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
dev.off();
```


#### Restricted sampling

```{r include=FALSE}
.pick_one_sample_per_family <- function(d, also_per_macroarea=FALSE)
{
  if( !also_per_macroarea )
  {
    # Pick one sample per family:
    i <- vapply(unique(d$family_name), function(f){ s <- which(d$family_name == f); ifelse(length(s)==1, s, sample(s, size=1)); }, numeric(1));
  } else
  {
    # Pick one sample per family and macroarea:
    unique_cases <- unique(d[,c("family_name","macroarea")]);
    i <- vapply(1:nrow(unique_cases), function(k){ s <- which(d$family_name == unique_cases$family_name[k] & d$macroarea == unique_cases$macroarea[k]); ifelse(length(s)==1, s, sample(s, size=1)); }, numeric(1));
  }
  d[i,];
}

# Repeatedly sample and do the regressions:
n_samples <- 1000;
if( file.exists("./cache-results/reg_samples_per_fam_tb.RData") )
{
  load("./cache-results/reg_samples_per_fam_tb.RData");
} else
{
  reg_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tb);
    
    # Null:
    m_0 <- glm(tone_binary ~ 1, family=binomial(), data=d);
    # ASPM:
    m_aspm <- glm(tone_binary ~ 1 + ASPM_freq_wavg, family=binomial(), data=d); a_aspm <- anova(m_0, m_aspm, test="Chisq");
    # MCPH1:
    m_mcph1 <- glm(tone_binary ~ 1 + MCPH1_freq_wavg, family=binomial(), data=d); a_mcph1 <- anova(m_0, m_mcph1, test="Chisq");
    # Both alleles:
    m_alleles <- glm(tone_binary ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg, family=binomial(), data=d); a_alleles <- anova(m_0, m_alleles, test="Chisq");
    # macroarea:
    m_macroarea <- glm(tone_binary ~ 1 + macroarea, family=binomial(), data=d); a_macroarea <- anova(m_0, m_macroarea, test="Chisq");
    # ASPM + m_macroarea:
    m_aspm_macroarea <- glm(tone_binary ~ 1 + ASPM_freq_wavg + macroarea, family=binomial(), data=d);
    # MCPH1 + m_macroarea:
    m_mcph1_macroarea <- glm(tone_binary ~ 1 + MCPH1_freq_wavg + macroarea, family=binomial(), data=d);
    # all:
    m_full <- glm(tone_binary ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg + macroarea, family=binomial(), data=d); a_full <- anova(m_0, m_full, test="Chisq");
    
    # Return value:
    data.frame("b_aspm"=m_aspm$coefficients[2],   "p_aspm"=summary(m_aspm)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_aspm_macroarea"=m_aspm_macroarea$coefficients["ASPM_freq_wavg"], "p_aspm_macroarea"=summary(m_aspm_macroarea)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_mcph1"=m_mcph1$coefficients[2], "p_mcph1"=summary(m_mcph1)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"], 
               "b_mcph1_macroarea"=m_mcph1_macroarea$coefficients["MCPH1_freq_wavg"], "p_mcph1_macroarea"=summary(m_mcph1_macroarea)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"],
               "p_alleles"=a_alleles[2,"Pr(>Chi)"], 
               "p_macroarea"=a_macroarea[2,"Pr(>Chi)"], 
               "b_aspm_all"=m_full$coefficients["ASPM_freq_wavg"], "b_mcph1_all"=m_full$coefficients["MCPH1_freq_wavg"], "p_all"=a_full[2,"Pr(>Chi)"]);
  }));
  # Save these results to file:
  save(reg_samples_per_fam, file="./cache-results/reg_samples_per_fam_tb.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig(paste0("Results for ",n_samples," restricted samplings. For *ASPM*-D (left): ", round(100*sum(reg_samples_per_fam$b_aspm<0)/nrow(reg_samples_per_fam),1), "% of &beta;s are negative when regressing tone on *ASPM* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_aspm, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam$b_aspm_macroarea<0)/nrow(reg_samples_per_fam),1), "%, when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_aspm_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam$b_aspm_all<0)/nrow(reg_samples_per_fam),1), "% when controlling for both macroarea and *MCPH1* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_aspm_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "). For *MCPH1*-D (right): ", round(100*sum(reg_samples_per_fam$b_mcph1<0)/nrow(reg_samples_per_fam),1), "% of &beta;s are negative when regressing tone on *MCPH1* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_mcph1, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam$b_mcph1_macroarea<0)/nrow(reg_samples_per_fam),1), "% when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_mcph1_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam$b_mcph1_all<0)/nrow(reg_samples_per_fam),1), "% when controlling for both macroarea and *ASPM* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam$b_mcph1_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), ").")), fig.width=2*4, fig.height=1*4+0.25}
tmp <- rbind(cbind("gene"="ASPM",
                   reshape2::melt(reg_samples_per_fam[,c("b_aspm", "b_aspm_macroarea", "b_aspm_all")], 
                                  measure.vars=c("b_aspm", "b_aspm_macroarea", "b_aspm_all"), variable.name="model", value.name="beta")),
             cbind("gene"="MCPH1",
                   reshape2::melt(reg_samples_per_fam[,c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all")], 
                                  measure.vars=c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), variable.name="model", value.name="beta")));
tmp$model <- factor(as.character(tmp$model), 
                    levels=c("b_aspm", "b_aspm_macroarea", "b_aspm_all", "b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), 
                    labels=c("by itself", "ctrl macroarea", "ctrl macroarea & the other allele", "by itself", "ctrl macroarea", "ctrl macroarea & the other allele"));

ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone1_regressions_restricted.pdf", width=2*2.5, height=1*2.5+0.25);
ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
dev.off();
```


### Mediation and path analysis

Here, I try to disentangle the fact that *macroarea* is a very good predictor of *tone1*, but also of the frequency of the two alleles, from any effect that the alleles might have on *tone1*.
For this, I conducted mediation analysis and path analysis, where I model the effect of *macroarea* on *tone1* as partially mediated by the two alleles.

Please note that there are several technical issues with these approaches:

- for mediation analysis, the method used (as implemented by function `mediate` in package `mediation`):
  + cannot deal with a factor with several levels &rarr; I focused on the contrast between Africa and the rest of the world;
  + cannot deal with language *family* as random effect &rarr; I use "flat" regressions throughout, but I did perform restricted sampling as well as a method to control for *family*.
  
- to adress these issues, I also conducted Bayesian mediation analysis (using `brms`) with logistic regression for the outcome, beta regression for the "derived" allele frequencies, and *family* and *(meta)population* as random effects (the *macroarea* cannot be a random effect as it is the treatment as Africa vs the rest of the world).
  
- for path analysis, the method used (as implemented by function `sem` with robust estimators in package `lavaan`):
  + cannot deal with binary variables unless they are either converted to numeric (0 vs 1) or ordered (i.e., assume that there is an intrinsic ordering between the two values), affecting both the binary contrast between Africa and the rest of the world (coded as Africa=1, or ordered as "rest of the world" < "Africa") and *tone1* (coded as Yes=1, or No < Yes); I tested both codings separately;
  + cannot deal with language *family* as random effect, but I did perform restricted sampling as well as a method to control for *family*.


#### Mediation analysis

```{r fig.cap=capFig("Graphical representation of the mediation model for the two alleles considered separately. Blue = *direct effect* of *macroarea* on *tone1*; red = *indirect effect* mediatated by the alleles.")}
DiagrammeR::grViz('
  digraph mediation_model {

  # the graph:
  graph [overlap = true]
  rankdir="LR";

  # the nodes:
  node [shape = box, style = "filled", fillcolor = "gray90"];
  macroarea [label = "macroarea (Africa vs. non-Africa)"]; 
  allele    [label = "allele (ASPM-D or MCPH1-D)"]; 
  tone      [label = "tone (binary)"]; 

  # the edges:
  edge       [style = "solid", color = "black"];
  macroarea -> tone   [color = "blue"] ;
  macroarea -> allele [color = "red"] ;
  allele    -> tone   [color = "red"] ;
}
');
```


##### All data

###### `(g)lm`

```{r include=FALSE}
# ASPM:
med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d_tb); (med_aspm_f1_summary <- summary(med_aspm_f1));
med_aspm_f2 <- glm(tone_binary ~ ASPM_freq_wavg + Africa, family=binomial(), data=d_tb); (med_aspm_f2_summary <- summary(med_aspm_f2));
med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE); (med_aspm_summary <- summary(med_aspm));

# MCPH1:
med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d_tb); (med_mcph1_f1_summary <- summary(med_mcph1_f1));
med_mcph1_f2 <- glm(tone_binary ~ MCPH1_freq_wavg + Africa, family=binomial(), data=d_tb); (med_mcph1_f2_summary <- summary(med_mcph1_f2));
med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE); (med_mcph1_summary <- summary(med_mcph1));
```

For *ASPM*-D:

- **total effect** (TE) of being in Africa on *tone1*: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$tau.coef, med_aspm_summary$tau.ci[1], med_aspm_summary$tau.ci[2], med_aspm_summary$tau.p)`, decomposed into:
- **average direct effect** (ADE): `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$z.avg, med_aspm_summary$z.avg.ci[1], med_aspm_summary$z.avg.ci[2], med_aspm_summary$z.avg.p)`, and
- **average indirect effect** (ACME) mediated by *ASPM*-D: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$d.avg, med_aspm_summary$d.avg.ci[1], med_aspm_summary$d.avg.ci[2], med_aspm_summary$d.avg.p)`, mediating `r sprintf("%.1f%% (%.1f%%, %.1f%%), *p*=%.2g", 100*med_aspm_summary$n.avg, 100*med_aspm_summary$n.avg.ci[1], 100*med_aspm_summary$n.avg.ci[2], med_aspm_summary$n.avg.p)` of the effect, resulting from:

  + effect of being in Africa on *ASPM*-D: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_aspm_f1_summary$coefficients["AfricaYes", "Estimate"], med_aspm_f1_summary$coefficients["AfricaYes", "Std. Error"], med_aspm_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"])`, and
  + effect of *ASPM*-D on *tone1*: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Estimate"], med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Std. Error"], med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`.

For *MCPH1*-D:

- **TE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$tau.coef, med_mcph1_summary$tau.ci[1], med_mcph1_summary$tau.ci[2], med_mcph1_summary$tau.p)`, decomposed into:
- **ADE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$z.avg, med_mcph1_summary$z.avg.ci[1], med_mcph1_summary$z.avg.ci[2], med_mcph1_summary$z.avg.p)`, and
- **ACME**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$d.avg, med_mcph1_summary$d.avg.ci[1], med_mcph1_summary$d.avg.ci[2], med_mcph1_summary$d.avg.p)`, mediating `r sprintf("%.1f%% (%.1f%%, %.1f%%), *p*=%.2g", 100*med_mcph1_summary$n.avg, 100*med_mcph1_summary$n.avg.ci[1], 100*med_mcph1_summary$n.avg.ci[2], med_mcph1_summary$n.avg.p)` of the effect, resulting from:

  + effect of being in Africa on *MCPH1*-D: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_mcph1_f1_summary$coefficients["AfricaYes", "Estimate"], med_mcph1_f1_summary$coefficients["AfricaYes", "Std. Error"], med_mcph1_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"])`, and
  + effect of *MCPH1*-D on *tone1*: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Estimate"], med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Std. Error"], med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"])`.


###### `brms`

```{r include=FALSE}
if( file.exists("./cache-results/brms_tb_med.RData") )
{
  load("./cache-results/brms_tb_med.RData");
} else
{
  # Mediation with brms:
  # ASPM:
  bmed_africa_aspm__tb <- .fit_mediation_model(d=d_tb, 
                                               outcome="tone_binary", outcome_name="tone", 
                                               treatment="Africa", treatment_name="Africa", 
                                               mediator="ASPM_freq_wavg_4beta", mediator_name="ASPM", 
                                               family_mediator=Beta(), family_outcome=bernoulli("logit"), ranefs="(1 | family_name / metapop)",
                                               cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                               save_model=FALSE, show_results=TRUE);
  
  # MCPH1:
  bmed_africa_mcph1__tb <- .fit_mediation_model(d=d_tb, 
                                                outcome="tone_binary", outcome_name="tone", 
                                                treatment="Africa", treatment_name="Africa", 
                                                mediator="MCPH1_freq_wavg_4beta", mediator_name="MCPH1", 
                                                family_mediator=Beta(), family_outcome=bernoulli("logit"), ranefs="(1 | family_name / metapop)",
                                                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                                save_model=FALSE, show_results=TRUE);
  
  # Save these results to file:
  save(bmed_africa_aspm__tb, bmed_africa_mcph1__tb, 
       file="./cache-results/brms_tb_med.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *ASPM*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_aspm__tb; .plot_mediation_model(m$summary, m$mediation, 
                                                 outcome=m$outcome, outcome_name=m$outcome_name, 
                                                 treatment=m$treatment, treatment_name=m$treatment_name, 
                                                 mediator=m$mediator, mediator_name=m$mediator_name);
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *MCPH1*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_mcph1__tb; .plot_mediation_model(m$summary, m$mediation, 
                                                  outcome=m$outcome, outcome_name=m$outcome_name, 
                                                  treatment=m$treatment, treatment_name=m$treatment_name, 
                                                  mediator=m$mediator, mediator_name=m$mediator_name);
```


##### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/med_tb_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  med_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tb);
    
    # ASPM:
    med_aspm_f1 <- med_aspm_f2 <- med_aspm <- NULL;
    try(med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_aspm_f1) ){ return (NULL); }; (med_aspm_f1_summary <- summary(med_aspm_f1));
    try(med_aspm_f2 <- glm(tone_binary ~ ASPM_freq_wavg + Africa, family=binomial(), data=d), silent=TRUE); if( is.null(med_aspm_f2) ){ return (NULL); }; (med_aspm_f2_summary <- summary(med_aspm_f2));
    try(med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_aspm) ){ return (NULL); }; (med_aspm_summary <- summary(med_aspm));
    
    # MCPH1:
    med_mcph1_f1 <- med_mcph1_f2 <- med_mcph1 <- NULL;
    try(med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_mcph1_f1) ){ return (NULL); }; (med_mcph1_f1_summary <- summary(med_mcph1_f1));
    try(med_mcph1_f2 <- glm(tone_binary ~ MCPH1_freq_wavg + Africa, family=binomial(), data=d), silent=TRUE); if( is.null(med_mcph1_f2) ){ return (NULL); }; (med_mcph1_f2_summary <- summary(med_mcph1_f2));
    try(med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_mcph1) ){ return (NULL); }; (med_mcph1_summary <- summary(med_mcph1));
    
    # Return value:
    data.frame(
      # ASPM:
      "aspm_TE"=med_aspm_summary$tau.coef, "aspm_TE_95low"=med_aspm_summary$tau.ci[1],     "aspm_TE_95high"=med_aspm_summary$tau.ci[2],     "aspm_TE_p"=med_aspm_summary$tau.p,
      "aspm_ADE"=med_aspm_summary$z.avg,   "aspm_ADE_95low"=med_aspm_summary$z.avg.ci[1],  "aspm_ADE_95high"=med_aspm_summary$z.avg.ci[2],  "aspm_ADE_p"=med_aspm_summary$z.avg.p,
      "aspm_ACME"=med_aspm_summary$d.avg,  "aspm_ACME_95low"=med_aspm_summary$d.avg.ci[1], "aspm_ACME_95high"=med_aspm_summary$d.avg.ci[2], "aspm_ACME_p"=med_aspm_summary$d.avg.p,
      "aspm_prop"=med_aspm_summary$n.avg,  "aspm_prop_95low"=med_aspm_summary$n.avg.ci[1], "aspm_prop_95high"=med_aspm_summary$n.avg.ci[2], "aspm_prop_p"=med_aspm_summary$n.avg.p,
      "aspm_Afr_gene_b"=med_aspm_f1_summary$coefficients["AfricaYes", "Estimate"], "aspm_Afr_gene_b_stderr"=med_aspm_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "aspm_Afr_gene_p"=med_aspm_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "aspm_gene_tone_b"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Estimate"], "aspm_gene_tone_b_stderr"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Std. Error"],
      "aspm_gene_tone_p"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Pr(>|z|)"],
      # MCPH1:
      "mcph1_TE"=med_mcph1_summary$tau.coef, "mcph1_TE_95low"=med_mcph1_summary$tau.ci[1],     "mcph1_TE_95high"=med_mcph1_summary$tau.ci[2],     "mcph1_TE_p"=med_mcph1_summary$tau.p,
      "mcph1_ADE"=med_mcph1_summary$z.avg,   "mcph1_ADE_95low"=med_mcph1_summary$z.avg.ci[1],  "mcph1_ADE_95high"=med_mcph1_summary$z.avg.ci[2],  "mcph1_ADE_p"=med_mcph1_summary$z.avg.p,
      "mcph1_ACME"=med_mcph1_summary$d.avg,  "mcph1_ACME_95low"=med_mcph1_summary$d.avg.ci[1], "mcph1_ACME_95high"=med_mcph1_summary$d.avg.ci[2], "mcph1_ACME_p"=med_mcph1_summary$d.avg.p,
      "mcph1_prop"=med_mcph1_summary$n.avg,  "mcph1_prop_95low"=med_mcph1_summary$n.avg.ci[1], "mcph1_prop_95high"=med_mcph1_summary$n.avg.ci[2], "mcph1_prop_p"=med_mcph1_summary$n.avg.p,
      "mcph1_Afr_gene_b"=med_mcph1_f1_summary$coefficients["AfricaYes", "Estimate"], "mcph1_Afr_gene_b_stderr"=med_mcph1_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "mcph1_Afr_gene_p"=med_mcph1_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "mcph1_gene_tone_b"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Estimate"], "MCPH1_gene_tone_b_stderr"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Std. Error"],
      "mcph1_gene_tone_p"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"], 
      row.names=NULL);
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, med_samples_per_fam, file="./cache-results/med_tb_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/med_tb_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=3*4, fig.cap=capFig(paste0("Mediation analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost panels show the distribution of point estimates of the Total Effect (TE), the Direct Effect (ADE) and the Indirect Effect (ACME) for *ASPM*-D and *MCPH1*-D; the middle panels show the distribution of the *p*-values for the same effects, while the rightmost panels show the distribution of the regression slopes (*β*) for the two alleles, top: for the regression of the allele frequency on within vs outside Africa, and bottom: for the regression of tone on the allele while controlling for within vs outside Africa. The black vertical lines show: 0.0 (solid), 0.05 (dashed) and 0.10 (dotted)."))}
p1 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE", "aspm_ADE", "aspm_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.30, 0.75) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               #scale_color_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation estimates")) + theme(legend.position="bottom");
             
p2 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE_p", "aspm_ADE_p", "aspm_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p3 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_Afr_gene_b", "mcph1_Afr_gene_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.8,0.1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Allele", labels=c("aspm_Afr_gene_b"=expression(" "~italic("ASPM")-D), "mcph1_Afr_gene_b"=expression(" "~italic("MCPH1")-D)), values=c("aspm_Afr_gene_b"="yellow", "mcph1_Afr_gene_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("Africa " %->% " allele"))) + theme_bw() + theme(legend.position="bottom");
             
p4 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE", "mcph1_ADE", "mcph1_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.30, 0.75) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation estimates")) + theme(legend.position="none");
             
p5 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE_p", "mcph1_ADE_p", "mcph1_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p6 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_gene_tone_b", "mcph1_gene_tone_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-10,10) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Gene", values=c("aspm_gene_tone_b"="yellow", "mcph1_gene_tone_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("allele " %->% " tone | Africa"))) + theme_bw() + theme(legend.position="none");
             
l1 <- get_legend(p1);
l3 <- get_legend(p3);

grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
```


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone1_mediation_restricted.pdf", width=3*3.3, height=2*2.5+0.15); 
grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
dev.off();
```

For *ASPM*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_TE,na.rm=TRUE), median(med_samples_per_fam$aspm_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ADE,na.rm=TRUE), median(med_samples_per_fam$aspm_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ACME,na.rm=TRUE), median(med_samples_per_fam$aspm_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

For *MCPH1*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_TE,na.rm=TRUE), median(med_samples_per_fam$mcph1_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), median(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), median(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

Given the low sample size *N* = `r length(unique(d_tb$family_name))` unique families, relatively few effect sizes are big enough to be significant for each individual analysis; however, there are many more significant ACMEs for *ASPM*-D than for *MCPH1*-D: `r sprintf("%.1f%% vs %.1f%% (%.1f times) for *α*-level 0.05, and %.1f%% vs %.1f%% (%.1f times) for *α*-level 0.10", 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE))`.


#### Path analysis

##### All data

```{r include=FALSE}
## Path analysis:
# The model (numeric):
sem_tone_num <- '
    # tone:
    tone_bin_num ~ Africa_num + ASPM_freq_wavg + MCPH1_freq_wavg

    # the alleles:
    ASPM_freq_wavg  ~ Africa_num
    MCPH1_freq_wavg ~ Africa_num
  ';
semfit_tone_num <- sem(sem_tone_num, data=d_tb, se="robust.sem");
summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
(semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));
mi_tone_num <- modindices(semfit_tone_num);

# The model (ordered):
sem_tone_ord <- '
    # tone:
    tone_bin_ord ~ Africa_ord + ASPM_freq_wavg + MCPH1_freq_wavg

    # the alleles:
    ASPM_freq_wavg  ~ Africa_ord
    MCPH1_freq_wavg ~ Africa_ord
  ';
semfit_tone_ord <- sem(sem_tone_ord, data=d_tb, se="robust.sem");
summary(semfit_tone_ord, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
lavaanPlot(model=semfit_tone_ord, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
(semfit_tone_ord_measures <- fitMeasures(semfit_tone_ord, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));
mi_tone_ord <- modindices(semfit_tone_ord);
```

With Africa and *tone1* coded numerically, the model fits the data very well[^SEM_INTERPRETATION] (`r sprintf("*&chi;*^2^(%d)=%.2f, *p*=%.2g; CFI=%.2f, TLI=%.2f, NNFI=%.2f and RFI=%.2f", semfit_tone_num_measures["df"], semfit_tone_num_measures["chisq"], semfit_tone_num_measures["pvalue"], semfit_tone_num_measures["cfi"], semfit_tone_num_measures["tli"], semfit_tone_num_measures["nnfi"], semfit_tone_num_measures["rfi"])`):

```{r fig.cap=capFig("Path analysis model with standardised coefficients and significance stars. *tone1* and *macroarea* (Africa vs non-Africa) are coded as numeric binary (`tone_bin_num` with Yes=1 and `Africa_num` with in Africa=1); `ASPM_freq_wavg` is *ASPM*-D and `MCPH1_freq_wavg` is *MCPH1*-D.")}
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=TRUE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```

[^SEM_INTERPRETATION]: Please note that for path analyses/SEM models, we want the goodness-of-fit *&chi;*^2^ test to be *non-significant*, meaning that there is no reason to reject the hypothesis that the model fits the data. On the other hand, there is a plethora of goodness of fit indices (we show a few) where the idea is that the closer they are to 1.00 the better the model fits to the data.

Likewise, with Africa and *tone1* coded as ordered binary factors, the model also fits the data very well (`r sprintf("*&chi;*^2^(%d)=%.2f, *p*=%.2g; CFI=%.2f, TLI=%.2f, NNFI=%.2f and RFI=%.2f", semfit_tone_ord_measures["df"], semfit_tone_ord_measures["chisq"], semfit_tone_ord_measures["pvalue"], semfit_tone_ord_measures["cfi"], semfit_tone_ord_measures["tli"], semfit_tone_ord_measures["nnfi"], semfit_tone_ord_measures["rfi"])`):

```{r fig.cap=capFig("Path analysis model with standardised coefficients and significance stars. *tone1* and *macroarea* (Africa vs non-Africa) are coded as ordered binary factors (`tone_bin_ord` with No < Yes, and `Africa_ord` with outside Africa < in Africa); `ASPM_freq_wavg` is *ASPM*-D and `MCPH1_freq_wavg` is *MCPH1*-D.")}
lavaanPlot(model=semfit_tone_ord, coefs=TRUE, sig=1.00, stand=TRUE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```


##### Restricted sampling

Here I use only the numerical coding.

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/sem_tb_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  sem_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tb);
    
    # Fit the model:
    semfit_tone_num <- NULL;
    try(semfit_tone_num <- sem(sem_tone_num, data=d, se="robust.sem"), silent=TRUE);
    if( is.null(semfit_tone_num) ){ return(NULL); }
    semfit_tone_num_summary <- summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
    #lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
    (semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));

    # Return value:
    tmp <- semfit_tone_num_summary$PE;
    cbind(
      as.data.frame(matrix(semfit_tone_num_measures, nrow=1, dimnames=list("", names(semfit_tone_num_measures)))),
      data.frame(
        "Afr_aspm_b"  =tmp$est[tmp$lhs=="ASPM_freq_wavg"     & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_aspm_p"  =tmp$pvalue[tmp$lhs=="ASPM_freq_wavg"  & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_mcph1_b" =tmp$est[tmp$lhs=="MCPH1_freq_wavg"    & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_mcph1_p" =tmp$pvalue[tmp$lhs=="MCPH1_freq_wavg" & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_tone_b"  =tmp$est[tmp$lhs=="tone_bin_num"       & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_tone_p"  =tmp$pvalue[tmp$lhs=="tone_bin_num"    & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "aspm_tone_b" =tmp$est[tmp$lhs=="tone_bin_num"       & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],  
        "aspm_tone_p" =tmp$pvalue[tmp$lhs=="tone_bin_num"    & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],
        "mcph1_tone_b"=tmp$est[tmp$lhs=="tone_bin_num"       & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"], 
        "mcph1_tone_p"=tmp$pvalue[tmp$lhs=="tone_bin_num"    & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"],
        row.names=NULL));
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, sem_samples_per_fam, file="./cache-results/sem_tb_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/sem_tb_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=2*4, fig.cap=capFig(paste0("Path analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost row of two plots shows the coefficient estimates and the *p*-values, respectively, for the five paths in the model (see the path plots above). The rightmost plot shows the various fit indices. The black horiontal lines show: 0.0 (solid), 0.05 (dashed) and 1.0 (dotted)."))}
grid.arrange(ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_b", "Afr_mcph1_b", "Afr_tone_b", "aspm_tone_b", "mcph1_tone_b")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_b"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_b"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_b"=expression("Africa " %->% " tone1"), "aspm_tone_b"=expression("ASPM-D " %->% " tone1"), "mcph1_tone_b"=expression("MCPH1-D " %->% " tone1"))) + 
               xlab("Path") + ylab("Coefficient") + ggtitle("Path coeffcients") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("pvalue", "cfi", "tli", "nnfi", "rfi")]),
                    aes(x=variable, y=value, fill=variable)) + ylim(0,NA) + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=c(0.05, 1.0), color="black", linetype=c("dashed", "dotted")) +
               scale_fill_discrete(name="Fit indices", labels=c("pvalue"=expression(chi^2~italic(p)~"-value"), "cfi"="CFI", "tli"="TLI", "nnfi"="NNFI", "rfi"="RFI")) + 
               ylab("Estimate") + xlab("Fit indices") + ggtitle("Fit indices") + theme(legend.position="right"),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_p", "Afr_mcph1_p", "Afr_tone_p", "aspm_tone_p", "mcph1_tone_p")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.05, color="black", linetype="dashed") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_p"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_p"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_p"=expression("Africa " %->% " tone1"), "aspm_tone_p"=expression("ASPM-D " %->% " tone1"), "mcph1_tone_p"=expression("MCPH1-D " %->% " tone1"))) + 
               xlab("Path") + ylab("p-value") + ggtitle("Path p-values") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             nrow=2);
```

- models fits: 
  + `r round(100*sum(sem_samples_per_fam$pvalue >= 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam),1)`% of the *p*-values are not significant
  + mean(CFI) = `r round(mean(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, median(CFI) = `r round(median(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, sd(CFI) = `r round(sd(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, IQR(CFI) = `r round(IQR(sem_samples_per_fam$cfi, na.rm=TRUE),2)`
  + mean(TLI) = `r round(mean(sem_samples_per_fam$tli, na.rm=TRUE),2)`, median(TLI) = `r round(median(sem_samples_per_fam$tli, na.rm=TRUE),2)`, sd(TLI) = `r round(sd(sem_samples_per_fam$tli, na.rm=TRUE),2)`, IQR(TLI) = `r round(IQR(sem_samples_per_fam$tli, na.rm=TRUE),2)`
  + mean(NNFI) = `r round(mean(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, median(NNFI) = `r round(median(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, sd(NNFI) = `r round(sd(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, IQR(NNFI) = `r round(IQR(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`
  + mean(RFI) = `r round(mean(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, median(RFI) = `r round(median(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, sd(RFI) = `r round(sd(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, IQR(RFI) = `r round(IQR(sem_samples_per_fam$rfi, na.rm=TRUE),2)`

- Africa → *ASPM*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_aspm_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_aspm_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_aspm_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- Africa → *MCPH1*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_mcph1_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_mcph1_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_mcph1_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- Africa → *tone1*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% > 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_tone_b > 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_tone_b, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- *ASPM*-D → *tone1*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), median(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$aspm_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$aspm_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$aspm_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- *MCPH1*-D → *tone1*: `r sprintf("mean = %.2g, median = %.2g, as = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), median(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$mcph1_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$mcph1_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$mcph1_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.


### Machine Learning techniques

Here I apply various "machine learning" techniques to explore how well the *macroarea* and the two alleles predict *tone1*. 
For these techniques, in general I:

a) fit the model to the *full* data and estimate how well these modes fit, but also
b) repeatedly split the data into a *training* set the complementary *test* set; the first usually contains a random subset of 80% of the data and is used to fit the model, while the second, containing the remaining 20% of the data, is used to check how well the model generalizes to new data.

Thus, these techniques can:

- quantify the *amount of information* about tone contained by macroarea and the alleles,
- but also give an estimate of the *relative importance* of these variables as predictors.

```{r include=FALSE}
# The predictors:
list_predictors      <- c("ASPM_freq_wavg", "MCPH1_freq_wavg", "macroarea");
list_predictors_labs <- c("ASPM.D", "MCPH1.D", "macroarea"); # with pretty labels for plotting
f_tone               <- formula(paste0("tone_binary ~ ", paste0(list_predictors,collapse=" + ")));
f_tone_labs          <- formula(paste0("tone_binary ~ ", paste0(list_predictors_labs,collapse=" + ")));
list_predictors_nomacroarea      <- list_predictors[ list_predictors != "macroarea" ];
list_predictors_nomacroarea_labs <- list_predictors_labs[ list_predictors_labs != "macroarea" ];
f_tone_nomacroarea               <- formula(paste0("tone_binary ~ ", paste0(list_predictors_nomacroarea,collapse=" + ")));
f_tone_nomacroarea_labs          <- formula(paste0("tone_binary ~ ", paste0(list_predictors_nomacroarea_labs,collapse=" + ")));

# Dataset with pretty labels for plotting:
d_tb_labels <- d_tb;
names(d_tb_labels)[ names(d_tb_labels) == "ASPM_freq_wavg" ]  <- "ASPM.D";
names(d_tb_labels)[ names(d_tb_labels) == "MCPH1_freq_wavg" ] <- "MCPH1.D";

# Generate the training/testing splits into a training (80%) and a testing (20%) set stratified by macroarea:
n_train <- 100; # the number of training/testing splits
# Make sure all macroareas in the test data are also in the training data:
if( file.exists("./cache-results/train_test_splits_tb.RData") )
{
  load("./cache-results/train_test_splits_tb.RData");
} else
{
  k <- 0; success_splitting <- FALSE;
  while(k < 100)
  {
    success_splitting <- TRUE;
    train_test_splits <- lapply(1:n_train, function(i) rsample::initial_split(d_tb, prop=0.80, strata="macroarea"));
    for( i in 1:n_train )
    {
      data_train <- training(train_test_splits[[i]]);
      data_test  <- testing(train_test_splits[[i]]);
      if( !all(unique(data_test$macroarea) %in% unique(data_train$macroarea)) )
      {
        # Try again: 
        success_splitting <- FALSE; break;
      }
    }
    if( success_splitting ) break; 
    
    # Try again:
    k <- k + 1;
  }
  if( !success_splitting && k == 100 ) stop("Error: cannot split the data into traning and testing sets by macroareas!\n");
  # Save these results to file:
  save(train_test_splits, file="./cache-results/train_test_splits_tb.RData", compress="xz", compression_level=9);
}
```


#### Decision trees

##### Including macroarea

```{r include=FALSE}
### With macroareas:
if( file.exists("./cache-results/ctree_tb_m.RData") )
{
  load("./cache-results/ctree_tb_m.RData");
} else
{
  ## On the full dataset:
  ctree_tb_m_all <- ctree(f_tone_labs, data=d_tb_labels, control=ctree_control(testtype=c("MonteCarlo")));
  (cm_ctree_tb_m_all <- confusionMatrix(d_tb_labels$tone_binary, predict(ctree_tb_m_all), positive="Yes"));
  success_ctree_tb_m_all <- data.frame("accuracy"     =cm_ctree_tb_m_all$overall["Accuracy"],
                                       "sensitivity"  =cm_ctree_tb_m_all$byClass["Sensitivity"], 
                                       "specificity"  =cm_ctree_tb_m_all$byClass["Specificity"],
                                       "precision"    =cm_ctree_tb_m_all$byClass["Precision"],
                                       "recall"       =cm_ctree_tb_m_all$byClass["Recall"],
                                       row.names=NULL);
  
  ## On the training/testing sets:
  ctree_tb_m_traintest <- pblapply(1:n_train, function(i)
  {
    # split the data:
    data_train <- training(train_test_splits[[i]]);
    data_test  <- testing(train_test_splits[[i]]);
    
    # fit the models:
    ctree_model <- ctree(f_tone, data=data_train, control=ctree_control(testtype=c("MonteCarlo")));
    
    # confusion matrices:
    cm_ctree <- confusionMatrix(data_test$tone_binary, predict(ctree_model,  newdata=data_test, allow_new_levels=TRUE), positive="Yes");
    
    # return the results:
    success_ctree <- data.frame("replication"  =i, # replication
                                "accuracy"     =cm_ctree$overall["Accuracy"],
                                "sensitivity"  =cm_ctree$byClass["Sensitivity"], 
                                "specificity"  =cm_ctree$byClass["Specificity"],
                                "precision"    =cm_ctree$byClass["Precision"],
                                "recall"       =cm_ctree$byClass["Recall"],
                                row.names=NULL);
    
    return (list("replication"       =i,
                 "data_train_indices"=train_test_splits[[i]]$in_id, 
                 "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                 "success"=success_ctree));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  # Save these results to file:
  save(ctree_tb_m_all, cm_ctree_tb_m_all, success_ctree_tb_m_all, ctree_tb_m_traintest, 
       file="./cache-results/ctree_tb_m.RData", compress="xz", compression_level=9);
}
```

Using the frequency of the two alleles and the *macroarea* as predictors, the fit to the data is: `r sprintf("accuracy = %.1f%%, sensitivity = %.1f%%, specificity = %.1f%%, precision = %.1f%%, and recall = %.1f%%", 100*success_ctree_tb_m_all["accuracy"], 100*success_ctree_tb_m_all["sensitivity"], 100*success_ctree_tb_m_all["specificity"], 100*success_ctree_tb_m_all["precision"], 100*success_ctree_tb_m_all["recall"])`.

```{r fig.cap=capFig("Decision tree on the full data using the two alleles and *macroarea*. `ASPM.D` = *ASPM*-D.")}
plot(ctree_tb_m_all, gp=gpar(fontsize = 11));
```

On the `r n_train` training/testing sets, the fit is: `r success_ctree_tb_m_traintest <- do.call(rbind, lapply(ctree_tb_m_traintest, function(x) x$success)); paste0(names(success_ctree_tb_m_traintest)[-1], " = ", vapply(success_ctree_tb_m_traintest[,-1], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`.

```{r fig.cap=capFig("The success of generalising to the testing sets from the training sets (yellow boxplots) compared to the success on the full data (red segments).")}
ggplot(success_ctree_tb_m_traintest %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  # measures on the full dataset:
  geom_rect(data=success_ctree_tb_m_all %>% 
              reshape2::melt(measure.vars=c("accuracy", "sensitivity", "specificity", "precision", "recall"), variable.name="measure", value.name="value") %>%
              mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
            aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value-0.10, ymax=value+0.10), color="red", fill="red") +
  theme(legend.position="right");
```


##### Excluding macroarea

```{r include=FALSE}
if( file.exists("./cache-results/ctree_tb_nom.RData") )
{
  load("./cache-results/ctree_tb_nom.RData");
} else
{
  ### On the full dataset:
  ctree_tb_nom_all <- ctree(f_tone_nomacroarea_labs, data=d_tb_labels, control=ctree_control(testtype=c("MonteCarlo")));
  (cm_ctree_tb_nom_all <- confusionMatrix(d_tb_labels$tone_binary, predict(ctree_tb_nom_all), positive="Yes"));
  success_ctree_tb_nom_all <- data.frame("accuracy"     =cm_ctree_tb_nom_all$overall["Accuracy"],
                                         "sensitivity"  =cm_ctree_tb_nom_all$byClass["Sensitivity"], 
                                         "specificity"  =cm_ctree_tb_nom_all$byClass["Specificity"],
                                         "precision"    =cm_ctree_tb_nom_all$byClass["Precision"],
                                         "recall"       =cm_ctree_tb_nom_all$byClass["Recall"],
                                         row.names=NULL);
  
  ## On the training/testing sets:
  ctree_tb_nom_traintest <- pblapply(1:n_train, function(i) # very computationally expensive
  {
    # split the data:
    data_train <- training(train_test_splits[[i]]);
    data_test  <- testing(train_test_splits[[i]]);
    
    # fit the models:
    ctree_model <- ctree(f_tone_nomacroarea, data=data_train, control=ctree_control(testtype=c("MonteCarlo")));
    
    # confusion matrices:
    cm_ctree <- confusionMatrix(data_test$tone_binary, predict(ctree_model,  newdata=data_test, allow_new_levels=TRUE), positive="Yes");
    
    # return the results:
    success_ctree <- data.frame("replication"  =i, # replication
                                "accuracy"     =cm_ctree$overall["Accuracy"],
                                "sensitivity"  =cm_ctree$byClass["Sensitivity"], 
                                "specificity"  =cm_ctree$byClass["Specificity"],
                                "precision"    =cm_ctree$byClass["Precision"],
                                "recall"       =cm_ctree$byClass["Recall"],
                                row.names=NULL);
    
    return (list("replication"       =i,
                 "data_train_indices"=train_test_splits[[i]]$in_id, 
                 "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                 "success"=success_ctree));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  # Save these results to file:
  save(ctree_tb_nom_all, cm_ctree_tb_nom_all, success_ctree_tb_nom_all, ctree_tb_nom_traintest, 
       file="./cache-results/ctree_tb_nom.RData", compress="xz", compression_level=9);
}
```

When using the frequency of the two alleles only as predictors, the fit to the data is: `r sprintf("accuracy = %.1f%%, sensitivity = %.1f%%, specificity = %.1f%%, precision = %.1f%%, and recall = %.1f%%", 100*success_ctree_tb_nom_all["accuracy"], 100*success_ctree_tb_nom_all["sensitivity"], 100*success_ctree_tb_nom_all["specificity"], 100*success_ctree_tb_nom_all["precision"], 100*success_ctree_tb_nom_all["recall"])`:

```{r fig.cap=capFig("Decision tree on the full data using the two alleles only. `ASPM.D` = *ASPM*-D, `MCPH1.D` = *MCPH1*-D.")}
plot(ctree_tb_nom_all, gp=gpar(fontsize = 11));
```

On the `r n_train` training/testing sets,the fit is: `r success_ctree_tb_nom_traintest <- do.call(rbind, lapply(ctree_tb_nom_traintest, function(x) x$success)); paste0(names(success_ctree_tb_nom_traintest)[-1], " = ", vapply(success_ctree_tb_nom_traintest[,-1], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`.

```{r fig.cap=capFig("The success of generalising to the testing sets from the training sets (yellow boxplots) compared to the success on the full data (red segments).")}
ggplot(success_ctree_tb_nom_traintest %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  # measures on the full dataset:
  geom_rect(data=success_ctree_tb_nom_all %>% 
              reshape2::melt(measure.vars=c("accuracy", "sensitivity", "specificity", "precision", "recall"), variable.name="measure", value.name="value") %>%
              mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
            aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value-0.10, ymax=value+0.10), color="red", fill="red") +
  theme(legend.position="right");
```


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone1_decision_trees_macroarea.pdf", width=1*6.0, height=1*4.0);
plot(ctree_tb_m_all, gp=gpar(fontsize = 9));
dev.off();
cairo_pdf("./figures/tone1_decision_trees_nomacroarea.pdf", width=1*6.0, height=1*4.0);
plot(ctree_tb_nom_all, gp=gpar(fontsize = 9));
dev.off();
```


#### Random forests

I use two methods: random forests as implemented by `randomForest()` in package `randomForest`, and conditional random forests as implemented by `cforest()` in package `partykit`.
As (conditional) random forests do internal bootstrapping, there is no need for the explicit training/testing set repeated refitting.

```{r}
# Collect the success measures and the predictor importance based on the gini index (randomForest) and the accuracy indices (randomForest and cForest):
n_replications <- 100; # the number of replications
cf_ntree       <- 500; # the number of trees for cforest
cf_nperm       <- 10;  # number of permutations for cforest:varimp
```


##### Including macroarea

```{r include=FALSE}
## With macroareas:
if( !file.exists("./cache-results/forest_tb_m_all.RData") )
{
  forest_tb_m_all <- pblapply(1:n_replications, function(i) # computationally expensive
  {
    # fit the random forests:
    rf_tone <- cf_tone <- NULL;
    try(rf_tone <- randomForest(f_tone, data=d_tb, importance=TRUE), silent=TRUE);
    try(cf_tone <- cforest(f_tone, data=d_tb, ntree=cf_ntree), silent=TRUE);
    if( is.null(rf_tone) || is.null(cf_tone) ) return (NULL); # some error
    
    # confusion matrices:
    cm_rf_tone <- confusionMatrix(d_tb$tone_binary, rf_tone$predicted, positive="Yes");
    cm_cf_tone <- confusionMatrix(d_tb$tone_binary, predict(cf_tone),  positive="Yes");
    
    # predictor importance:
    pia_rf_tone <- pig_rf_tone <- piu_cf_tone <- NULL
    try(pia_rf_tone <- importance(rf_tone, type=1), silent=TRUE); # accuracy-based
    try(pig_rf_tone <- importance(rf_tone, type=2), silent=TRUE); # gini-based
    try(piu_cf_tone <- varimp(cf_tone, conditional=FALSE, nperm=cf_nperm), silent=TRUE); # unconditional
    if( is.null(pia_rf_tone) || is.null(pig_rf_tone) || is.null(piu_cf_tone) ) return (NULL); # some error
    
    # return the results:
    success <- data.frame("replication"     =i,                              # replication
                          "rf_accuracy"     =cm_rf_tone$overall["Accuracy"], # randomForest
                          "rf_sensitivity"  =cm_rf_tone$byClass["Sensitivity"], 
                          "rf_specificity"  =cm_rf_tone$byClass["Specificity"],
                          "rf_precision"    =cm_rf_tone$byClass["Precision"],
                          "rf_recall"       =cm_rf_tone$byClass["Recall"],
                          "cf_accuracy"     =cm_cf_tone$overall["Accuracy"], # cforest
                          "cf_sensitivity"  =cm_cf_tone$byClass["Sensitivity"], 
                          "cf_specificity"  =cm_cf_tone$byClass["Specificity"],
                          "cf_precision"    =cm_cf_tone$byClass["Precision"],
                          "cf_recall"       =cm_cf_tone$byClass["Recall"], 
                          row.names=NULL);
    pi_df  <- data.frame("replication"      =i,               # replication
                         "predictor"        =list_predictors, # predictors
                         "rf_accuracy_based"=pia_rf_tone,     # randomForest accuracy-based
                         "rf_gini_based"    =pig_rf_tone,     # randomForest gini-based
                         "cf_unconditional" =piu_cf_tone,     # cforest unconditional
                         row.names=NULL);
    
    return (list("replication"    =i,
                 "success"        =success,   
                 "pred_importance"=pi_df));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  
  # Assemble the various results and save them:
  forest_tb_m_all <- list("replications"   =n_replications,
                          "success"        =do.call(rbind, lapply(forest_tb_m_all, function(x) if(is.null(x)){ NULL; } else { x$success; })),
                          "pred_importance"=do.call(rbind, lapply(forest_tb_m_all, function(x) if(is.null(x)){ NULL; } else { x$pred_importance; })));
  save(forest_tb_m_all, file="./cache-results/forest_tb_m_all.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/forest_tb_m_all.RData");
}

forest_tb_m_all$pred_importance %>% 
  group_by(predictor) %>% 
  summarise("MeanDecreaseAccuracy" = sprintf("%.2f ±%.2f", mean(MeanDecreaseAccuracy, na.rm=TRUE), sd(MeanDecreaseAccuracy, na.rm=TRUE)),
            "MeanDecreaseGini" = sprintf("%.2f ±%.2f", mean(MeanDecreaseGini, na.rm=TRUE), sd(MeanDecreaseGini, na.rm=TRUE)),
            "cf_unconditional" = sprintf("%.2f ±%.2f", mean(cf_unconditional, na.rm=TRUE), sd(cf_unconditional, na.rm=TRUE)));
```

When using the frequency of the two alleles and the *macroarea* as predictors, the models fit to the full data is: 

- random forests: `r s <- grep("rf_", names(forest_tb_m_all$success), fixed=TRUE); paste0(substring(names(forest_tb_m_all$success)[s],4), " = ", vapply(forest_tb_m_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`,
- conditional random forests: `r s <- grep("cf_", names(forest_tb_m_all$success), fixed=TRUE); paste0(substring(names(forest_tb_m_all$success)[s],4), " = ", vapply(forest_tb_m_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`.

```{r fig.cap=capFig("The success of the two random forest methods on the full data."), fig.width=8, fig.height=4}
ggplot(forest_tb_m_all$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("method"=factor(if_else(substring(measure,1,2) == "rf", "random forest", "conditional random forest"), levels=c("random forest", "conditional random forest")), 
                "measure"=factor(substring(measure,4), levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), 
                "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  theme(legend.position="right") + 
  facet_grid(. ~ method);
```

```{r fig.cap=capFig("Variable importance using three methods: mean decrease in accuracy, mean decrease of the Gini coeficient, and unconditional importance. `ASPM_freq_wavg` = *ASPM*-D, `MCPH1_freq_wavg` = *MCPH1*-D."), fig.width=12, fig.height=4}
grid.arrange(ggplot(forest_tb_m_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseAccuracy, median), y=MeanDecreaseAccuracy, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease accuracy") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_tb_m_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseGini, median), y=MeanDecreaseGini, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease Gini index") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_tb_m_all$pred_importance, 
                    aes(x=reorder(predictor, cf_unconditional, median), y=cf_unconditional, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Unconditional importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ncol=3);
```


##### Excluding macroarea

```{r include=FALSE}
## Without macroareas:
if( !file.exists("./cache-results/forest_tb_nom_all.RData") )
{
  forest_tb_nom_all <- pblapply(1:n_replications, function(i) # computationally expensive
  {
    # fit the random forests:
    rf_tone <- cf_tone <- NULL;
    try(rf_tone <- randomForest(f_tone_nomacroarea, data=d_tb, importance=TRUE), silent=TRUE);
    try(cf_tone <- cforest(f_tone_nomacroarea, data=d_tb, ntree=cf_ntree), silent=TRUE);
    if( is.null(rf_tone) || is.null(cf_tone) ) return (NULL); # some error
    
    # confusion matrices:
    cm_rf_tone <- confusionMatrix(d_tb$tone_binary, rf_tone$predicted, positive="Yes");
    cm_cf_tone <- confusionMatrix(d_tb$tone_binary, predict(cf_tone),  positive="Yes");
    
    # predictor importance:
    pia_rf_tone <- pig_rf_tone <- piu_cf_tone <- NULL
    try(pia_rf_tone <- importance(rf_tone, type=1), silent=TRUE); # accuracy-based
    try(pig_rf_tone <- importance(rf_tone, type=2), silent=TRUE); # gini-based
    try(piu_cf_tone <- varimp(cf_tone, conditional=FALSE, nperm=cf_nperm), silent=TRUE); # unconditional
    if( is.null(pia_rf_tone) || is.null(pig_rf_tone) || is.null(piu_cf_tone) ) return (NULL); # some error
    
    # return the results:
    success <- data.frame("replication"     =i,                              # replication
                          "rf_accuracy"     =cm_rf_tone$overall["Accuracy"], # randomForest
                          "rf_sensitivity"  =cm_rf_tone$byClass["Sensitivity"], 
                          "rf_specificity"  =cm_rf_tone$byClass["Specificity"],
                          "rf_precision"    =cm_rf_tone$byClass["Precision"],
                          "rf_recall"       =cm_rf_tone$byClass["Recall"],
                          "cf_accuracy"     =cm_cf_tone$overall["Accuracy"], # cforest
                          "cf_sensitivity"  =cm_cf_tone$byClass["Sensitivity"], 
                          "cf_specificity"  =cm_cf_tone$byClass["Specificity"],
                          "cf_precision"    =cm_cf_tone$byClass["Precision"],
                          "cf_recall"       =cm_cf_tone$byClass["Recall"], 
                          row.names=NULL);
    pi_df  <- data.frame("replication"      =i,               # replication
                         "predictor"        =list_predictors_nomacroarea, # predictors
                         "rf_accuracy_based"=pia_rf_tone,     # randomForest accuracy-based
                         "rf_gini_based"    =pig_rf_tone,     # randomForest gini-based
                         "cf_unconditional" =piu_cf_tone,     # cforest unconditional
                         row.names=NULL);
    
    return (list("replication"    =i,
                 "success"        =success,   
                 "pred_importance"=pi_df));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  
  # Assemble the various results and save them:
  forest_tb_nom_all <- list("replications"   =n_replications,
                          "success"        =do.call(rbind, lapply(forest_tb_nom_all, function(x) if(is.null(x)){ NULL; } else { x$success; })),
                          "pred_importance"=do.call(rbind, lapply(forest_tb_nom_all, function(x) if(is.null(x)){ NULL; } else { x$pred_importance; })));
  save(forest_tb_nom_all, file="./cache-results/forest_tb_nom_all.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/forest_tb_nom_all.RData");
}

forest_tb_nom_all$pred_importance %>% 
  group_by(predictor) %>% 
  summarise("MeanDecreaseAccuracy" = sprintf("%.2f ±%.2f", mean(MeanDecreaseAccuracy, na.rm=TRUE), sd(MeanDecreaseAccuracy, na.rm=TRUE)),
            "MeanDecreaseGini" = sprintf("%.2f ±%.2f", mean(MeanDecreaseGini, na.rm=TRUE), sd(MeanDecreaseGini, na.rm=TRUE)),
            "cf_unconditional" = sprintf("%.2f ±%.2f", mean(cf_unconditional, na.rm=TRUE), sd(cf_unconditional, na.rm=TRUE)));
```

When using the frequency of the two alleles only, the models fit the full as: 

- random forests: `r s <- grep("rf_", names(forest_tb_nom_all$success), fixed=TRUE); paste0(substring(names(forest_tb_nom_all$success)[s],4), " = ", vapply(forest_tb_nom_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`,
- conditional random forests: `r s <- grep("cf_", names(forest_tb_nom_all$success), fixed=TRUE); paste0(substring(names(forest_tb_nom_all$success)[s],4), " = ", vapply(forest_tb_nom_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`.

```{r fig.cap=capFig("The success of the two random forest methods on the full data."), fig.width=8, fig.height=4}
ggplot(forest_tb_nom_all$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("method"=factor(if_else(substring(measure,1,2) == "rf", "random forest", "conditional random forest"), levels=c("random forest", "conditional random forest")), 
                "measure"=factor(substring(measure,4), levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), 
                "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  theme(legend.position="right") + 
  facet_grid(. ~ method);
```

```{r fig.cap=capFig("Variable importance using three methods: mean decrease in accuracy, mean decrease of the Gini coeficient, and unconditional importance. `ASPM_freq_wavg` = *ASPM*-D, `MCPH1_freq_wavg` = *MCPH1*-D."), fig.width=12, fig.height=4}
grid.arrange(ggplot(forest_tb_nom_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseAccuracy, median), y=MeanDecreaseAccuracy, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease accuracy") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_tb_nom_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseGini, median), y=MeanDecreaseGini, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease Gini index") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_tb_nom_all$pred_importance, 
                    aes(x=reorder(predictor, cf_unconditional, median), y=cf_unconditional, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Unconditional importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ncol=3);
```



## *tone2* (is there *complex* tone?)


```{r include=FALSE}
# Split 3-way into complex vs none+simple:
# Keep only the observation with non-missing data for the relevant variables:
d_t3 <- unique(data_all[complete.cases(data_all[, c("tone_3way", "tone_binary",
                                                    "ASPM_freq_wavg", "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta",
                                                    "family_name", "macroarea", "metapop_ID")]), 
                        c("metapop", "metapop_ID", "pop_ID", "glottocode", "family_name", "macroarea", "latitude", "longitude", 
                          "tone_3way", "tone_binary", "ASPM_freq_wavg" , "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta")]);
# and only the observations of the same pop_ID that have different tone and gene frequency data:
lgs_to_keep <- d_t3 %>% group_by(metapop, pop_ID, tone_3way, ASPM_freq_wavg, MCPH1_freq_wavg) %>%
  summarise("keep_glottocode"=glottocode[1]);
d_t3 <- d_t3[ d_t3$glottocode %in% lgs_to_keep$keep_glottocode, ];

# None vs simple+complex:
d_t3$tone_yes <- factor(ifelse(d_t3$tone_3way == "None", "No", "Yes"), levels=c("No", "Yes"));
table(d_t3[,c("tone_yes", "tone_binary")]); # <- almost perfect match (1 mismatch out of 160 for Ket kett1243)!

# Complex vs non+simple:
d_t3$tone_complex <- factor(ifelse(d_t3$tone_3way == "Complex", "Yes", "No"), levels=c("No", "Yes"));

# Dichotomise macroarea:
d_t3$Africa <- factor(ifelse(d_t3$macroarea == "Africa", "Yes", "No"), levels=c("No", "Yes"));

# Recode tone and Africa as numeric and ordered:
d_t3$Africa_num   <- as.numeric(d_t3$Africa == "Yes");
d_t3$Africa_ord   <- ordered(d_t3$Africa, levels=c("No", "Yes"));
d_t3$tone_complex_num <- as.numeric(d_t3$tone_complex == "Yes");
d_t3$tone_complex_ord <- ordered(d_t3$tone_complex, levels=c("No", "Yes"));
```

I kept only the entries with non-missing data for the *tone2*, *ASPM*-D and *MCPH1*-D, and if there are more than one possible languages or allele frequencies for a given sample, I only kept those entries that have different tone or allele data.
The resulting dataset has `r nrow(d_t3)` observations, distributed among `r length(unique(d_t3$glottocode))` unique Glottolg codes in `r length(unique(d_t3$family))` families (ranging from a minimum of 1 language per family to a maximum of `r max(tmp <- as.numeric(table(d_t3$family)))`, with a mean `r round(mean(tmp),1)` and median `r round(median(tmp),1)` languages per family) and `r length(unique(d_t3$macroarea))` macroareas.

```{r fig.cap=capFig("Distribution of *tone2*.")}
distrib_all <- ggplot(as.data.frame(table(d_t3$tone_complex)), aes(x="Whole database", y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone") + ylab("Count") + 
  scale_fill_viridis_d("Complex tone?") + theme(legend.position="top") + 
  NULL;
#distrib_all;

pander(addmargins(tmp <- table(d_t3$tone_complex, d_t3$macroarea)));

distrib_macroarea <- ggplot(as.data.frame(tmp), aes(x=Var2, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone") + ylab("Count") + 
  scale_fill_viridis_d("Complex tone?") + theme(legend.position="top") + 
  NULL;
#distrib_macroarea;

grid.arrange(distrib_all + ggtitle("Overall distribution") + theme(legend.position="right") + xlab(""), 
             distrib_macroarea + ggtitle("By macroarea") + theme(legend.position="none") + xlab(""),
             nrow=1);
```

```{r fig.cap=capFig("Map of *tone2*.")}
ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d_t3, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=tone_complex)) +
  theme(legend.position = c(0.25, 0.32), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) + 
  scale_fill_viridis_d("Complex tone?");
```

```{r fig.cap=capFig("Relationship between *tone2*, *ASPM*-D and *MCPH1*-D."), fig.width=2*5, fig.height=2*3.2}
tmp <- d_t3; tmp$macroarea <- "All"; tmp <- rbind(tmp, d_t3); tmp$macroarea <- factor(tmp$macroarea, levels=c("All", "Africa", "America", "Eurasia", "Papunesia"));
plot_tone2_alleles_p1 <- ggplot(tmp, aes(x=ASPM_freq_wavg, y=MCPH1_freq_wavg)) + xlim(0,1) + ylim(0,1) + 
  xlab(expression(italic("ASPM")-"D")) + ylab(expression(italic("MCPH1")-"D")) +
  geom_point(aes(shape=tone_complex, fill=tone_complex), alpha=0.75, color="black") + 
  #geom_smooth(method="lm", formula=y~poly(x,2), color="black", alpha=0.25, size=0.5) + 
  facet_grid(. ~ macroarea) +
  #scale_color_manual("tone2", values=c("Yes"="blue", "No"="red")) + scale_shape("tone2") + 
  scale_fill_viridis_d(expression(italic("tone2"))) + scale_shape_manual(expression(italic("tone2")), values=c("Yes"=24, "No"=21)) + 
  ggtitle(expression(italic("ASPM")-"D, "~italic("MCPH1")-"D & "~italic("tone2")));
plot_tone2_alleles_p2 <- ggplot(tmp, aes(x=ASPM_freq_wavg, fill=tone_complex)) + xlim(0,1) +
  geom_jitter(aes(y=tone_complex, shape=tone_complex), alpha=0.50, color="black") + 
  geom_violin(aes(y=tone_complex), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=tone_complex), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("ASPM")-"D")) + ylab(expression(italic("tone2"))) +
  #scale_fill_manual("tone2", values=c("Yes"="blue", "No"="red")) + scale_shape("tone2") + 
  scale_fill_viridis_d(expression(italic("tone2"))) + scale_shape_manual(expression(italic("tone2")), values=c("Yes"=24, "No"=21)) + 
  ggtitle(expression(italic("tone2")~" vs "~italic("ASPM")-"D"));
plot_tone2_alleles_p3 <- ggplot(tmp, aes(x=MCPH1_freq_wavg, fill=tone_complex)) + xlim(0,1) +
  geom_jitter(aes(y=tone_complex, shape=tone_complex), alpha=0.50, color="black") + 
  geom_violin(aes(y=tone_complex), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=tone_complex), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("MCPH1")-"D")) + ylab(expression(italic("tone2"))) +
  #scale_fill_manual("tone2", values=c("Yes"="blue", "No"="red")) + scale_shape("tone2") + coord_flip() + 
  scale_fill_viridis_d(expression(italic("tone2"))) + scale_shape_manual(expression(italic("tone2")), values=c("Yes"=24, "No"=21)) + coord_flip() + 
  ggtitle(expression(italic("tone2")~" vs "~italic("MCPH1")-"D"));
grid.arrange(plot_tone2_alleles_p1, plot_tone2_alleles_p2, plot_tone2_alleles_p3, nrow=3);
```

Please note that the distribution of this variable is very skewed, so the results might not be very solid...


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone2_distribution.pdf", width=2*3.5, height=1*3.5);
grid.arrange(distrib_all + ggtitle("Overall distribution") + theme(legend.position="right") + xlab(""), 
             distrib_macroarea + ggtitle("By macroarea") + theme(legend.position="none") + xlab(""),
             nrow=1);
dev.off();

cairo_pdf("./figures/tone2_alleles.pdf", width=5*2.5, height=3*2.75);
grid.arrange(plot_tone2_alleles_p1, plot_tone2_alleles_p2, plot_tone2_alleles_p3, nrow=3);
dev.off();
```

### Regressions

#### All data

##### `glmer`

```{r include=FALSE}
# The null model:
m_t3_0 <- glmer(tone_complex ~ 1 + # intercept
                  (1 | family_name), # random effects structure
                family=binomial(), data=d_t3, control=glmer_ctrl);
summary(m_t3_0);

# Full model:
m_t3_full <- glmer(tone_complex ~ 1 + # intercept
                     ASPM_freq_wavg + MCPH1_freq_wavg + # the two alleles (and their interaction)
                     macroarea + # macroarea
                     ASPM_freq_wavg:macroarea + MCPH1_freq_wavg:macroarea + # interactions between alleles and macroareas
                     ASPM_freq_wavg:MCPH1_freq_wavg + # interaction between alleles
                     (1 | family_name), # random effects structure
                   family=binomial(), data=d_t3, control=glmer_ctrl);
summary(m_t3_full); # Model is nearly unidentifiable: large eigenvalue ratio -> try to remove interactions:
m_t3_1 <- update(m_t3_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg); # Model failed to converge: degenerate  Hessian with 1 negative eigenvalues
summary(m_t3_1); anova(m_t3_full, m_t3_1); # p=0.7415
m_t3_2 <- update(m_t3_1, . ~ . - ASPM_freq_wavg:macroarea - MCPH1_freq_wavg:macroarea);
summary(m_t3_2); anova(m_t3_full, m_t3_2); # p=0.6633
# -> ok, so this seems to be the base model... try again the gene-gene interaction:
m_t3_3 <- update(m_t3_2, . ~ . + ASPM_freq_wavg:MCPH1_freq_wavg);
summary(m_t3_3); anova(m_t3_2, m_t3_3); # p=0.8034 -> no interactions!
m_t3_full_old <- m_t3_full; m_t3_full <- m_t3_2;
lattice::dotplot(ranef(m_t3_full, which="family_name", condVar=TRUE));

# Does macroarea matter?
m_t3_nom <- update(m_t3_full, . ~ . - macroarea);
summary(m_t3_nom);
anova(m_t3_full, m_t3_nom); # p=0.9696 -> no
anova(m_t3_0, m_t3_nom); # p=0.2312 -> the alleles don't add anything

# Do the alleles matter?
m_t3_nog <- update(m_t3_full, . ~ . - ASPM_freq_wavg - MCPH1_freq_wavg);
summary(m_t3_nog); anova(m_t3_full, m_t3_nog); # p=0.6814 -> no
anova(m_t3_0, m_t3_nog); # p=0.4919 -> macroarea adds no info
# ASPM:
m_t3_aspm_m <- update(m_t3_nog, . ~ . + ASPM_freq_wavg);
summary(m_t3_aspm_m); anova(m_t3_nog, m_t3_aspm_m); # p=0.3964
m_t3_aspm <- update(m_t3_aspm_m, . ~ . - macroarea);
summary(m_t3_aspm); 
anova(m_t3_aspm_m, m_t3_aspm); # p=0.8213 -> macroarea does not add info
anova(m_t3_0, m_t3_aspm); # p=0.137 -> ASPM does not predicts tone by itself
# MCPH1:
m_t3_mcph1_m <- update(m_t3_nog, . ~ . + MCPH1_freq_wavg);
summary(m_t3_mcph1_m); anova(m_t3_nog, m_t3_mcph1_m); # p=0.5964
m_t3_mcph1 <- update(m_t3_mcph1_m, . ~ . - macroarea);
summary(m_t3_mcph1); 
anova(m_t3_mcph1_m, m_t3_mcph1); # p=0.9058 -> macroarea does not add info
anova(m_t3_0, m_t3_mcph1); # p=0.1443 -> MCPH1 does not predicts tone by itself

# -> ASPM and MCPH1 do not predict complex tone!
```

The "null model": `r sprintf("ICC = %.1f%%", 100*performance::icc(m_t3_0)$ICC_adjusted)`, which shows that *tone2* is very strongly clustered within families.

The "full model" of a mixed-effects logistic regression where *tone2* is predicted by *macroarea*, *ASPM*-D and *MCPH1*-D (with their *interactions*) as fixed effects, and language *family* as random effect:

- the *interactions* drop out: 
  + between the two alleles (`r sprintf("*p* = %.2g", anova(m_t3_full, m_t3_1)[2,"Pr(>Chisq)"])`)
  + between the alleles and *macroarea* (`r sprintf("*p* = %.2g", anova(m_t3_full_old, m_t3_2)[2,"Pr(>Chisq)"])`)
- the *macroarea* by itself does not predict *tone2*: `r sprintf("*p* = %.2g", anova(m_t3_0, m_t3_nog)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_nog)$R2_marginal)`
- the two alleles together do not predict *tone2* even in the absence of *macroarea*: `r sprintf("*p* = %.2g", anova(m_t3_0, m_t3_nom)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_nom)$R2_marginal)`
- the two alleles individually in the absence of *macroarea*: 
  + *ASPM*-D: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_t3_aspm)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_t3_aspm)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_t3_0, m_t3_aspm)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_aspm)$R2_marginal)`
  + *MCPH1*-D: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_t3_mcph1)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_t3_mcph1)$coefficients["MCPH1_freq_wavg", "Std. Error"], anova(m_t3_0, m_t3_mcph1)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_mcph1)$R2_marginal)`
- the two alleles individually in the presence of *macroarea*: 
  + *ASPM*-D: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_t3_aspm_m)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_t3_aspm_m)$coefficients["ASPM_freq_wavg", "Std. Error"], summary(m_t3_aspm_m)$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_aspm_m)$R2_marginal)`
  + *MCPH1*-D: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_t3_mcph1_m)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_t3_mcph1_m)$coefficients["MCPH1_freq_wavg", "Std. Error"], summary(m_t3_aspm_m)$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_t3_mcph1_m)$R2_marginal)`


##### `brms`

###### Macroarea as raneff

```{r include=FALSE}
if( file.exists("./cache-results/brms_t3.RData") )
{
  load("./cache-results/brms_t3.RData");
} else
{
  # The null model:
  b_t3_0 <- brm(tone_complex ~ 1 + # intercept
                  (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                family=bernoulli(link="logit"), data=d_t3, 
                prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
                save_pars=save_pars(all=TRUE), # needed for Bayes factors
                sample_prior=TRUE,  # needed for hypotheses tests
                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_t3_0); mcmc_plot(b_t3_0, type="trace"); mcmc_plot(b_t3_0, type="areas");
  
  # Full model:
  b_t3_full <- brm(tone_complex ~ 1 + # intercept
                     ASPM_freq_wavg + MCPH1_freq_wavg + # the two alleles (and their interaction)
                     ASPM_freq_wavg:MCPH1_freq_wavg + # interaction between alleles
                     (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                   family=bernoulli(link="logit"), data=d_t3, 
                   prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                           prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                   save_pars=save_pars(all=TRUE), # needed for Bayes factors
                   sample_prior=TRUE,  # needed for hypotheses tests
                   cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_t3_full); mcmc_plot(b_t3_full, type="trace"); mcmc_plot(b_t3_full, type="areas");
  # Check interaction:
  brms::hypothesis(b_t3_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.47 -> I can remove the interaction
  b_t3_full <- update(b_t3_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_t3_full); mcmc_plot(b_t3_full, type="trace"); mcmc_plot(b_t3_full, type="areas");
  (b_t3_full_hyps <- brms::hypothesis(b_t3_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.80 and 0.72 -> not bad!
  (b_t3_full_hdi <- bayestestR::hdi(b_t3_full, ci=0.95));
  
  #sjPlot::plot_model(b_t3_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(b_t3_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  b_t3_aspm_only <- update(b_t3_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_t3_aspm_only); mcmc_plot(b_t3_aspm_only, type="trace"); mcmc_plot(b_t3_aspm_only, type="areas");
  brms::hypothesis(b_t3_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.82 -> not bad!
  # MCPH1:
  b_t3_mcph1_only <- update(b_t3_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_t3_mcph1_only); mcmc_plot(b_t3_mcph1_only, type="trace"); mcmc_plot(b_t3_mcph1_only, type="areas");
  brms::hypothesis(b_t3_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.75 -> not bad!
  
  # Formal model comparisons:
  b_t3_0          <- brms_fit_indices(b_t3_0);
  b_t3_full       <- brms_fit_indices(b_t3_full);
  b_t3_aspm_only  <- brms_fit_indices(b_t3_aspm_only);
  b_t3_mcph1_only <- brms_fit_indices(b_t3_mcph1_only);
  (b_t3_cmp_null_full  <- brms_compare_models(b_t3_0, b_t3_full, "null", "full"));
  (b_t3_cmp_null_aspm  <- brms_compare_models(b_t3_0, b_t3_aspm_only, "null", "ASPM"));
  (b_t3_cmp_null_mcph1 <- brms_compare_models(b_t3_0, b_t3_mcph1_only, "null", "MCPH1")); 
  (b_t3_cmp_full_aspm  <- brms_compare_models(b_t3_full, b_t3_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (b_t3_cmp_full_mcph1 <- brms_compare_models(b_t3_full, b_t3_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  
  # Save these results to file:
  save(b_t3_full, b_t3_0, b_t3_aspm_only, b_t3_mcph1_only,
       b_t3_full_hyps, b_t3_full_hdi, b_t3_cmp_null_full, b_t3_cmp_null_aspm, b_t3_cmp_null_mcph1, b_t3_cmp_full_aspm, b_t3_cmp_full_mcph1, 
       file="./cache-results/brms_t3.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(b_t3_full, type="areas");
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(b_t3_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(b_t3_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_t3_full_hdi$CI_low[ b_t3_full_hdi$Parameter == "b_ASPM_freq_wavg" ], b_t3_full_hdi$CI_high[ b_t3_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_t3_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(b_t3_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_t3_full_hdi$CI_low[ b_t3_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], b_t3_full_hdi$CI_high[ b_t3_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_t3_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(b_t3_cmp_null_full)`.

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(b_t3_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(b_t3_cmp_full_aspm)`.

```{r fig.cap=capFig("Plot of the posterior distribution of the macroareas as random effect.")}
# macroarea:
b_t3_full %>%
  spread_draws(b_Intercept, r_macroarea[macroarea,]) %>%
  mutate(macroarea_mean = b_Intercept + r_macroarea) %>%
  ggplot(aes(y = macroarea, x = macroarea_mean)) +
  stat_halfeye(fill="skyblue") + 
  geom_vline(xintercept = 0, linetype = "dashed");
```

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks and confusion-matrix-based measures of the quality of predictions vs the observed data:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(b_t3_0) + ggtitle("null model"),
             pp_check(b_t3_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(b_t3_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(b_t3_full) + ggtitle("full model"), 
             ncol=2);
```

```{r fig.cap=capFig("Confusion matrix for the *null* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_t3_0, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_t3_0$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *ASPM*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_t3_aspm_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_t3_aspm_only$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *MCPH1*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_t3_mcph1_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_t3_mcph1_only$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *full* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(b_t3_full, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      b_t3_full$data$tone_complex, positive="Yes"));
```


###### Gaussian process

```{r include=FALSE}
if( file.exists("./cache-results/gp_t3.RData") )
{
  load("./cache-results/gp_t3.RData");
} else
{
  # Full model:
  gp_t3_full <- brm(bf(tone_complex ~ 1 +                                 # intercept
                         ASPM_freq_wavg + MCPH1_freq_wavg +               # the two alleles (and their interaction)
                         ASPM_freq_wavg:MCPH1_freq_wavg +                 # interaction between alleles
                         gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                         (1 | family_name / metapop)),                    # family and metapopulation
                    data=d_t3,
                    family=bernoulli(link="logit"),
                    prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), 
                            prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                            prior(normal(1, 0.2), class="sd"),      # try to reduce over-fitting
                            prior(normal(0, 3), class="sdgp")),     # pretty wide prior centered on 0
                    save_pars=save_pars(all=TRUE), # needed for Bayes factors
                    sample_prior=TRUE,  # needed for hypotheses tests
                    chains=4, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_t3_full); mcmc_plot(gp_t3_full, type="trace"); mcmc_plot(gp_t3_full, type="areas");
  # Check interaction:
  brms::hypothesis(gp_t3_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.47 -> I can remove the interaction
  gp_t3_full <- update(gp_t3_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_t3_full); mcmc_plot(gp_t3_full, type="trace"); mcmc_plot(gp_t3_full, type="areas");
  (gp_t3_full_hyps <- brms::hypothesis(gp_t3_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.71, 0.66
  (gp_t3_full_hdi <- bayestestR::hdi(gp_t3_full, ci=0.95));
  
  #sjPlot::plot_model(gp_t3_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(gp_t3_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  gp_t3_aspm_only <- update(gp_t3_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_t3_aspm_only); mcmc_plot(gp_t3_aspm_only, type="trace"); mcmc_plot(gp_t3_aspm_only, type="areas");
  brms::hypothesis(gp_t3_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.72 -> not bad!
  # MCPH1:
  gp_t3_mcph1_only <- update(gp_t3_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  summary(gp_t3_mcph1_only); mcmc_plot(gp_t3_mcph1_only, type="trace"); mcmc_plot(gp_t3_mcph1_only, type="areas");
  brms::hypothesis(gp_t3_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.67 -> not bad!
  
  # Null model:
  gp_t3_0 <- brm(bf(tone_complex ~ 1 +                                 # intercept
                      gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                      (1 | family_name / metapop)),                    # family and metapopulation
                 data=d_t3,
                 family=bernoulli(link="logit"),
                    prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), # pretty wide priors centered on 0
                            prior(normal(1, 0.2), class="sd"),              # try to reduce over-fitting
                            prior(normal(0, 3), class="sdgp")),             # pretty wide prior centered on 0
                 save_pars=save_pars(all=TRUE), # needed for Bayes factors
                 sample_prior=TRUE,  # needed for hypotheses tests
                 chains=4, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.9, max_treedepth=10));
  # Formal model comparisons:
  gp_t3_0          <- brms_fit_indices(gp_t3_0);
  gp_t3_full       <- brms_fit_indices(gp_t3_full);
  gp_t3_aspm_only  <- brms_fit_indices(gp_t3_aspm_only);
  gp_t3_mcph1_only <- brms_fit_indices(gp_t3_mcph1_only);
  (gp_t3_cmp_null_full  <- brms_compare_models(gp_t3_0, gp_t3_full, "null", "full"));
  (gp_t3_cmp_null_aspm  <- brms_compare_models(gp_t3_0, gp_t3_aspm_only, "null", "ASPM"));
  (gp_t3_cmp_null_mcph1 <- brms_compare_models(gp_t3_0, gp_t3_mcph1_only, "null", "MCPH1"));  
  (gp_t3_cmp_full_aspm  <- brms_compare_models(gp_t3_full, gp_t3_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (gp_t3_cmp_full_mcph1 <- brms_compare_models(gp_t3_full, gp_t3_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  

  # Save these results to file:
  save(gp_t3_full, gp_t3_0, gp_t3_aspm_only, gp_t3_mcph1_only,
       gp_t3_full_hyps, gp_t3_full_hdi, gp_t3_cmp_null_full, gp_t3_cmp_null_aspm, gp_t3_cmp_null_mcph1, gp_t3_cmp_full_aspm, gp_t3_cmp_full_mcph1, 
       file="./cache-results/gp_t3.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression with a 2D Gaussian process results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(gp_t3_full, type="areas", pars=c("b_Intercept", "b_ASPM", "b_MCPH1"));
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(gp_t3_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(gp_t3_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_t3_full_hdi$CI_low[ gp_t3_full_hdi$Parameter == "b_ASPM_freq_wavg" ], gp_t3_full_hdi$CI_high[ gp_t3_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_t3_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(gp_t3_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_t3_full_hdi$CI_low[ gp_t3_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], gp_t3_full_hdi$CI_high[ gp_t3_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_t3_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(gp_t3_cmp_null_full)`.

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(gp_t3_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(gp_t3_cmp_full_aspm)`.

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks and confusion-matrix-based measures of the quality of predictions vs the observed data:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(gp_t3_0) + ggtitle("null model"),
             pp_check(gp_t3_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(gp_t3_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(gp_t3_full) + ggtitle("full model"), 
             ncol=2);
```

```{r fig.cap=capFig("Confusion matrix for the *null* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_t3_0, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_t3_0$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *ASPM*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_t3_aspm_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_t3_aspm_only$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *MCPH1*-D-only model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_t3_mcph1_only, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_t3_mcph1_only$data$tone_complex, positive="Yes"));
```

```{r fig.cap=capFig("Confusion matrix for the *full* model.")}
draw_confusion_matrix(confusionMatrix(factor(if_else(predict(gp_t3_full, type = "response")[,"Estimate"] > 0.5, "Yes", "No")), 
                                      gp_t3_full$data$tone_complex, positive="Yes"));
```


#### Randomization

```{r include=FALSE}
# Permutations:
if( file.exists("./cache-results/perm_res_t3_glmer.RData") )
{
  load("./cache-results/perm_res_t3_glmer.RData");
} else
{
  perm_res_t3_glmer <- rbind(
    # Original values:
    do.call(rbind, pblapply(unique(all_conditions$macroarea), function(macroarea)
    {
      r <- NULL;
      capture.output(try(r <- .fit_permuted(d_t3, tone_dv="tone_complex", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                            macroarea=macroarea, permute="nothing", within="unrestricted", regression_type="logistic"),
                         silent=TRUE), type="message");
      if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=0), r)) }
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character),
    # Permute values:
    do.call(rbind, pblapply(1:n_permutations, function(i)
    {
      do.call(rbind, lapply(1:nrow(all_conditions), function(j)
      {
        r <- NULL;
        capture.output(try(r <- .fit_permuted(d_t3, tone_dv="tone_complex", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                              macroarea=all_conditions$macroarea[j], permute=all_conditions$permute[j], within=all_conditions$within[j], regression_type="logistic"),
                           silent=TRUE), type="message");
        if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=i), r)) }
      }));
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character));
  # Save these results to file:
  save(perm_res_t3_glmer, file="./cache-results/perm_res_t3_glmer.RData", compress="xz", compression_level=9);
}
```

```{r}
# Summarize and plot these randomization results:
perm_res_t3_glmer_summary <- do.call(rbind, lapply(1:nrow(all_conditions), function(i) 
  {
    original_results <- perm_res_t3_glmer[ perm_res_t3_glmer$macroarea == all_conditions$macroarea[i] & perm_res_t3_glmer$permute == "nothing", ];
    .summarize_permuted(perm_res_t3_glmer, 
                        original=original_results, macroarea=all_conditions$macroarea[i], permute=all_conditions$permute[i], permute_within=all_conditions$within[i]);
}));
# Column order:
perm_res_t3_glmer_summary <- perm_res_t3_glmer_summary[, c("permute_within", "macroarea", "permute", 
                                                           "better_AIC", "signif_vs_null", "signif_ASPM", "smaller_beta_ASPM", "signif_MCPH1", "smaller_beta_MCPH1")];
# To percent:
perm_res_t3_glmer_summary$better_AIC         <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$better_AIC);
perm_res_t3_glmer_summary$signif_vs_null     <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$signif_vs_null);
perm_res_t3_glmer_summary$signif_ASPM        <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$signif_ASPM);
perm_res_t3_glmer_summary$smaller_beta_ASPM  <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$smaller_beta_ASPM);
perm_res_t3_glmer_summary$signif_MCPH1       <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$signif_MCPH1);
perm_res_t3_glmer_summary$smaller_beta_MCPH1 <- sprintf("%.0f%%",100*perm_res_t3_glmer_summary$smaller_beta_MCPH1);
# SHow it:
knitr::kable(perm_res_t3_glmer_summary,
             col.names=c("Permute within", "Macroarea", "Permute", "AIC", "Signif.", "*p*~*ASPM*-D~", "*&beta;*~*ASPM*-D~", "*p*~*MCPH1*-D~", "*&beta;*~*MCPH1*-D~"), 
             align="r",
             caption="Regressions with randomizations for *tone2*.");
```

```{r fig.cap=paste0("Regressions on ",n_permutations," permuted data. Each plot shows the original result (vertical dashed black line) and the distribution of the permutations for the three possible things to be permuted (colored curves) for each combination of permutation constraints (horizontal panels) and control for *macroarea* (vertical panels) in terms of the effect size *&beta;*; *ASPM*-D is on the left and *MCPH1*-D on the right. The vertical dotted black thin line is at 0.0."), fig.height=2*2+0.5, fig.width=6*2.5}
perm_res_t3_glmer$macroarea      <- factor(as.character(perm_res_t3_glmer$macroarea), levels=c("none", "fixef"));
perm_res_t3_glmer$permute        <- factor(as.character(perm_res_t3_glmer$permute), levels=c("nothing", "tone", "alleles-together", "alleles-independent"));
perm_res_t3_glmer$permute_within <- factor(as.character(perm_res_t3_glmer$permute_within), levels=c("unrestricted", "macroareas", "families"));

# ASPM:
p1 <-ggplot(perm_res_t3_glmer[ perm_res_t3_glmer$permute != "nothing", ], aes(x=ASPM_b)) + xlab("β") + xlim(-10,10) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_t3_glmer[ perm_res_t3_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=ASPM_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "top") + 
  scale_fill_discrete("What is permuted:") + scale_color_discrete("What is permuted:");
# MCPH1:
p2 <- ggplot(perm_res_t3_glmer[ perm_res_t3_glmer$permute != "nothing", ], aes(x=MCPH1_b)) + xlab("β") + xlim(-10,10) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_t3_glmer[ perm_res_t3_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=MCPH1_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "none");
l <- get_legend(p1);
grid.arrange(p1 + theme(legend.position = "none") + ggtitle(expression(italic("ASPM")-"D")), p2 + ggtitle(expression(italic("MCPH1")-"D")), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone2_regressions_permuted.pdf", width=6*1.25, height=2*1.50+0.15);
grid.arrange(p1 + theme(legend.position = "none") + ggtitle(expression(italic("ASPM")-"D")), p2 + ggtitle(expression(italic("MCPH1")-"D")), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
dev.off();
```


#### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( file.exists("./cache-results/reg_samples_per_fam_t3.RData") )
{
  load("./cache-results/reg_samples_per_fam_t3.RData");
} else
{
  reg_samples_per_fam_complex <- do.call(rbind, lapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_t3);
    
    # Null:
    m_0 <- glm(tone_complex ~ 1, family=binomial(), data=d);
    # ASPM:
    m_aspm <- glm(tone_complex ~ 1 + ASPM_freq_wavg, family=binomial(), data=d); a_aspm <- anova(m_0, m_aspm, test="Chisq");
    # MCPH1:
    m_mcph1 <- glm(tone_complex ~ 1 + MCPH1_freq_wavg, family=binomial(), data=d); a_mcph1 <- anova(m_0, m_mcph1, test="Chisq");
    # Both alleles:
    m_alleles <- glm(tone_complex ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg, family=binomial(), data=d); a_alleles <- anova(m_0, m_alleles, test="Chisq");
    # macroarea:
    m_macroarea <- glm(tone_complex ~ 1 + macroarea, family=binomial(), data=d); a_macroarea <- anova(m_0, m_macroarea, test="Chisq");
    # ASPM + m_macroarea:
    m_aspm_macroarea <- glm(tone_complex ~ 1 + ASPM_freq_wavg + macroarea, family=binomial(), data=d);
    # MCPH1 + m_macroarea:
    m_mcph1_macroarea <- glm(tone_complex ~ 1 + MCPH1_freq_wavg + macroarea, family=binomial(), data=d);
    # all:
    m_full <- glm(tone_complex ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg + macroarea, family=binomial(), data=d); a_full <- anova(m_0, m_full, test="Chisq");
    
    # Return value:
    data.frame("b_aspm"=m_aspm$coefficients[2],   "p_aspm"=summary(m_aspm)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_aspm_macroarea"=m_aspm_macroarea$coefficients["ASPM_freq_wavg"], "p_aspm_macroarea"=summary(m_aspm_macroarea)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_mcph1"=m_mcph1$coefficients[2], "p_mcph1"=summary(m_mcph1)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"], 
               "b_mcph1_macroarea"=m_mcph1_macroarea$coefficients["MCPH1_freq_wavg"], "p_mcph1_macroarea"=summary(m_mcph1_macroarea)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"],
               "p_alleles"=a_alleles[2,"Pr(>Chi)"], 
               "p_macroarea"=a_macroarea[2,"Pr(>Chi)"], 
               "b_aspm_all"=m_full$coefficients["ASPM_freq_wavg"], "b_mcph1_all"=m_full$coefficients["MCPH1_freq_wavg"], "p_all"=a_full[2,"Pr(>Chi)"]);
  }));
  # Save these results to file:
  save(reg_samples_per_fam_complex, file="./cache-results/reg_samples_per_fam_t3.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig(paste0("Results for ",n_samples," restricted samplings. For *ASPM*-D (left): ", round(100*sum(reg_samples_per_fam_complex$b_aspm<0)/nrow(reg_samples_per_fam_complex),1), "% of &beta;s are negative when regressing tone on *ASPM* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_aspm, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam_complex$b_aspm_macroarea<0)/nrow(reg_samples_per_fam_complex),1), "%, when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_aspm_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam_complex$b_aspm_all<0)/nrow(reg_samples_per_fam_complex),1), "% when controlling for both macroarea and *MCPH1* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_aspm_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "). For *MCPH1*-D (right): ", round(100*sum(reg_samples_per_fam_complex$b_mcph1<0)/nrow(reg_samples_per_fam_complex),1), "% of &beta;s are negative when regressing tone on *MCPH1* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_mcph1, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam_complex$b_mcph1_macroarea<0)/nrow(reg_samples_per_fam_complex),1), "% when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_mcph1_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam_complex$b_mcph1_all<0)/nrow(reg_samples_per_fam_complex),1), "% when controlling for both macroarea and *ASPM* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_complex$b_mcph1_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), ").")), fig.width=2*4, fig.height=1*4+0.25}
tmp <- rbind(cbind("gene"="ASPM",
                   reshape2::melt(reg_samples_per_fam_complex[,c("b_aspm", "b_aspm_macroarea", "b_aspm_all")], 
                                  measure.vars=c("b_aspm", "b_aspm_macroarea", "b_aspm_all"), variable.name="model", value.name="beta")),
             cbind("gene"="MCPH1",
                   reshape2::melt(reg_samples_per_fam_complex[,c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all")], 
                                  measure.vars=c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), variable.name="model", value.name="beta")));
tmp$model <- factor(as.character(tmp$model), 
                    levels=c("b_aspm", "b_aspm_macroarea", "b_aspm_all", "b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), 
                    labels=c("by itself", "ctrl macroarea", "ctrl macroarea & the other allele", "by itself", "ctrl macroarea", "ctrl macroarea & the other allele"));

ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone2_regressions_restricted.pdf", width=2*2.5, height=1*2.5+0.25);
ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
dev.off();
```


### Mediation and path analysis

#### Mediation analysis

##### All data

###### `(g)lm`

```{r include=FALSE}
# ASPM:
med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d_t3); (med_aspm_f1_summary <- summary(med_aspm_f1));
med_aspm_f2 <- glm(tone_complex ~ ASPM_freq_wavg + Africa, family=binomial(), data=d_t3); (med_aspm_f2_summary <- summary(med_aspm_f2));
med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE); (med_aspm_summary <- summary(med_aspm));

# MCPH1:
med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d_t3); (med_mcph1_f1_summary <- summary(med_mcph1_f1));
med_mcph1_f2 <- glm(tone_complex ~ MCPH1_freq_wavg + Africa, family=binomial(), data=d_t3); (med_mcph1_f2_summary <- summary(med_mcph1_f2));
med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE); (med_mcph1_summary <- summary(med_mcph1));
```

For either allele, there is no significant total effect:

- *ASPM*-D: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$tau.coef, med_aspm_summary$tau.ci[1], med_aspm_summary$tau.ci[2], med_aspm_summary$tau.p)`
- *MCPH1*-D: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$tau.coef, med_mcph1_summary$tau.ci[1], med_mcph1_summary$tau.ci[2], med_mcph1_summary$tau.p)`


###### `brms`

```{r include=FALSE}
if( file.exists("./cache-results/brms_t3_med.RData") )
{
  load("./cache-results/brms_t3_med.RData");
} else
{
  # Mediation with brms:
  # ASPM:
  bmed_africa_aspm__t3 <- .fit_mediation_model(d=d_t3, 
                                               outcome="tone_complex", outcome_name="tone", 
                                               treatment="Africa", treatment_name="Africa", 
                                               mediator="ASPM_freq_wavg_4beta", mediator_name="ASPM", 
                                               family_mediator=Beta(), family_outcome=bernoulli("logit"), ranefs="(1 | family_name / metapop)",
                                               cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                               save_model=FALSE, show_results=TRUE);
  
  # MCPH1:
  bmed_africa_mcph1__t3 <- .fit_mediation_model(d=d_t3, 
                                                outcome="tone_complex", outcome_name="tone", 
                                                treatment="Africa", treatment_name="Africa", 
                                                mediator="MCPH1_freq_wavg_4beta", mediator_name="MCPH1", 
                                                family_mediator=Beta(), family_outcome=bernoulli("logit"), ranefs="(1 | family_name / metapop)",
                                                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                                save_model=FALSE, show_results=TRUE);
  
  # Save these results to file:
  save(bmed_africa_aspm__t3, bmed_africa_mcph1__t3, 
       file="./cache-results/brms_t3_med.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *ASPM*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_aspm__t3; .plot_mediation_model(m$summary, m$mediation, 
                                                 outcome=m$outcome, outcome_name=m$outcome_name, 
                                                 treatment=m$treatment, treatment_name=m$treatment_name, 
                                                 mediator=m$mediator, mediator_name=m$mediator_name);
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *MCPH1*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_mcph1__t3; .plot_mediation_model(m$summary, m$mediation, 
                                                  outcome=m$outcome, outcome_name=m$outcome_name, 
                                                  treatment=m$treatment, treatment_name=m$treatment_name, 
                                                  mediator=m$mediator, mediator_name=m$mediator_name);
```


##### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/med_t3_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  med_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_t3);
    
    # ASPM:
    med_aspm_f1 <- med_aspm_f2 <- med_aspm <- NULL;
    try(med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_aspm_f1) ){ return (NULL); }; (med_aspm_f1_summary <- summary(med_aspm_f1));
    try(med_aspm_f2 <- glm(tone_complex ~ ASPM_freq_wavg + Africa, family=binomial(), data=d), silent=TRUE); if( is.null(med_aspm_f2) ){ return (NULL); }; (med_aspm_f2_summary <- summary(med_aspm_f2));
    try(med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_aspm) ){ return (NULL); }; (med_aspm_summary <- summary(med_aspm));
    
    # MCPH1:
    med_mcph1_f1 <- med_mcph1_f2 <- med_mcph1 <- NULL;
    try(med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_mcph1_f1) ){ return (NULL); }; (med_mcph1_f1_summary <- summary(med_mcph1_f1));
    try(med_mcph1_f2 <- glm(tone_complex ~ MCPH1_freq_wavg + Africa, family=binomial(), data=d), silent=TRUE); if( is.null(med_mcph1_f2) ){ return (NULL); }; (med_mcph1_f2_summary <- summary(med_mcph1_f2));
    try(med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_mcph1) ){ return (NULL); }; (med_mcph1_summary <- summary(med_mcph1));
    
    # Return value:
    data.frame(
      # ASPM:
      "aspm_TE"=med_aspm_summary$tau.coef, "aspm_TE_95low"=med_aspm_summary$tau.ci[1],     "aspm_TE_95high"=med_aspm_summary$tau.ci[2],     "aspm_TE_p"=med_aspm_summary$tau.p,
      "aspm_ADE"=med_aspm_summary$z.avg,   "aspm_ADE_95low"=med_aspm_summary$z.avg.ci[1],  "aspm_ADE_95high"=med_aspm_summary$z.avg.ci[2],  "aspm_ADE_p"=med_aspm_summary$z.avg.p,
      "aspm_ACME"=med_aspm_summary$d.avg,  "aspm_ACME_95low"=med_aspm_summary$d.avg.ci[1], "aspm_ACME_95high"=med_aspm_summary$d.avg.ci[2], "aspm_ACME_p"=med_aspm_summary$d.avg.p,
      "aspm_prop"=med_aspm_summary$n.avg,  "aspm_prop_95low"=med_aspm_summary$n.avg.ci[1], "aspm_prop_95high"=med_aspm_summary$n.avg.ci[2], "aspm_prop_p"=med_aspm_summary$n.avg.p,
      "aspm_Afr_gene_b"=med_aspm_f1_summary$coefficients["AfricaYes", "Estimate"], "aspm_Afr_gene_b_stderr"=med_aspm_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "aspm_Afr_gene_p"=med_aspm_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "aspm_gene_tone_b"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Estimate"], "aspm_gene_tone_b_stderr"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Std. Error"],
      "aspm_gene_tone_p"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Pr(>|z|)"],
      # MCPH1:
      "mcph1_TE"=med_mcph1_summary$tau.coef, "mcph1_TE_95low"=med_mcph1_summary$tau.ci[1],     "mcph1_TE_95high"=med_mcph1_summary$tau.ci[2],     "mcph1_TE_p"=med_mcph1_summary$tau.p,
      "mcph1_ADE"=med_mcph1_summary$z.avg,   "mcph1_ADE_95low"=med_mcph1_summary$z.avg.ci[1],  "mcph1_ADE_95high"=med_mcph1_summary$z.avg.ci[2],  "mcph1_ADE_p"=med_mcph1_summary$z.avg.p,
      "mcph1_ACME"=med_mcph1_summary$d.avg,  "mcph1_ACME_95low"=med_mcph1_summary$d.avg.ci[1], "mcph1_ACME_95high"=med_mcph1_summary$d.avg.ci[2], "mcph1_ACME_p"=med_mcph1_summary$d.avg.p,
      "mcph1_prop"=med_mcph1_summary$n.avg,  "mcph1_prop_95low"=med_mcph1_summary$n.avg.ci[1], "mcph1_prop_95high"=med_mcph1_summary$n.avg.ci[2], "mcph1_prop_p"=med_mcph1_summary$n.avg.p,
      "mcph1_Afr_gene_b"=med_mcph1_f1_summary$coefficients["AfricaYes", "Estimate"], "mcph1_Afr_gene_b_stderr"=med_mcph1_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "mcph1_Afr_gene_p"=med_mcph1_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "mcph1_gene_tone_b"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Estimate"], "MCPH1_gene_tone_b_stderr"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Std. Error"],
      "mcph1_gene_tone_p"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"], 
      row.names=NULL);
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, med_samples_per_fam, file="./cache-results/med_t3_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/med_t3_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=3*4, fig.cap=capFig(paste0("Mediation analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost panels show the distribution of point estimates of the Total Effect (TE), the Direct Effect (ADE) and the Indirect Effect (ACME) for *ASPM* and *MCPH1*; the middle panels show the distribution of the *p*-values for the same effects, while the rightmost panels show the distribution of the regression slopes (*β*) for the two alleles, top: for the regression of the allele frequency on within vs outside Africa, and bottom: for the regression of tone on the allele while controlling for within vs outside Africa. The black vertical lines show: 0.0 (solid), 0.05 (dashed) and 0.10 (dotted)."))}
p1 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE", "aspm_ADE", "aspm_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.30, 0.75) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               #scale_color_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation estimates")) + theme(legend.position="bottom");
             
p2 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE_p", "aspm_ADE_p", "aspm_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p3 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_Afr_gene_b", "mcph1_Afr_gene_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.8,0.1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Allele", labels=c("aspm_Afr_gene_b"=expression(" "~italic("ASPM")-D), "mcph1_Afr_gene_b"=expression(" "~italic("MCPH1")-D)), values=c("aspm_Afr_gene_b"="yellow", "mcph1_Afr_gene_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("Africa " %->% " allele"))) + theme_bw() + theme(legend.position="bottom");
             
p4 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE", "mcph1_ADE", "mcph1_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.30, 0.75) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation estimates")) + theme(legend.position="none");
             
p5 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE_p", "mcph1_ADE_p", "mcph1_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p6 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_gene_tone_b", "mcph1_gene_tone_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-10,10) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Gene", values=c("aspm_gene_tone_b"="yellow", "mcph1_gene_tone_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("allele " %->% " tone | Africa"))) + theme_bw() + theme(legend.position="none");
             
l1 <- get_legend(p1);
l3 <- get_legend(p3);

grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone2_mediation_restricted.pdf", width=3*3.3, height=2*2.5+0.15); 
grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
dev.off();
```

For *ASPM*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_TE,na.rm=TRUE), median(med_samples_per_fam$aspm_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ADE,na.rm=TRUE), median(med_samples_per_fam$aspm_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ACME,na.rm=TRUE), median(med_samples_per_fam$aspm_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

For *MCPH1*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_TE,na.rm=TRUE), median(med_samples_per_fam$mcph1_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), median(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), median(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

Pretty much none of these effects are individually significant.


#### Path analysis

##### All data

```{r include=FALSE}
## Path analysis:
# The model (numeric):
sem_tone_num <- '
    # tone:
    tone_complex_num ~ Africa_num + ASPM_freq_wavg + MCPH1_freq_wavg

    # the alleles:
    ASPM_freq_wavg  ~ Africa_num
    MCPH1_freq_wavg ~ Africa_num
  ';
semfit_tone_num <- sem(sem_tone_num, data=d_t3, se="robust.sem");
summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
(semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));
mi_tone_num <- modindices(semfit_tone_num);

# The model (ordered):
sem_tone_ord <- '
    # tone:
    tone_complex_ord ~ Africa_ord + ASPM_freq_wavg + MCPH1_freq_wavg

    # the alleles:
    ASPM_freq_wavg  ~ Africa_ord
    MCPH1_freq_wavg ~ Africa_ord
  ';
semfit_tone_ord <- sem(sem_tone_ord, data=d_t3, se="robust.sem");
summary(semfit_tone_ord, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
lavaanPlot(model=semfit_tone_ord, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
(semfit_tone_ord_measures <- fitMeasures(semfit_tone_ord, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));
mi_tone_ord <- modindices(semfit_tone_ord);
```

Coding Africa and *tone2* numerically, the model fit is: `r sprintf("*&chi;*^2^(%d)=%.2f, *p*=%.2g; CFI=%.2f, TLI=%.2f, NNFI=%.2f and RFI=%.2f", semfit_tone_num_measures["df"], semfit_tone_num_measures["chisq"], semfit_tone_num_measures["pvalue"], semfit_tone_num_measures["cfi"], semfit_tone_num_measures["tli"], semfit_tone_num_measures["nnfi"], semfit_tone_num_measures["rfi"])`.

```{r fig.cap=capFig("Path analysis model with standardised coefficients and significance stars. Here, we coded tone and macroarea (Africa vs non-Africa) as numeric binary (`tone_complex_num` with Yes=1 and `Africa_num` with in Africa=1); `ASPM_freq_wavg` is *ASPM*-D and `MCPH1_freq_wavg` is *MCPH1*-D.")}
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=TRUE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```

Coding Africa and *tone2* as ordered binary factors, the model fit is: `r sprintf("*&chi;*^2^(%d)=%.2f, *p*=%.2g; CFI=%.2f, TLI=%.2f, NNFI=%.2f and RFI=%.2f", semfit_tone_ord_measures["df"], semfit_tone_ord_measures["chisq"], semfit_tone_ord_measures["pvalue"], semfit_tone_ord_measures["cfi"], semfit_tone_ord_measures["tli"], semfit_tone_ord_measures["nnfi"], semfit_tone_ord_measures["rfi"])`.

```{r fig.cap=capFig("Path analysis model with standardised coefficients and significance stars. Here, we coded tone and macroarea (Africa vs non-Africa) as ordered binary factors (`tone_complex_ord` with No < Yes, and `Africa_ord` with outside Africa < in Africa); `ASPM_freq_wavg` is *ASPM*-D and `MCPH1_freq_wavg` is *MCPH1*-D.")}
lavaanPlot(model=semfit_tone_ord, coefs=TRUE, sig=1.00, stand=TRUE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```


##### Restricted sampling

Here I use here only the numerically-coded model.

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/sem_t3_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  sem_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_t3);
    
    # Fit the model:
    semfit_tone_num <- NULL;
    try(semfit_tone_num <- sem(sem_tone_num, data=d, se="robust.sem"), silent=TRUE);
    if( is.null(semfit_tone_num) ){ return(NULL); }
    semfit_tone_num_summary <- NULL;
    try(semfit_tone_num_summary <- summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE), silent=TRUE);
    if( is.null(semfit_tone_num_summary) ){ return (NULL); }
    #lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
    semfit_tone_num_measures <- NULL;
    try(semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")), silent=TRUE);
    if( is.null(semfit_tone_num_measures) ){ return (NULL); }

    # Return value:
    tmp <- semfit_tone_num_summary$PE;
    cbind(
      as.data.frame(matrix(semfit_tone_num_measures, nrow=1, dimnames=list("", names(semfit_tone_num_measures)))),
      data.frame(
        "Afr_aspm_b"  =tmp$est[tmp$lhs=="ASPM_freq_wavg"      & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_aspm_p"  =tmp$pvalue[tmp$lhs=="ASPM_freq_wavg"   & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_mcph1_b" =tmp$est[tmp$lhs=="MCPH1_freq_wavg"     & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_mcph1_p" =tmp$pvalue[tmp$lhs=="MCPH1_freq_wavg"  & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_tone_b"  =tmp$est[tmp$lhs=="tone_complex_num"    & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_tone_p"  =tmp$pvalue[tmp$lhs=="tone_complex_num" & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "aspm_tone_b" =tmp$est[tmp$lhs=="tone_complex_num"    & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],  
        "aspm_tone_p" =tmp$pvalue[tmp$lhs=="tone_complex_num" & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],
        "mcph1_tone_b"=tmp$est[tmp$lhs=="tone_complex_num"    & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"], 
        "mcph1_tone_p"=tmp$pvalue[tmp$lhs=="tone_complex_num" & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"],
        row.names=NULL));
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, sem_samples_per_fam, file="./cache-results/sem_t3_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/sem_t3_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=2*4, fig.cap=capFig(paste0("Path analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost row of two plots shows the coefficient estimates and the *p*-values, respectively, for the five paths in the model (see the path plots above). The rightmost plot shows the various fit indices. The black horiontal lines show: 0.0 (solid), 0.05 (dashed) and 1.0 (dotted)."))}
grid.arrange(ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_b", "Afr_mcph1_b", "Afr_tone_b", "aspm_tone_b", "mcph1_tone_b")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_b"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_b"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_b"=expression("Africa " %->% " tone2"), "aspm_tone_b"=expression("ASPM-D " %->% " tone2"), "mcph1_tone_b"=expression("MCPH1-D " %->% " tone2"))) + 
               xlab("Path") + ylab("Coefficient") + ggtitle("Path coeffcients") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("pvalue", "cfi", "tli", "nnfi", "rfi")]),
                    aes(x=variable, y=value, fill=variable)) + ylim(0,NA) + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=c(0.05, 1.0), color="black", linetype=c("dashed", "dotted")) +
               scale_fill_discrete(name="Fit indices", labels=c("pvalue"=expression(chi^2~italic(p)~"-value"), "cfi"="CFI", "tli"="TLI", "nnfi"="NNFI", "rfi"="RFI")) + 
               ylab("Estimate") + xlab("Fit indices") + ggtitle("Fit indices") + theme(legend.position="right"),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_p", "Afr_mcph1_p", "Afr_tone_p", "aspm_tone_p", "mcph1_tone_p")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.05, color="black", linetype="dashed") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_p"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_p"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_p"=expression("Africa " %->% " tone2"), "aspm_tone_p"=expression("ASPM-D " %->% " tone2"), "mcph1_tone_p"=expression("MCPH1-D " %->% " tone2"))) + 
               xlab("Path") + ylab("p-value") + ggtitle("Path p-values") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             nrow=2);
```

It can be seen that:

- the models fit are: 
  + `r round(100*sum(sem_samples_per_fam$pvalue >= 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam),1)`% of the *p*-values are not significant
  + mean(CFI) = `r round(mean(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, median(CFI) = `r round(median(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, sd(CFI) = `r round(sd(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, IQR(CFI) = `r round(IQR(sem_samples_per_fam$cfi, na.rm=TRUE),2)`
  + mean(TLI) = `r round(mean(sem_samples_per_fam$tli, na.rm=TRUE),2)`, median(TLI) = `r round(median(sem_samples_per_fam$tli, na.rm=TRUE),2)`, sd(TLI) = `r round(sd(sem_samples_per_fam$tli, na.rm=TRUE),2)`, IQR(TLI) = `r round(IQR(sem_samples_per_fam$tli, na.rm=TRUE),2)`
  + mean(NNFI) = `r round(mean(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, median(NNFI) = `r round(median(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, sd(NNFI) = `r round(sd(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, IQR(NNFI) = `r round(IQR(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`
  + mean(RFI) = `r round(mean(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, median(RFI) = `r round(median(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, sd(RFI) = `r round(sd(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, IQR(RFI) = `r round(IQR(sem_samples_per_fam$rfi, na.rm=TRUE),2)`

- Africa → *ASPM*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_aspm_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_aspm_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_aspm_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- Africa → *MCPH1*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_mcph1_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_mcph1_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_mcph1_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- Africa → *tone2*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% > 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_tone_b > 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_tone_b, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- *ASPM*-D → *tone2*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), median(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$aspm_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$aspm_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$aspm_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- *MCPH1*-D → *tone2*: `r sprintf("mean = %.2g, median = %.2g, as = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), median(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$mcph1_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$mcph1_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$mcph1_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.


### Machine Learning techniques

```{r include=FALSE}
# The predictors:
list_predictors <- c("ASPM_freq_wavg", "MCPH1_freq_wavg", "macroarea");
f_tone          <- formula(paste0("tone_complex ~ ", paste0(list_predictors,collapse=" + ")));
list_predictors_nomacroarea <- list_predictors[ list_predictors != "macroarea" ];
f_tone_nomacroarea          <- formula(paste0("tone_complex ~ ", paste0(list_predictors_nomacroarea,collapse=" + ")));

# Generate the training/testing splits into a training (80%) and a testing (20%) set stratified by macroarea:
# Make sure all macroareas in the test data are also in the training data:
if( file.exists("./cache-results/train_test_splits_t3.RData") )
{
  load("./cache-results/train_test_splits_t3.RData");
} else
{
  k <- 0; success_splitting <- FALSE;
  while(k < 100)
  {
    success_splitting <- TRUE;
    train_test_splits <- lapply(1:n_train, function(i) rsample::initial_split(d_t3, prop=0.80, strata="macroarea"));
    for( i in 1:n_train )
    {
      data_train <- training(train_test_splits[[i]]);
      data_test  <- testing(train_test_splits[[i]]);
      if( !all(unique(data_test$macroarea) %in% unique(data_train$macroarea)) )
      {
        # Try again: 
        success_splitting <- FALSE; break;
      }
    }
    if( success_splitting ) break; 
    
    # Try again:
    k <- k + 1;
  }
  if( !success_splitting && k == 100 ) stop("Error: cannot split the data into traning and testing sets by macroareas!\n");
  # Save these results to file:
  save(train_test_splits, file="./cache-results/train_test_splits_t3.RData", compress="xz", compression_level=9);
}
```


#### Decision trees

```{r include=FALSE}
### With macroareas:
if( file.exists("./cache-results/ctree_t3_m.RData") )
{
  load("./cache-results/ctree_t3_m.RData");
} else
{
  ## On the full dataset:
  ctree_tb_m_all <- ctree(f_tone, data=d_t3, control=ctree_control(testtype=c("MonteCarlo")));
  (cm_ctree_tb_m_all <- confusionMatrix(d_t3$tone_complex, predict(ctree_tb_m_all), positive="Yes"));
  success_ctree_tb_m_all <- data.frame("accuracy"     =cm_ctree_tb_m_all$overall["Accuracy"],
                                       "sensitivity"  =cm_ctree_tb_m_all$byClass["Sensitivity"], 
                                       "specificity"  =cm_ctree_tb_m_all$byClass["Specificity"],
                                       "precision"    =cm_ctree_tb_m_all$byClass["Precision"],
                                       "recall"       =cm_ctree_tb_m_all$byClass["Recall"],
                                       row.names=NULL);
  
  ## On the training/testing sets:
  ctree_tb_m_traintest <- pblapply(1:n_train, function(i) # very computationally expensive
  {
    # split the data:
    data_train <- training(train_test_splits[[i]]);
    data_test  <- testing(train_test_splits[[i]]);
    
    # fit the models:
    ctree_model <- ctree(f_tone, data=data_train, control=ctree_control(testtype=c("MonteCarlo")));
    
    # confusion matrices:
    cm_ctree <- confusionMatrix(data_test$tone_complex, predict(ctree_model,  newdata=data_test, allow_new_levels=TRUE), positive="Yes");
    
    # return the results:
    success_ctree <- data.frame("replication"  =i, # replication
                                "accuracy"     =cm_ctree$overall["Accuracy"],
                                "sensitivity"  =cm_ctree$byClass["Sensitivity"], 
                                "specificity"  =cm_ctree$byClass["Specificity"],
                                "precision"    =cm_ctree$byClass["Precision"],
                                "recall"       =cm_ctree$byClass["Recall"],
                                row.names=NULL);
    
    return (list("replication"       =i,
                 "data_train_indices"=train_test_splits[[i]]$in_id, 
                 "data_test_indices" =setdiff(1:nrow(train_test_splits[[i]]$data), train_test_splits[[i]]$in_id),
                 "success"=success_ctree));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  # Save these results to file:
  save(ctree_tb_m_all, cm_ctree_tb_m_all, success_ctree_tb_m_all, ctree_tb_m_traintest, 
       file="./cache-results/ctree_t3_m.RData", compress="xz", compression_level=9);
}
```

When using the frequency of the two alleles and the *macroarea* as predictors, the decision tree is trivial: it uniformly predicts just the majority value "No".

```{r fig.cap=capFig("Decision tree on the full data using the two alleles and macroarea.")}
plot(ctree_tb_m_all, gp=gpar(fontsize = 11));
```

`r sprintf("accuracy = %.1f%%, sensitivity = %.1f%%, specificity = %.1f%%, precision = %.1f%%, and recall = %.1f%%", 100*success_ctree_tb_m_all["accuracy"], 100*success_ctree_tb_m_all["sensitivity"], 100*success_ctree_tb_m_all["specificity"], 100*success_ctree_tb_m_all["precision"], 100*success_ctree_tb_m_all["recall"])`.

On the `r n_train` training/testing sets: `r success_ctree_tb_m_traintest <- do.call(rbind, lapply(ctree_tb_m_traintest, function(x) x$success)); paste0(names(success_ctree_tb_m_traintest)[-1], " = ", vapply(success_ctree_tb_m_traintest[,-1], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`.

```{r fig.cap=capFig("The success of generalising to the testing sets from the training sets (yellow boxplots) compared to the success on the full data (red segments).")}
ggplot(success_ctree_tb_m_traintest %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  # measures on the full dataset:
  geom_rect(data=success_ctree_tb_m_all %>% 
              reshape2::melt(measure.vars=c("accuracy", "sensitivity", "specificity", "precision", "recall"), variable.name="measure", value.name="value") %>%
              mutate("measure"=factor(measure, levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), "value"=value*100), 
            aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=value-0.10, ymax=value+0.10), color="red", fill="red") +
  theme(legend.position="right");
```


#### Random forests

##### Including macroarea

```{r include=FALSE}
## With macroareas:
if( !file.exists("./cache-results/forest_t3_m_all.RData") )
{
  forest_t3_m_all <- pblapply(1:n_replications, function(i) # computationally expensive
  {
    # fit the random forests:
    rf_tone <- cf_tone <- NULL;
    try(rf_tone <- randomForest(f_tone, data=d_t3, importance=TRUE), silent=TRUE);
    try(cf_tone <- cforest(f_tone, data=d_t3, ntree=cf_ntree), silent=TRUE);
    if( is.null(rf_tone) || is.null(cf_tone) ) return (NULL); # some error
    
    # confusion matrices:
    cm_rf_tone <- confusionMatrix(d_t3$tone_complex, rf_tone$predicted, positive="Yes");
    cm_cf_tone <- confusionMatrix(d_t3$tone_complex, predict(cf_tone),  positive="Yes");
    
    # predictor importance:
    pia_rf_tone <- pig_rf_tone <- piu_cf_tone <- NULL
    try(pia_rf_tone <- importance(rf_tone, type=1), silent=TRUE); # accuracy-based
    try(pig_rf_tone <- importance(rf_tone, type=2), silent=TRUE); # gini-based
    try(piu_cf_tone <- varimp(cf_tone, conditional=FALSE, nperm=cf_nperm), silent=TRUE); # unconditional
    if( is.null(pia_rf_tone) || is.null(pig_rf_tone) || is.null(piu_cf_tone) ) return (NULL); # some error
    
    # return the results:
    success <- data.frame("replication"     =i,                              # replication
                          "rf_accuracy"     =cm_rf_tone$overall["Accuracy"], # randomForest
                          "rf_sensitivity"  =cm_rf_tone$byClass["Sensitivity"], 
                          "rf_specificity"  =cm_rf_tone$byClass["Specificity"],
                          "rf_precision"    =cm_rf_tone$byClass["Precision"],
                          "rf_recall"       =cm_rf_tone$byClass["Recall"],
                          "cf_accuracy"     =cm_cf_tone$overall["Accuracy"], # cforest
                          "cf_sensitivity"  =cm_cf_tone$byClass["Sensitivity"], 
                          "cf_specificity"  =cm_cf_tone$byClass["Specificity"],
                          "cf_precision"    =cm_cf_tone$byClass["Precision"],
                          "cf_recall"       =cm_cf_tone$byClass["Recall"], 
                          row.names=NULL);
    pi_df  <- data.frame("replication"      =i,               # replication
                         "predictor"        =list_predictors, # predictors
                         "rf_accuracy_based"=pia_rf_tone,     # randomForest accuracy-based
                         "rf_gini_based"    =pig_rf_tone,     # randomForest gini-based
                         "cf_unconditional" =piu_cf_tone,     # cforest unconditional
                         row.names=NULL);
    
    return (list("replication"    =i,
                 "success"        =success,   
                 "pred_importance"=pi_df));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  
  # Assemble the various results and save them:
  forest_t3_m_all <- list("replications"   =n_replications,
                          "success"        =do.call(rbind, lapply(forest_t3_m_all, function(x) if(is.null(x)){ NULL; } else { x$success; })),
                          "pred_importance"=do.call(rbind, lapply(forest_t3_m_all, function(x) if(is.null(x)){ NULL; } else { x$pred_importance; })));
  save(forest_t3_m_all, file="./cache-results/forest_t3_m_all.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/forest_t3_m_all.RData");
}
```

- random forests: `r s <- grep("rf_", names(forest_t3_m_all$success), fixed=TRUE); paste0(substring(names(forest_t3_m_all$success)[s],4), " = ", vapply(forest_t3_m_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`
- conditional random forests: `r s <- grep("cf_", names(forest_t3_m_all$success), fixed=TRUE); paste0(substring(names(forest_t3_m_all$success)[s],4), " = ", vapply(forest_t3_m_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`

```{r fig.cap=capFig("The success of the two random forest methods on the full data."), fig.width=8, fig.height=4}
ggplot(forest_t3_m_all$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("method"=factor(if_else(substring(measure,1,2) == "rf", "random forest", "conditional random forest"), levels=c("random forest", "conditional random forest")), 
                "measure"=factor(substring(measure,4), levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), 
                "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  theme(legend.position="right") + 
  facet_grid(. ~ method);
```

```{r fig.cap=capFig("Variable importance using three methods: mean decrease in accuracy, mean decrease of the Gini coeficient, and unconditional importance."), fig.width=12, fig.height=4}
grid.arrange(ggplot(forest_t3_m_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseAccuracy, median), y=MeanDecreaseAccuracy, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease accuracy") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_t3_m_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseGini, median), y=MeanDecreaseGini, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease Gini index") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_t3_m_all$pred_importance, 
                    aes(x=reorder(predictor, cf_unconditional, median), y=cf_unconditional, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Unconditional importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ncol=3);
```


##### Excluding macroarea

```{r include=FALSE}
## Without macroareas:
if( !file.exists("./cache-results/forest_t3_nom_all.RData") )
{
  forest_t3_nom_all <- pblapply(1:n_replications, function(i) # computationally expensive
  {
    # fit the random forests:
    rf_tone <- cf_tone <- NULL;
    try(rf_tone <- randomForest(f_tone_nomacroarea, data=d_t3, importance=TRUE), silent=TRUE);
    try(cf_tone <- cforest(f_tone_nomacroarea, data=d_t3, ntree=cf_ntree), silent=TRUE);
    if( is.null(rf_tone) || is.null(cf_tone) ) return (NULL); # some error
    
    # confusion matrices:
    cm_rf_tone <- confusionMatrix(d_t3$tone_complex, rf_tone$predicted, positive="Yes");
    cm_cf_tone <- confusionMatrix(d_t3$tone_complex, predict(cf_tone),  positive="Yes");
    
    # predictor importance:
    pia_rf_tone <- pig_rf_tone <- piu_cf_tone <- NULL
    try(pia_rf_tone <- importance(rf_tone, type=1), silent=TRUE); # accuracy-based
    try(pig_rf_tone <- importance(rf_tone, type=2), silent=TRUE); # gini-based
    try(piu_cf_tone <- varimp(cf_tone, conditional=FALSE, nperm=cf_nperm), silent=TRUE); # unconditional
    if( is.null(pia_rf_tone) || is.null(pig_rf_tone) || is.null(piu_cf_tone) ) return (NULL); # some error
    
    # return the results:
    success <- data.frame("replication"     =i,                              # replication
                          "rf_accuracy"     =cm_rf_tone$overall["Accuracy"], # randomForest
                          "rf_sensitivity"  =cm_rf_tone$byClass["Sensitivity"], 
                          "rf_specificity"  =cm_rf_tone$byClass["Specificity"],
                          "rf_precision"    =cm_rf_tone$byClass["Precision"],
                          "rf_recall"       =cm_rf_tone$byClass["Recall"],
                          "cf_accuracy"     =cm_cf_tone$overall["Accuracy"], # cforest
                          "cf_sensitivity"  =cm_cf_tone$byClass["Sensitivity"], 
                          "cf_specificity"  =cm_cf_tone$byClass["Specificity"],
                          "cf_precision"    =cm_cf_tone$byClass["Precision"],
                          "cf_recall"       =cm_cf_tone$byClass["Recall"], 
                          row.names=NULL);
    pi_df  <- data.frame("replication"      =i,               # replication
                         "predictor"        =list_predictors_nomacroarea, # predictors
                         "rf_accuracy_based"=pia_rf_tone,     # randomForest accuracy-based
                         "rf_gini_based"    =pig_rf_tone,     # randomForest gini-based
                         "cf_unconditional" =piu_cf_tone,     # cforest unconditional
                         row.names=NULL);
    
    return (list("replication"    =i,
                 "success"        =success,   
                 "pred_importance"=pi_df));
  }, cl=mclapply_ncores); # try to use multiple cores, if present
  
  # Assemble the various results and save them:
  forest_t3_nom_all <- list("replications"   =n_replications,
                          "success"        =do.call(rbind, lapply(forest_t3_nom_all, function(x) if(is.null(x)){ NULL; } else { x$success; })),
                          "pred_importance"=do.call(rbind, lapply(forest_t3_nom_all, function(x) if(is.null(x)){ NULL; } else { x$pred_importance; })));
  save(forest_t3_nom_all, file="./cache-results/forest_t3_nom_all.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/forest_t3_nom_all.RData");
}
```

- random forests: `r s <- grep("rf_", names(forest_t3_nom_all$success), fixed=TRUE); paste0(substring(names(forest_t3_nom_all$success)[s],4), " = ", vapply(forest_t3_nom_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`
- conditional random forests: `r s <- grep("cf_", names(forest_t3_nom_all$success), fixed=TRUE); paste0(substring(names(forest_t3_nom_all$success)[s],4), " = ", vapply(forest_t3_nom_all$success[,s], function(x) sprintf("%.1f%% ±%.1f%%", mean(x,na.rm=TRUE)*100, sd(x,na.rm=TRUE)*100), character(1)), collapse=", ")`

```{r fig.cap=capFig("The success of the two random forest methods on the full data."), fig.width=8, fig.height=4}
ggplot(forest_t3_nom_all$success %>% 
         reshape2::melt(id.vars=c("replication"), variable.name="measure", value.name="value") %>% 
         mutate("method"=factor(if_else(substring(measure,1,2) == "rf", "random forest", "conditional random forest"), levels=c("random forest", "conditional random forest")), 
                "measure"=factor(substring(measure,4), levels=c("accuracy", "sensitivity", "specificity", "precision", "recall")), 
                "value"=value*100), 
       aes(x=measure, y=value, fill=measure)) + 
  ylim(c(0,100)) + xlab("Measures of success") + ylab("Value (%)") +
  theme_bw() +
  geom_boxplot(show.legend=FALSE) + 
  # draw alternating vertical bands:
  new_scale_fill() + 
  geom_rect(aes(xmin=as.numeric(measure)-0.5, xmax=as.numeric(measure)+0.5, ymin=0, ymax=100, fill=as.factor(as.numeric(measure) %% 2 == 0)), show.legend=FALSE) + 
  scale_fill_manual("", values=c("white", "gray95")) +
  # draw the actual boxplots:
  new_scale_fill() + 
  geom_boxplot(aes(x=measure, y=value), color="gray20", fill="lightyellow") + 
  theme(legend.position="right") + 
  facet_grid(. ~ method);
```

```{r fig.cap=capFig("Variable importance using three methods: mean decrease in accuracy, mean decrease of the Gini coeficient, and unconditional importance."), fig.width=12, fig.height=4}
grid.arrange(ggplot(forest_t3_nom_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseAccuracy, median), y=MeanDecreaseAccuracy, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease accuracy") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_t3_nom_all$pred_importance, 
                    aes(x=reorder(predictor, MeanDecreaseGini, median), y=MeanDecreaseGini, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Mean decrease Gini index") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ggplot(forest_t3_nom_all$pred_importance, 
                    aes(x=reorder(predictor, cf_unconditional, median), y=cf_unconditional, fill=predictor)) +
               theme_bw() +
               geom_boxplot(color="black") +
               labs(x="Predictors (decr. importance)", y="Unconditional importance") +
               theme(axis.text.y = element_text(angle=30, hjust=1, size=10), 
                     axis.text.x = element_text(hjust=1, size=10),
                     axis.title=element_text(size=16),
                     legend.position="bottom") +
               coord_flip() +
               NULL,
             ncol=3);
```


## Tone *counts*

```{r include=FALSE}
# Keep only the observation with non-missing data for the relevant variables:
d_tc <- unique(data_all[complete.cases(data_all[, c("n_tones",
                                                    "ASPM_freq_wavg", "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta",
                                                    "family_name", "macroarea", "metapop_ID")]), 
                        c("metapop", "metapop_ID", "pop_ID", "glottocode", "family_name", "macroarea", "latitude", "longitude", 
                          "n_tones", "ASPM_freq_wavg" , "MCPH1_freq_wavg", "ASPM_freq_wavg_4beta", "MCPH1_freq_wavg_4beta")]);
# and only the observations of the same pop_ID that have different tone and gene frequency data:
lgs_to_keep <- d_tc %>% group_by(metapop, pop_ID, n_tones, ASPM_freq_wavg, MCPH1_freq_wavg) %>%
  summarise("keep_glottocode"=glottocode[1]);
d_tc <- d_tc[ d_tc$glottocode %in% lgs_to_keep$keep_glottocode, ];

# Dichotomise macroarea:
d_tc$Africa <- factor(ifelse(d_tc$macroarea == "Africa", "Yes", "No"), levels=c("No", "Yes"));

# Recode Africa as numeric and ordered:
d_tc$Africa_num   <- as.numeric(d_tc$Africa == "Yes");
d_tc$Africa_ord   <- ordered(d_tc$Africa, levels=c("No", "Yes"));
```

I kept only the entries with non-missing data for the tone *counts*, *ASPM*-D and *MCPH1*-D, and if there are more than one possible languages or allele frequencies for a given sample, I only kept those entries that have different tone or allele data.
The resulting dataset has `r nrow(d_tc)` observations, distributed among `r length(unique(d_tc$glottocode))` unique Glottolg codes in `r length(unique(d_tc$family))` families (ranging from a minimum of 1 language per family to a maximum of `r max(tmp <- as.numeric(table(d_tc$family)))`, with a mean `r round(mean(tmp),1)` and median `r round(median(tmp),1)` languages per family) and `r length(unique(d_tc$macroarea))` macroareas.

```{r fig.cap=capFig("Distribution of tone *counts*.")}
pander(addmargins(tmp <- table(d_tc$n_tones, d_tc$macroarea)));
tmp <- as.data.frame(tmp);

distrib_all <- ggplot(as.data.frame(table(d_tc$n_tones)), aes(x=Var1, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone count") + ylab("Count") + 
  scale_fill_viridis_d("Tone counts") + theme(legend.position="top") + ggtitle("World") + 
  NULL;

distrib_africa <- ggplot(tmp[ tmp$Var2 == "Africa", ], aes(x=Var1, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone count") + ylab("Count") + 
  scale_fill_viridis_d("Tone counts") + theme(legend.position="none") + ggtitle("Africa") + 
  NULL;

distrib_eurasia <- ggplot(tmp[ tmp$Var2 == "Eurasia", ], aes(x=Var1, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone count") + ylab("Count") + 
  scale_fill_viridis_d("Tone counts") + theme(legend.position="none") + ggtitle("Eurasia") + 
  NULL;

distrib_america <- ggplot(tmp[ tmp$Var2 == "America", ], aes(x=Var1, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone count") + ylab("Count") + 
  scale_fill_viridis_d("Tone counts") + theme(legend.position="none") + ggtitle("America") + 
  NULL;

distrib_papunesia <- ggplot(tmp[ tmp$Var2 == "Papunesia", ], aes(x=Var1, y=Freq, fill=Var1)) +
  theme_bw() +
  geom_bar(stat="identity", color="black", alpha=0.25) + 
  geom_text(aes(label=Freq), color="black", position = position_stack(vjust = 0.5), size=3.0)+
  xlab("Tone count") + ylab("Count") + 
  scale_fill_viridis_d("Tone counts") + theme(legend.position="none") + ggtitle("Papunesia") + 
  NULL;

l <- get_legend(distrib_all);

grid.arrange(distrib_all + theme(legend.position = "none"), distrib_africa, distrib_eurasia, distrib_america, distrib_papunesia, l, 
             layout_matrix=rbind(c(1,2,3,4,5), 
                                 c(1,2,3,4,5), 
                                 c(1,2,3,4,5), 
                                 c(1,2,3,4,5),  
                                 c(1,2,3,4,5),  
                                 c(NA,NA,6,NA,NA))); 

```

```{r fig.cap=capFig("Distribution of tone *counts* across the world.")}
ggplot() +
  geom_polygon(data=mapWorld, aes(x=long, y=lat, group=group), fill="grey") +
  geom_point(data=d_tc, shape=21, size=1.5, aes(x=longitude, y=latitude, fill=n_tones)) +
  theme(legend.position = c(0.25, 0.32), 
      legend.justification = c(1, 1), 
      legend.title = element_text(size = 9), 
      legend.text = element_text(size = 10)) + 
  scale_fill_viridis_c("Tone counts");
```

```{r fig.cap=capFig("Relationship between tone *counts* (colors) and the two alleles (frequency) by macroarea."), fig.width=2*5, fig.height=2*3.2}
tmp <- d_tc; tmp$macroarea <- "All"; tmp <- rbind(tmp, d_tc); 
tmp$macroarea <- factor(tmp$macroarea, levels=c("All", "Africa", "America", "Eurasia", "Papunesia"));
tmp$n_tones <- factor(tmp$n_tones);
plot_tone2_alleles_p1 <- ggplot(tmp, aes(x=ASPM_freq_wavg, y=MCPH1_freq_wavg)) + xlim(0,1) + ylim(0,1) + 
  xlab(expression(italic("ASPM")-"D")) + ylab(expression(italic("MCPH1")-"D")) +
  geom_point(aes(fill=n_tones), alpha=0.75, color="black", shape=21) + 
  #geom_smooth(method="lm", formula=y~poly(x,2), color="black", alpha=0.25, size=0.5) + 
  facet_grid(. ~ macroarea) +
  scale_fill_viridis_d(expression(italic("counts"))) + 
  ggtitle(expression(italic("ASPM")-"D, "~italic("MCPH1")-"D & tone"~italic("counts")));
plot_tone2_alleles_p2 <- ggplot(tmp, aes(x=ASPM_freq_wavg, fill=n_tones)) + xlim(0,1) +
  geom_jitter(aes(y=n_tones), alpha=0.50, color="black") + 
  geom_violin(aes(y=n_tones), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=n_tones), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("ASPM")-"D")) + ylab(expression("tone"~italic("counts"))) +
  scale_fill_viridis_d(expression(italic("counts"))) + 
  ggtitle(expression("tone"~italic("counts")~" vs "~italic("ASPM")-"D"));
plot_tone2_alleles_p3 <- ggplot(tmp, aes(x=MCPH1_freq_wavg, fill=n_tones)) + xlim(0,1) +
  geom_jitter(aes(y=n_tones), alpha=0.50, color="black") + 
  geom_violin(aes(y=n_tones), alpha=0.35, color="black") + 
  geom_boxplot(aes(y=n_tones), alpha=0.35, color="black") + 
  facet_grid(. ~ macroarea) + xlab(expression(italic("MCPH1")-"D")) + ylab(expression("tone"~italic("counts"))) +
  scale_fill_viridis_d(expression(italic("counts"))) +
  ggtitle(expression("tone"~italic("counts")~" vs "~italic("MCPH1")-"D"));
grid.arrange(plot_tone2_alleles_p1, plot_tone2_alleles_p2, plot_tone2_alleles_p3, nrow=3);
```


```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone_counts_distribution.pdf", width=5*2.0, height=6*0.5);
grid.arrange(distrib_all + theme(legend.position = "none"), distrib_africa, distrib_eurasia, distrib_america, distrib_papunesia, l, 
             layout_matrix=rbind(c(1,2,3,4,5), 
                                 c(1,2,3,4,5), 
                                 c(1,2,3,4,5), 
                                 c(1,2,3,4,5),  
                                 c(1,2,3,4,5),  
                                 c(NA,NA,6,NA,NA))); 

dev.off();

cairo_pdf("./figures/tone_counts_alleles.pdf", width=5*2.5, height=3*2.75);
grid.arrange(plot_tone2_alleles_p1, plot_tone2_alleles_p2, plot_tone2_alleles_p3, nrow=3);
dev.off();
```


### Regressions

I used a mixed-effects *Poisson model*.

#### All data

##### `glmer`

```{r include=FALSE}
# Check for overdispersion (as per https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#overdispersion):
overdisp_fun <- function(model)
{
  rdf <- df.residual(model)
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}


# The null model:
m_tc_0 <- glmer(n_tones ~ 1 + # intercept
                  (1 | family_name), # random effects structure
                family=poisson(), data=d_tc, control=glmer_ctrl);
summary(m_tc_0);
overdisp_fun(m_tc_0); # no overdispersion

# Full model:
m_tc_full <- glmer(n_tones ~ 1 + # intercept
                     ASPM_freq_wavg + I(ASPM_freq_wavg^2) + MCPH1_freq_wavg + I(MCPH1_freq_wavg^2) + # the two alleles (and their interaction)
                     macroarea + # macroarea
                     (1 | family_name), # random effects structure
                   family=poisson(), data=d_tc, control=glmer_ctrl);
summary(m_tc_full);
overdisp_fun(m_tc_full); # no overdispersion
lattice::dotplot(ranef(m_tc_full, which="family_name", condVar=TRUE));

# Does macroarea matter?
m_tc_nom <- update(m_tc_full, . ~ . - macroarea);
summary(m_tc_nom);
anova(m_tc_full, m_tc_nom); # p=0.2075 -> no
anova(m_tc_0, m_tc_nom); # p=0.0435 * -> but the alleles matter

# Macroarea by itself:
m_tc_m <- update(m_tc_0, . ~ . + macroarea);
summary(m_tc_m);
anova(m_tc_0, m_tc_m); # p=0.01291 * -> macroarea predicts tone

# Do the alleles matter?
# ASPM:
m_tc_aspm_12 <- update(m_tc_0, . ~ . + ASPM_freq_wavg + I(ASPM_freq_wavg^2));
summary(m_tc_aspm_12); anova(m_tc_0, m_tc_aspm_12); # p=0.05236 .
m_tc_aspm_1 <- update(m_tc_aspm_12, . ~ . - I(ASPM_freq_wavg^2));
summary(m_tc_aspm_1); 
anova(m_tc_aspm_12, m_tc_aspm_1); # p=0.1227 -> no quadratic effect for ASPM
anova(m_tc_0, m_tc_aspm_1); # p=0.06074 . -> and no linear effect either
m_tc_aspm_1_m <- update(m_tc_aspm_1, . ~ . + macroarea);
summary(m_tc_aspm_1_m); 
# MCPH1:
m_tc_mcph1_12 <- update(m_tc_0, . ~ . + MCPH1_freq_wavg + I(MCPH1_freq_wavg^2));
summary(m_tc_mcph1_12); anova(m_tc_0, m_tc_mcph1_12); # p=0.05573 .
m_tc_mcph1_1 <- update(m_tc_mcph1_12, . ~ . - I(MCPH1_freq_wavg^2));
summary(m_tc_mcph1_1); 
anova(m_tc_mcph1_12, m_tc_mcph1_1); # p=0.9463 -> no quadratic effect for MCPH1
anova(m_tc_0, m_tc_mcph1_1); # p=0.0163 * -> but there is a linear negative effect!
m_tc_mcph1_1_m <- update(m_tc_mcph1_1, . ~ . + macroarea);
summary(m_tc_mcph1_1_m); 
anova(m_tc_mcph1_1, m_tc_mcph1_1_m); # p=0.1547 -> macroarea does not add anything
anova(m_tc_mcph1_1_m, m_tc_m); # p=0.6358 -> macroarea explains pretty much what MCPH1 seems to explain

# -> there is a linear negative effect of MCPH1 that seems fully explained by macroarea 
```

I used a mixed-effects Poisson model where tone *counts* are predicted by *macroarea* and the two alleles (linear and quadratic but no interactions) with language *family* as random effect.

For the "null model" (no fixed effects):

- the Poisson model is *not* overdispersed: `r sprintf("*&chi;*^2^(%d) = %.1f, *p* = %.2g", overdisp_fun(m_tc_0)["rdf"], overdisp_fun(m_tc_0)["chisq"], overdisp_fun(m_tc_0)["p"])`
- `r sprintf("ICC = %.1f%%", 100*performance::icc(m_tc_0)$ICC_adjusted)`, which shows that tone *counts* are clustered within families

For the "full" model:

- *macroarea* predicts tone *counts*: `r sprintf("*p* = %.2g", anova(m_tc_0, m_tc_m)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tc_m)$R2_marginal)`
- *ASPM*-D does not influence tone *counts* even in absence of *macroarea*: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_tc_aspm_1)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tc_aspm_1)$coefficients["ASPM_freq_wavg", "Std. Error"], anova(m_tc_0, m_tc_aspm_1)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tc_aspm_1)$R2_marginal)`, and after adding *macroarea* as a fixed effect: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_tc_aspm_1_m)$coefficients["ASPM_freq_wavg", "Estimate"], summary(m_tc_aspm_1_m)$coefficients["ASPM_freq_wavg", "Std. Error"], summary(m_tc_aspm_1_m)$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tc_aspm_1_m)$R2_marginal)`
- *MCPH1*-D influences tone *counts* in the absence of *macroarea*: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_tc_mcph1_1)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_tc_mcph1_1)$coefficients["MCPH1_freq_wavg", "Std. Error"], anova(m_tc_0, m_tc_mcph1_1)[2,"Pr(>Chisq)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tc_mcph1_1)$R2_marginal)`, but not after adding *macroarea* as a fixed effect: `r sprintf("*β* = %.2g ± %.2g, *p* = %.2g", summary(m_tc_mcph1_1_m)$coefficients["MCPH1_freq_wavg", "Estimate"], summary(m_tc_mcph1_1_m)$coefficients["MCPH1_freq_wavg", "Std. Error"], summary(m_tc_mcph1_1_m)$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"])`, `r sprintf("R^2^ = %.1f%%", 100*performance::r2(m_tc_mcph1_1_m)$R2_marginal)`


##### `brms`

###### Macroarea as raneff

```{r include=FALSE}
if( file.exists("./cache-results/brms_tc.RData") )
{
  load("./cache-results/brms_tc.RData");
} else
{
  # The null model:
  b_tc_0 <- brm(n_tones ~ 1 + # intercept
                  (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                family=poisson(), data=d_tc, 
                prior=c(prior(student_t(3, 0, 2.5), class="Intercept")), # pretty wide priors centered on 0
                save_pars=save_pars(all=TRUE), # needed for Bayes factors
                sample_prior=TRUE,  # needed for hypotheses tests
                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tc_0); mcmc_plot(b_tc_0, type="trace"); mcmc_plot(b_tc_0, type="areas");
  
  # Full model:
  b_tc_full <- brm(n_tones ~ 1 + # intercept
                     ASPM_freq_wavg + MCPH1_freq_wavg + # the two alleles (and their interaction)
                     ASPM_freq_wavg:MCPH1_freq_wavg + # interaction between alleles
                     (1 | family_name / metapop) + (1 | macroarea), # random effects structure
                   family=poisson(), data=d_tc, 
                   prior=c(prior(student_t(3, 0, 2.5), class="Intercept"),
                           prior(student_t(3, 0, 2.5), class="b")), # pretty wide priors centered on 0
                   save_pars=save_pars(all=TRUE), # needed for Bayes factors
                   sample_prior=TRUE,  # needed for hypotheses tests
                   cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10));
  summary(b_tc_full); mcmc_plot(b_tc_full, type="trace"); mcmc_plot(b_tc_full, type="areas");
  # Check interaction:
  brms::hypothesis(b_tc_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.58 -> I can remove the interaction
  b_tc_full <- update(b_tc_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tc_full); mcmc_plot(b_tc_full, type="trace"); mcmc_plot(b_tc_full, type="areas");
  (b_tc_full_hyps <- brms::hypothesis(b_tc_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.79 and 0.77 -> not bad!
  (b_tc_full_hdi <- bayestestR::hdi(b_tc_full, ci=0.95));
  
  #sjPlot::plot_model(b_tc_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(b_tc_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  b_tc_aspm_only <- update(b_tc_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tc_aspm_only); mcmc_plot(b_tc_aspm_only, type="trace"); mcmc_plot(b_tc_aspm_only, type="areas");
  brms::hypothesis(b_tc_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.80 -> not bad!
  # MCPH1:
  b_tc_mcph1_only <- update(b_tc_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(b_tc_mcph1_only); mcmc_plot(b_tc_mcph1_only, type="trace"); mcmc_plot(b_tc_mcph1_only, type="areas");
  brms::hypothesis(b_tc_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.78 -> not bad!
  
  # Formal model comparisons:
  b_tc_0          <- brms_fit_indices(b_tc_0);
  b_tc_full       <- brms_fit_indices(b_tc_full);
  b_tc_aspm_only  <- brms_fit_indices(b_tc_aspm_only);
  b_tc_mcph1_only <- brms_fit_indices(b_tc_mcph1_only);
  (b_tc_cmp_null_full  <- brms_compare_models(b_tc_0, b_tc_full, "null", "full"));
  (b_tc_cmp_null_aspm  <- brms_compare_models(b_tc_0, b_tc_aspm_only, "null", "ASPM")); 
  (b_tc_cmp_null_mcph1 <- brms_compare_models(b_tc_0, b_tc_mcph1_only, "null", "MCPH1"));
  (b_tc_cmp_full_aspm  <- brms_compare_models(b_tc_full, b_tc_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (b_tc_cmp_full_mcph1 <- brms_compare_models(b_tc_full, b_tc_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  
  # Save these results to file:
  save(b_tc_full, b_tc_0, b_tc_aspm_only, b_tc_mcph1_only,
       b_tc_full_hyps, b_tc_full_hdi, b_tc_cmp_null_full, b_tc_cmp_null_aspm, b_tc_cmp_null_mcph1, b_tc_cmp_full_aspm, b_tc_cmp_full_mcph1, 
       file="./cache-results/brms_tc.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(b_tc_full, type="areas");
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(b_tc_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(b_tc_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_tc_full_hdi$CI_low[ b_tc_full_hdi$Parameter == "b_ASPM_freq_wavg" ], b_tc_full_hdi$CI_high[ b_tc_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_tc_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(b_tc_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", b_tc_full_hdi$CI_low[ b_tc_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], b_tc_full_hdi$CI_high[ b_tc_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",b_tc_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(b_tc_cmp_null_full)`.

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(b_tc_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(b_tc_cmp_full_aspm)`.

```{r fig.cap=capFig("Plot of the posterior distribution of the macroareas as random effect.")}
# macroarea:
b_tc_full %>%
  spread_draws(b_Intercept, r_macroarea[macroarea,]) %>%
  mutate(macroarea_mean = b_Intercept + r_macroarea) %>%
  ggplot(aes(y = macroarea, x = macroarea_mean)) +
  stat_halfeye(fill="skyblue") + 
  geom_vline(xintercept = 0, linetype = "dashed");
```

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(b_tc_0) + ggtitle("null model"),
             pp_check(b_tc_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(b_tc_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(b_tc_full) + ggtitle("full model"), 
             ncol=2);
```


###### Gaussian process

```{r include=FALSE}
if( file.exists("./cache-results/gp_tc.RData") )
{
  load("./cache-results/gp_tc.RData");
} else
{
  # Full model:
  gp_tc_full <- brm(bf(n_tones ~ 1 +                                      # intercept
                         ASPM_freq_wavg + MCPH1_freq_wavg +               # the two alleles (and their interaction)
                         ASPM_freq_wavg:MCPH1_freq_wavg +                 # interaction between alleles
                         gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                         (1 | family_name / metapop)),                    # family and metapopulation
                    data=d_tc,
                    family=poisson(),
                    prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), 
                            prior(student_t(3, 0, 2.5), class="b"), # pretty wide priors centered on 0
                            prior(normal(1, 0.2), class="sd"),      # try to reduce over-fitting
                            prior(normal(0, 3), class="sdgp")),     # pretty wide prior centered on 0
                    save_pars=save_pars(all=TRUE), # needed for Bayes factors
                    sample_prior=TRUE,  # needed for hypotheses tests
                    chains=4, cores=brms_ncores, iter=10000, warmup=3000, thin=5, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(gp_tc_full); mcmc_plot(gp_tc_full, type="trace"); mcmc_plot(gp_tc_full, type="areas");
  # Check interaction:
  brms::hypothesis(gp_tc_full, c("ASPM_freq_wavg:MCPH1_freq_wavg = 0")); # p=0.55 -> I can remove the interaction
  gp_tc_full <- update(gp_tc_full, . ~ . - ASPM_freq_wavg:MCPH1_freq_wavg, cores=brms_ncores, iter=10000, warmup=3000, thin=5, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(gp_tc_full); mcmc_plot(gp_tc_full, type="trace"); mcmc_plot(gp_tc_full, type="areas");
  (gp_tc_full_hyps <- brms::hypothesis(gp_tc_full, c("ASPM_freq_wavg < 0", "MCPH1_freq_wavg < 0"))); # p=0.69, 0.92
  (gp_tc_full_hdi <- bayestestR::hdi(gp_tc_full, ci=0.95));
  
  #sjPlot::plot_model(gp_tc_full, type="pred", terms=c("ASPM_freq_wavg [all]"));
  #sjPlot::plot_model(gp_tc_full, type="pred", terms=c("MCPH1_freq_wavg [all]"));
  
  # Check each allele separately:
  # ASPM:
  gp_tc_aspm_only <- update(gp_tc_full, . ~ . - MCPH1_freq_wavg, cores=brms_ncores, iter=10000, warmup=3000, thin=5, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(gp_tc_aspm_only); mcmc_plot(gp_tc_aspm_only, type="trace"); mcmc_plot(gp_tc_aspm_only, type="areas");
  brms::hypothesis(gp_tc_aspm_only, c("ASPM_freq_wavg < 0")); # p=0.65 -> not bad!
  # MCPH1:
  gp_tc_mcph1_only <- update(gp_tc_full, . ~ . - ASPM_freq_wavg, cores=brms_ncores, iter=10000, warmup=3000, thin=5, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(gp_tc_mcph1_only); mcmc_plot(gp_tc_mcph1_only, type="trace"); mcmc_plot(gp_tc_mcph1_only, type="areas");
  brms::hypothesis(gp_tc_mcph1_only, c("MCPH1_freq_wavg < 0")); # p=0.92 -> not bad!
  
  # Null model:
  gp_tc_0 <- brm(bf(n_tones ~ 1 +                                      # intercept
                      gp(longitude, latitude, by=macroarea, gr=TRUE) + # the Gaussian process modeling contact
                      (1 | family_name / metapop)),                    # family and metapopulation
                 data=d_tc,
                 family=poisson(),
                    prior=c(prior(student_t(3, 0, 2.5), class="Intercept"), # pretty wide priors centered on 0
                            prior(normal(1, 0.2), class="sd"),              # try to reduce over-fitting
                            prior(normal(0, 3), class="sdgp")),             # pretty wide prior centered on 0
                 save_pars=save_pars(all=TRUE), # needed for Bayes factors
                 sample_prior=TRUE,  # needed for hypotheses tests
                 chains=4, cores=brms_ncores, iter=10000, warmup=3000, thin=5, control=list(adapt_delta=0.99, max_treedepth=10));
  summary(gp_tc_0); mcmc_plot(gp_tc_0, type="trace"); mcmc_plot(gp_tc_0, type="areas");
  # Formal model comparisons:
  gp_tc_0          <- brms_fit_indices(gp_tc_0);
  gp_tc_full       <- brms_fit_indices(gp_tc_full);
  gp_tc_aspm_only  <- brms_fit_indices(gp_tc_aspm_only);
  gp_tc_mcph1_only <- brms_fit_indices(gp_tc_mcph1_only);
  (gp_tc_cmp_null_full  <- brms_compare_models(gp_tc_0, gp_tc_full, "null", "full"));
  (gp_tc_cmp_null_aspm  <- brms_compare_models(gp_tc_0, gp_tc_aspm_only, "null", "ASPM"));
  (gp_tc_cmp_null_mcph1 <- brms_compare_models(gp_tc_0, gp_tc_mcph1_only, "null", "MCPH1"));
  (gp_tc_cmp_full_aspm  <- brms_compare_models(gp_tc_full, gp_tc_aspm_only, "full", "ASPM (i.e., removing MCPH1)"));
  (gp_tc_cmp_full_mcph1 <- brms_compare_models(gp_tc_full, gp_tc_mcph1_only, "full", "MCPH1 (i.e., removing ASPM)"));
  

  # Save these results to file:
  save(gp_tc_full, gp_tc_0, gp_tc_aspm_only, gp_tc_mcph1_only,
       gp_tc_full_hyps, gp_tc_full_hdi, gp_tc_cmp_null_full, gp_tc_cmp_null_aspm, gp_tc_cmp_null_mcph1, gp_tc_cmp_full_aspm, gp_tc_cmp_full_mcph1, 
       file="./cache-results/gp_tc.RData", compress="xz", compression_level=9);
}
```

The interaction between the two alleles does not contribute, and the posterior distribution of the results is:

```{r fig.cap=capFig("Posterior distribution of the Bayesian regression with a 2D Gaussian process results showing the 95% HDIs versus 0 (the vertical line).")}
mcmc_plot(gp_tc_full, type="areas", pars=c("b_Intercept", "b_ASPM", "b_MCPH1"));
```

```{r fig.cap=capFig("Conditional effects for the full model with 95% HDIs."), fig.show="hold", out.width="50%"}
plot(conditional_effects(gp_tc_full, effects=c("ASPM_freq_wavg", "MCPH1_freq_wavg")), points=TRUE, ask=FALSE);
```

The *individual effects* of the two "derived" alleles in the full model are:

- *ASPM*-D: *&beta;* = `r round(gp_tc_full_hyps$hypothesis$Estimate[1],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_tc_full_hdi$CI_low[ gp_tc_full_hdi$Parameter == "b_ASPM_freq_wavg" ], gp_tc_full_hdi$CI_high[ gp_tc_full_hdi$Parameter == "b_ASPM_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_tc_full_hyps$hypothesis$Post.Prob[1])`
- *MCPH1*-D: *&beta;* = `r round(gp_tc_full_hyps$hypothesis$Estimate[2],2)`, 95%HDI = `r sprintf("[%.2f, %.2f]", gp_tc_full_hdi$CI_low[ gp_tc_full_hdi$Parameter == "b_MCPH1_freq_wavg" ], gp_tc_full_hdi$CI_high[ gp_tc_full_hdi$Parameter == "b_MCPH1_freq_wavg" ])`, posterior probability *p*(*&beta;*<0) = `r sprintf("%.2g",gp_tc_full_hyps$hypothesis$Post.Prob[2])`.

The model comparison: `r print_brms_model_comparison(gp_tc_cmp_null_full)`.

*Removing one allele* from the full model: 

- removing *ASPM*-D: `r print_brms_model_comparison(gp_tc_cmp_full_mcph1)`
- removing *MCPH1*-D: `r print_brms_model_comparison(gp_tc_cmp_full_aspm)`.

Comparing the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models using visual posterior predictive checks:

```{r fig.cap=capFig("Visual posterior predictive checks for the *null*, *ASPM*-D-only, *MCPH1*-D-only and *full* models.")}
grid.arrange(pp_check(gp_tc_0) + ggtitle("null model"),
             pp_check(gp_tc_aspm_only) + ggtitle("ASPM-D-only model"),
             pp_check(gp_tc_mcph1_only) + ggtitle("MCPH1-D-only model"),
             pp_check(gp_tc_full) + ggtitle("full model"), 
             ncol=2);
```


#### Randomization

```{r include=FALSE}
# Permutations:
if( file.exists("./cache-results/perm_res_tc_glmer.RData") )
{
  load("./cache-results/perm_res_tc_glmer.RData");
} else
{
  perm_res_tc_glmer <- rbind(
    # Original values:
    do.call(rbind, pblapply(unique(all_conditions$macroarea), function(macroarea)
    {
      r <- NULL;
      capture.output(try(r <- .fit_permuted(d_tc, tone_dv="n_tones", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                            macroarea=macroarea, permute="nothing", within="unrestricted", regression_type="poisson"),
                         silent=TRUE), type="message");
      if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=0), r)) }
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character),
    # Permute values:
    do.call(rbind, pblapply(1:n_permutations, function(i)
    {
      do.call(rbind, lapply(1:nrow(all_conditions), function(j)
      {
        r <- NULL;
        capture.output(try(r <- .fit_permuted(d_tc, tone_dv="n_tones", aspm_iv="ASPM_freq_wavg", mcph1_iv="MCPH1_freq_wavg",
                                              macroarea=all_conditions$macroarea[j], permute=all_conditions$permute[j], within=all_conditions$within[j], regression_type="poisson"),
                           silent=TRUE), type="message");
        if( is.null(r) ) { return (NULL) } else { return (cbind(data.frame("replication"=i), r)) }
      }));
    }, cl=mclapply_ncores)) %>% mutate_if(is.factor, as.character));
  # Save these results to file:
  save(perm_res_tc_glmer, file="./cache-results/perm_res_tc_glmer.RData", compress="xz", compression_level=9);
}
```

We performed `r n_permutations` independent replications:

```{r}
# Summarize and plot these randomization results:
perm_res_tc_glmer_summary <- do.call(rbind, lapply(1:nrow(all_conditions), function(i) 
  {
    original_results <- perm_res_tc_glmer[ perm_res_tc_glmer$macroarea == all_conditions$macroarea[i] & perm_res_tc_glmer$permute == "nothing", ];
    .summarize_permuted(perm_res_tc_glmer, 
                        original=original_results, macroarea=all_conditions$macroarea[i], permute=all_conditions$permute[i], permute_within=all_conditions$within[i]);
}));
# Column order:
perm_res_tc_glmer_summary <- perm_res_tc_glmer_summary[, c("permute_within", "macroarea", "permute", 
                                                           "better_AIC", "signif_vs_null", "signif_ASPM", "smaller_beta_ASPM", "signif_MCPH1", "smaller_beta_MCPH1")];
# To percent:
perm_res_tc_glmer_summary$better_AIC         <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$better_AIC);
perm_res_tc_glmer_summary$signif_vs_null     <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$signif_vs_null);
perm_res_tc_glmer_summary$signif_ASPM        <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$signif_ASPM);
perm_res_tc_glmer_summary$smaller_beta_ASPM  <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$smaller_beta_ASPM);
perm_res_tc_glmer_summary$signif_MCPH1       <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$signif_MCPH1);
perm_res_tc_glmer_summary$smaller_beta_MCPH1 <- sprintf("%.0f%%",100*perm_res_tc_glmer_summary$smaller_beta_MCPH1);
# SHow it:
knitr::kable(perm_res_tc_glmer_summary,
             col.names=c("Permute within", "Macroarea", "Permute", "AIC", "Signif.", "*p*~*ASPM*-D~", "*&beta;*~*ASPM*-D~", "*p*~*MCPH1*-D~", "*&beta;*~*MCPH1*-D~"), 
             align="r",
             caption="Regressions with randomizations for tone *counts*.");
```

```{r fig.cap=paste0("Regressions on ",n_permutations," permuted data. Each plot shows the original result (vertical dashed black line) and the distribution of the permutations for the three possible things to be permuted (colored curves) for each combination of permutation constraints (horizontal panels) and control for *macroarea* (vertical panels) in terms of the effect size *&beta;*; *ASPM*-D is on the left and *MCPH1*-D on the right. The vertical dotted black thin line is at 0.0."), fig.height=2*2+0.5, fig.width=6*2.5}
perm_res_tc_glmer$macroarea      <- factor(as.character(perm_res_tc_glmer$macroarea), levels=c("none", "fixef"));
perm_res_tc_glmer$permute        <- factor(as.character(perm_res_tc_glmer$permute), levels=c("nothing", "tone", "alleles-together", "alleles-independent"));
perm_res_tc_glmer$permute_within <- factor(as.character(perm_res_tc_glmer$permute_within), levels=c("unrestricted", "macroareas", "families"));

# ASPM:
p1 <-ggplot(perm_res_tc_glmer[ perm_res_tc_glmer$permute != "nothing", ], aes(x=ASPM_b)) + xlab("β") + xlim(-5,5) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_tc_glmer[ perm_res_tc_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=ASPM_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "top") + 
  scale_fill_discrete("What is permuted:") + scale_color_discrete("What is permuted:");
# MCPH1:
p2 <- ggplot(perm_res_tc_glmer[ perm_res_tc_glmer$permute != "nothing", ], aes(x=MCPH1_b)) + xlab("β") + xlim(-5,5) + 
  geom_density(aes(fill=permute, color=permute), alpha=0.5) + 
  geom_vline(data=perm_res_tc_glmer[ perm_res_tc_glmer$permute == "nothing", c("macroarea", "ASPM_b", "MCPH1_b")], aes(xintercept=MCPH1_b), color="black", linetype="dashed") + 
  geom_vline(xintercept=0.0, color="black", linetype="dotted") + 
  facet_grid(macroarea ~ permute_within, scales="free_y") + theme(legend.position = "none");
l <- get_legend(p1);
grid.arrange(p1 + theme(legend.position = "none") + ggtitle("ASPM"), p2 + ggtitle("MCPH1"), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone_counts_regressions_permuted.pdf", width=6*1.25, height=2*1.50+0.15); 
grid.arrange(p1 + theme(legend.position = "none") + ggtitle(expression(italic("ASPM")-"D")), p2 + ggtitle(expression(italic("MCPH1")-"D")), l, 
             layout_matrix=rbind(c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2),
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(1,1,1, 2,2,2), 
                                 c(NA,NA, 3,3, NA,NA))); 
dev.off();
```


#### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( file.exists("./cache-results/reg_samples_per_fam_tc.RData") )
{
  load("./cache-results/reg_samples_per_fam_tc.RData");
} else
{
  reg_samples_per_fam_count <- do.call(rbind, lapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tc);
    
    # Null:
    m_0 <- glm(n_tones ~ 1, family=poisson(), data=d);
    # ASPM:
    m_aspm <- glm(n_tones ~ 1 + ASPM_freq_wavg, family=poisson(), data=d); a_aspm <- anova(m_0, m_aspm, test="Chisq");
    # MCPH1:
    m_mcph1 <- glm(n_tones ~ 1 + MCPH1_freq_wavg, family=poisson(), data=d); a_mcph1 <- anova(m_0, m_mcph1, test="Chisq");
    # Both alleles:
    m_alleles <- glm(n_tones ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg, family=poisson(), data=d); a_alleles <- anova(m_0, m_alleles, test="Chisq");
    # macroarea:
    m_macroarea <- glm(n_tones ~ 1 + macroarea, family=poisson(), data=d); a_macroarea <- anova(m_0, m_macroarea, test="Chisq");
    # ASPM + m_macroarea:
    m_aspm_macroarea <- glm(n_tones ~ 1 + ASPM_freq_wavg + macroarea, family=poisson(), data=d);
    # MCPH1 + m_macroarea:
    m_mcph1_macroarea <- glm(n_tones ~ 1 + MCPH1_freq_wavg + macroarea, family=poisson(), data=d);
    # all:
    m_full <- glm(n_tones ~ 1 + ASPM_freq_wavg + MCPH1_freq_wavg + macroarea, family=poisson(), data=d); a_full <- anova(m_0, m_full, test="Chisq");
    
    # Return value:
    data.frame("b_aspm"=m_aspm$coefficients[2],   "p_aspm"=summary(m_aspm)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_aspm_macroarea"=m_aspm_macroarea$coefficients["ASPM_freq_wavg"], "p_aspm_macroarea"=summary(m_aspm_macroarea)$coefficients["ASPM_freq_wavg","Pr(>|z|)"],
               "b_mcph1"=m_mcph1$coefficients[2], "p_mcph1"=summary(m_mcph1)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"], 
               "b_mcph1_macroarea"=m_mcph1_macroarea$coefficients["MCPH1_freq_wavg"], "p_mcph1_macroarea"=summary(m_mcph1_macroarea)$coefficients["MCPH1_freq_wavg","Pr(>|z|)"],
               "p_alleles"=a_alleles[2,"Pr(>Chi)"], 
               "p_macroarea"=a_macroarea[2,"Pr(>Chi)"], 
               "b_aspm_all"=m_full$coefficients["ASPM_freq_wavg"], "b_mcph1_all"=m_full$coefficients["MCPH1_freq_wavg"], "p_all"=a_full[2,"Pr(>Chi)"]);
  }));
  # Save these results to file:
  save(reg_samples_per_fam_count, file="./cache-results/reg_samples_per_fam_tc.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig(paste0("Results for ",n_samples," restricted samplings. For *ASPM*-D (left): ", round(100*sum(reg_samples_per_fam_count$b_aspm<0)/nrow(reg_samples_per_fam_count),1), "% of &beta;s are negative when regressing tone on *ASPM* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_aspm, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam_count$b_aspm_macroarea<0)/nrow(reg_samples_per_fam_count),1), "%, when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_aspm_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam_count$b_aspm_all<0)/nrow(reg_samples_per_fam_count),1), "% when controlling for both macroarea and *MCPH1* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_aspm_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "). For *MCPH1*-D (right): ", round(100*sum(reg_samples_per_fam_count$b_mcph1<0)/nrow(reg_samples_per_fam_count),1), "% of &beta;s are negative when regressing tone on *MCPH1* alone (", sprintf("one-sided *t*-test < 0: *t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_mcph1, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), ", round(100*sum(reg_samples_per_fam_count$b_mcph1_macroarea<0)/nrow(reg_samples_per_fam_count),1), "% when controlling for the macroarea (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_mcph1_macroarea, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), "), and ", round(100*sum(reg_samples_per_fam_count$b_mcph1_all<0)/nrow(reg_samples_per_fam_count),1), "% when controlling for both macroarea and *ASPM* (", sprintf("*t*(%d) = %.1f, mean = %.2f, *p* = %.2g", (tt <- t.test(reg_samples_per_fam_count$b_mcph1_all, mu=0.0, alternative="less"))$parameter, tt$statistic, tt$estimate, tt$p.value), ").")), fig.width=2*4, fig.height=1*4+0.25}
tmp <- rbind(cbind("gene"="ASPM",
                   reshape2::melt(reg_samples_per_fam_count[,c("b_aspm", "b_aspm_macroarea", "b_aspm_all")], 
                                  measure.vars=c("b_aspm", "b_aspm_macroarea", "b_aspm_all"), variable.name="model", value.name="beta")),
             cbind("gene"="MCPH1",
                   reshape2::melt(reg_samples_per_fam_count[,c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all")], 
                                  measure.vars=c("b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), variable.name="model", value.name="beta")));
tmp$model <- factor(as.character(tmp$model), 
                    levels=c("b_aspm", "b_aspm_macroarea", "b_aspm_all", "b_mcph1", "b_mcph1_macroarea", "b_mcph1_all"), 
                    labels=c("by itself", "ctrl macroarea", "ctrl macroarea & the other allele", "by itself", "ctrl macroarea", "ctrl macroarea & the other allele"));

ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone_counts_regressions_restricted.pdf", width=2*2.5, height=1*2.5+0.25);
ggplot(tmp, aes(x=beta, fill=model)) + 
  geom_density(alpha=0.25) + geom_vline(xintercept=0.0, color="black", linetype="dotted") + xlim(-10,10) + xlab("β") +
  #facet_wrap(. ~ gene, scales="free_y", labeller=labeller(gene=c("ASPM"=expression(italic("ASPM")-"D"), "MCPH1"=expression(italic("MCPH1")-"D")))) + 
  facet_wrap(. ~ gene, scales="free_y", labeller=label_bquote(italic(.(gene))-"D")) + 
  theme(legend.position="bottom") + scale_fill_discrete(name="Model");
dev.off();
```


### Mediation and path analysis

#### Mediation analysis

##### All data

###### `(g)lm`

```{r include=FALSE}
# ASPM:
med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d_tc); (med_aspm_f1_summary <- summary(med_aspm_f1));
med_aspm_f2 <- glm(n_tones ~ ASPM_freq_wavg + Africa, family=poisson(), data=d_tc); (med_aspm_f2_summary <- summary(med_aspm_f2));
med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE); (med_aspm_summary <- summary(med_aspm));

# MCPH1:
med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d_tc); (med_mcph1_f1_summary <- summary(med_mcph1_f1));
med_mcph1_f2 <- glm(n_tones ~ MCPH1_freq_wavg + Africa, family=poisson(), data=d_tc); (med_mcph1_f2_summary <- summary(med_mcph1_f2));
med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE); (med_mcph1_summary <- summary(med_mcph1));
```

For *ASPM*-D, there are:

- **TE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$tau.coef, med_aspm_summary$tau.ci[1], med_aspm_summary$tau.ci[2], med_aspm_summary$tau.p)`
- **ADE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$z.avg, med_aspm_summary$z.avg.ci[1], med_aspm_summary$z.avg.ci[2], med_aspm_summary$z.avg.p)`
- **ACME**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_aspm_summary$d.avg, med_aspm_summary$d.avg.ci[1], med_aspm_summary$d.avg.ci[2], med_aspm_summary$d.avg.p)`, mediating `r sprintf("%.1f%% (%.1f%%, %.1f%%), *p*=%.2g", 100*med_aspm_summary$n.avg, 100*med_aspm_summary$n.avg.ci[1], 100*med_aspm_summary$n.avg.ci[2], med_aspm_summary$n.avg.p)` of the effect:

  + effect of being in Africa on *ASPM*-D: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_aspm_f1_summary$coefficients["AfricaYes", "Estimate"], med_aspm_f1_summary$coefficients["AfricaYes", "Std. Error"], med_aspm_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"])`
  + effect of *ASPM*-D on tone *counts*: `r sprintf("%.2f ±%.2f, *p*=%.2g", med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Estimate"], med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Std. Error"], med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Pr(>|z|)"])`

For *MCPH1*-D, there are:

- **TE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$tau.coef, med_mcph1_summary$tau.ci[1], med_mcph1_summary$tau.ci[2], med_mcph1_summary$tau.p)`
- **ADE**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$z.avg, med_mcph1_summary$z.avg.ci[1], med_mcph1_summary$z.avg.ci[2], med_mcph1_summary$z.avg.p)`
- **ACME**: `r sprintf("%.2f (%.2f, %.2f), *p*=%.2g", med_mcph1_summary$d.avg, med_mcph1_summary$d.avg.ci[1], med_mcph1_summary$d.avg.ci[2], med_mcph1_summary$d.avg.p)`, mediating `r sprintf("%.1f%% (%.1f%%, %.1f%%), *p*=%.2g", 100*med_mcph1_summary$n.avg, 100*med_mcph1_summary$n.avg.ci[1], 100*med_mcph1_summary$n.avg.ci[2], med_mcph1_summary$n.avg.p)` of the effect.


###### `brms`

```{r include=FALSE}
if( file.exists("./cache-results/brms_tc_med.RData") )
{
  load("./cache-results/brms_tc_med.RData");
} else
{
  # Mediation with brms:
  # ASPM:
  bmed_africa_aspm__tc <- .fit_mediation_model(d=d_tc, 
                                               outcome="n_tones", outcome_name="tone", 
                                               treatment="Africa", treatment_name="Africa", 
                                               mediator="ASPM_freq_wavg_4beta", mediator_name="ASPM", 
                                               family_mediator=Beta(), family_outcome=poisson(), ranefs="(1 | family_name / metapop)",
                                               cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                               save_model=FALSE, show_results=TRUE);
  
  # MCPH1:
  bmed_africa_mcph1__tc <- .fit_mediation_model(d=d_tc, 
                                                outcome="n_tones", outcome_name="tone", 
                                                treatment="Africa", treatment_name="Africa", 
                                                mediator="MCPH1_freq_wavg_4beta", mediator_name="MCPH1", 
                                                family_mediator=Beta(), family_outcome=poisson(), ranefs="(1 | family_name / metapop)",
                                                cores=brms_ncores, iter=4000, warmup=2000, thin=2, control=list(adapt_delta=0.999, max_treedepth=10),
                                                save_model=FALSE, show_results=TRUE);
  
  # Save these results to file:
  save(bmed_africa_aspm__tc, bmed_africa_mcph1__tc, 
       file="./cache-results/brms_tc_med.RData", compress="xz", compression_level=9);
}
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *ASPM*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_aspm__tc; .plot_mediation_model(m$summary, m$mediation, 
                                                 outcome=m$outcome, outcome_name=m$outcome_name, 
                                                 treatment=m$treatment, treatment_name=m$treatment_name, 
                                                 mediator=m$mediator, mediator_name=m$mediator_name);
```

```{r fig.cap=capFig("Graphical representation of the Bayesian mediation analysis for *MCPH1*-D showing the means of the effects and the actual partial regression coefficients, with their 95% HDIs. The colors reflect the sign of the mean estimate.")}
m <- bmed_africa_mcph1__tc; .plot_mediation_model(m$summary, m$mediation, 
                                                  outcome=m$outcome, outcome_name=m$outcome_name, 
                                                  treatment=m$treatment, treatment_name=m$treatment_name, 
                                                  mediator=m$mediator, mediator_name=m$mediator_name);
```

##### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/med_tc_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  med_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tc);
    
    # ASPM:
    med_aspm_f1 <- med_aspm_f2 <- med_aspm <- NULL;
    try(med_aspm_f1 <- lm(ASPM_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_aspm_f1) ){ return (NULL); }; (med_aspm_f1_summary <- summary(med_aspm_f1));
    try(med_aspm_f2 <- glm(n_tones ~ ASPM_freq_wavg + Africa, family=poisson(), data=d), silent=TRUE); if( is.null(med_aspm_f2) ){ return (NULL); }; (med_aspm_f2_summary <- summary(med_aspm_f2));
    try(med_aspm <- mediation::mediate(med_aspm_f1, med_aspm_f2, treat='Africa', mediator='ASPM_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_aspm) ){ return (NULL); }; (med_aspm_summary <- summary(med_aspm));
    
    # MCPH1:
    med_mcph1_f1 <- med_mcph1_f2 <- med_mcph1 <- NULL;
    try(med_mcph1_f1 <- lm(MCPH1_freq_wavg ~ Africa, data=d), silent=TRUE); if( is.null(med_mcph1_f1) ){ return (NULL); }; (med_mcph1_f1_summary <- summary(med_mcph1_f1));
    try(med_mcph1_f2 <- glm(n_tones ~ MCPH1_freq_wavg + Africa, family=poisson(), data=d), silent=TRUE); if( is.null(med_mcph1_f2) ){ return (NULL); }; (med_mcph1_f2_summary <- summary(med_mcph1_f2));
    try(med_mcph1 <- mediation::mediate(med_mcph1_f1, med_mcph1_f2, treat='Africa', mediator='MCPH1_freq_wavg', boot=FALSE), silent=TRUE); if( is.null(med_mcph1) ){ return (NULL); }; (med_mcph1_summary <- summary(med_mcph1));
    
    # Return value:
    data.frame(
      # ASPM:
      "aspm_TE"=med_aspm_summary$tau.coef, "aspm_TE_95low"=med_aspm_summary$tau.ci[1],     "aspm_TE_95high"=med_aspm_summary$tau.ci[2],     "aspm_TE_p"=med_aspm_summary$tau.p,
      "aspm_ADE"=med_aspm_summary$z.avg,   "aspm_ADE_95low"=med_aspm_summary$z.avg.ci[1],  "aspm_ADE_95high"=med_aspm_summary$z.avg.ci[2],  "aspm_ADE_p"=med_aspm_summary$z.avg.p,
      "aspm_ACME"=med_aspm_summary$d.avg,  "aspm_ACME_95low"=med_aspm_summary$d.avg.ci[1], "aspm_ACME_95high"=med_aspm_summary$d.avg.ci[2], "aspm_ACME_p"=med_aspm_summary$d.avg.p,
      "aspm_prop"=med_aspm_summary$n.avg,  "aspm_prop_95low"=med_aspm_summary$n.avg.ci[1], "aspm_prop_95high"=med_aspm_summary$n.avg.ci[2], "aspm_prop_p"=med_aspm_summary$n.avg.p,
      "aspm_Afr_gene_b"=med_aspm_f1_summary$coefficients["AfricaYes", "Estimate"], "aspm_Afr_gene_b_stderr"=med_aspm_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "aspm_Afr_gene_p"=med_aspm_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "aspm_gene_tone_b"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Estimate"], "aspm_gene_tone_b_stderr"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Std. Error"],
      "aspm_gene_tone_p"=med_aspm_f2_summary$coefficients["ASPM_freq_wavg", "Pr(>|z|)"],
      # MCPH1:
      "mcph1_TE"=med_mcph1_summary$tau.coef, "mcph1_TE_95low"=med_mcph1_summary$tau.ci[1],     "mcph1_TE_95high"=med_mcph1_summary$tau.ci[2],     "mcph1_TE_p"=med_mcph1_summary$tau.p,
      "mcph1_ADE"=med_mcph1_summary$z.avg,   "mcph1_ADE_95low"=med_mcph1_summary$z.avg.ci[1],  "mcph1_ADE_95high"=med_mcph1_summary$z.avg.ci[2],  "mcph1_ADE_p"=med_mcph1_summary$z.avg.p,
      "mcph1_ACME"=med_mcph1_summary$d.avg,  "mcph1_ACME_95low"=med_mcph1_summary$d.avg.ci[1], "mcph1_ACME_95high"=med_mcph1_summary$d.avg.ci[2], "mcph1_ACME_p"=med_mcph1_summary$d.avg.p,
      "mcph1_prop"=med_mcph1_summary$n.avg,  "mcph1_prop_95low"=med_mcph1_summary$n.avg.ci[1], "mcph1_prop_95high"=med_mcph1_summary$n.avg.ci[2], "mcph1_prop_p"=med_mcph1_summary$n.avg.p,
      "mcph1_Afr_gene_b"=med_mcph1_f1_summary$coefficients["AfricaYes", "Estimate"], "mcph1_Afr_gene_b_stderr"=med_mcph1_f1_summary$coefficients["AfricaYes", "Std. Error"], 
      "mcph1_Afr_gene_p"=med_mcph1_f1_summary$coefficients["AfricaYes", "Pr(>|t|)"],
      "mcph1_gene_tone_b"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Estimate"], "MCPH1_gene_tone_b_stderr"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Std. Error"],
      "mcph1_gene_tone_p"=med_mcph1_f2_summary$coefficients["MCPH1_freq_wavg", "Pr(>|z|)"], 
      row.names=NULL);
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, med_samples_per_fam, file="./cache-results/med_tc_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/med_tc_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=3*4, fig.cap=capFig(paste0("Mediation analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost panels show the distribution of point estimates of the Total Effect (TE), the Direct Effect (ADE) and the Indirect Effect (ACME) for *ASPM* and *MCPH1*; the middle panels show the distribution of the *p*-values for the same effects, while the rightmost panels show the distribution of the regression slopes (*β*) for the two alleles, top: for the regression of the allele frequency on within vs outside Africa, and bottom: for the regression of tone on the allele while controlling for within vs outside Africa. The black vertical lines show: 0.0 (dotted), 0.05 (solid) and 0.10 (dashed)."))}
p1 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE", "aspm_ADE", "aspm_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-4.00, 4.00) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               #scale_color_discrete(name="Effect type", labels=c("aspm_TE"=expression(" "~italic("TE")), "aspm_ADE"=expression(" "~italic("ADE")), "aspm_ACME"=expression(" "~italic("ACME")))) + 
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation estimates")) + theme(legend.position="bottom");
             
p2 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_TE_p", "aspm_ADE_p", "aspm_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("ASPM")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p3 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_Afr_gene_b", "mcph1_Afr_gene_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-0.8,0.1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Allele", labels=c("aspm_Afr_gene_b"=expression(" "~italic("ASPM")-D), "mcph1_Afr_gene_b"=expression(" "~italic("MCPH1")-D)), values=c("aspm_Afr_gene_b"="yellow", "mcph1_Afr_gene_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("Africa " %->% " allele"))) + theme_bw() + theme(legend.position="bottom");
             
p4 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE", "mcph1_ADE", "mcph1_ACME")]),
                    aes(x=value, fill=variable), color="black") + xlim(-4.00, 4.00) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab("Estimate") + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation estimates")) + theme(legend.position="none");
             
p5 <- ggplot(reshape::melt(med_samples_per_fam[,c("mcph1_TE_p", "mcph1_ADE_p", "mcph1_ACME_p")]),
                    aes(x=value, fill=variable), color="black") + xlim(0,1) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.05, color="black", linetype="dashed") + geom_vline(xintercept=0.10, color="black", linetype="dotted") + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               xlab(expression(italic("p")-"value")) + ylab("Density") + ggtitle(expression(italic("MCPH1")-D:"Mediation "~italic("p")-"values")) + theme(legend.position="none");
             
p6 <- ggplot(reshape::melt(med_samples_per_fam[,c("aspm_gene_tone_b", "mcph1_gene_tone_b")]),
                    aes(x=value, fill=variable), color="black") + xlim(-10,10) +
               geom_density(alpha=0.3) + geom_vline(xintercept=0.0, color="black", linetype="solid") +
               scale_fill_manual(name="Gene", values=c("aspm_gene_tone_b"="yellow", "mcph1_gene_tone_b"="black")) + 
               xlab(expression(italic(beta))) + ylab("Density") + ggtitle(expression(italic(beta)("allele " %->% " tone | Africa"))) + theme_bw() + theme(legend.position="none");
             
l1 <- get_legend(p1);
l3 <- get_legend(p3);

grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
```

```{r include=FALSE}
# Plots for paper
cairo_pdf("./figures/tone_counts_mediation_restricted.pdf", width=3*3.3, height=2*2.5+0.15); 
grid.arrange(p1 + theme(legend.position = "none"), p2, p3 + theme(legend.position = "none"), p4, p5, p6, l1, l3, 
             layout_matrix=rbind(c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3), 
                                 c(1,1, 2,2, 3,3),
                                 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 c(4,4, 5,5, 6,6), 
                                 
                                 c(NA,7,7,NA, 8,8))); 
dev.off();
```

For *ASPM*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_TE,na.rm=TRUE), median(med_samples_per_fam$aspm_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ADE,na.rm=TRUE), median(med_samples_per_fam$aspm_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_ACME,na.rm=TRUE), median(med_samples_per_fam$aspm_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$aspm_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$aspm_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$aspm_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$aspm_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

For *MCPH1*-D:

- **TE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_TE,na.rm=TRUE), median(med_samples_per_fam$mcph1_TE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_TE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_TE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ADE**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), median(med_samples_per_fam$mcph1_ADE,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ADE > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ADE, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **ACME**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% > 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), median(med_samples_per_fam$mcph1_ACME,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_ACME > 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_ACME, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`;

- **β(Africa → allele)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_Afr_gene_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_Afr_gene_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_Afr_gene_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`;

- **β(allele → tone | Africa)**: `r sprintf("mean = %.2g, median = %.2g; %.1f%% significant at *α*-level 0.05 and %.1f%% significant at *α*-level 0.10; %.1f%% < 0.0; one-sample one-sided t-test vs 0: *t*(%d) = %.1f, *p* = %.2g", mean(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), median(med_samples_per_fam$mcph1_gene_tone_b,na.rm=TRUE), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_b < 0.0,na.rm=TRUE)/nrow(med_samples_per_fam), (tt <- t.test(med_samples_per_fam$mcph1_gene_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`.

Given the low sample size *N* = `r length(unique(d_tb$family_name))` unique families, relatively few effect sizes are big enough to be significant; however, there are many more significant indirect effects (ACME) for *ASPM*-D than for *MCPH1*-D: `r sprintf("%.1f%% vs %.1f%% (%.1f times) for *α*-level 0.05, and %.1f%% vs %.1f%% (%.1f times) for *α*-level 0.10", 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE)/nrow(med_samples_per_fam), sum(med_samples_per_fam$aspm_gene_tone_p < 0.05,na.rm=TRUE)/sum(med_samples_per_fam$mcph1_gene_tone_p < 0.05,na.rm=TRUE), 100*sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), 100*sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE)/nrow(med_samples_per_fam), sum(med_samples_per_fam$aspm_gene_tone_p < 0.10,na.rm=TRUE)/sum(med_samples_per_fam$mcph1_gene_tone_p < 0.10,na.rm=TRUE))`.


#### Path analysis

Please note that path analysis uses a linear model (so not a Poisson one) for the tone *counts*; also I only use the numeric coding for Africa.

##### All data

```{r include=FALSE}
## Path analysis:
# The model (numeric):
sem_tone_num <- '
    # tone:
    n_tones ~ Africa_num + ASPM_freq_wavg + MCPH1_freq_wavg

    # the alleles:
    ASPM_freq_wavg  ~ Africa_num
    MCPH1_freq_wavg ~ Africa_num
  ';
semfit_tone_num <- sem(sem_tone_num, data=d_tc, se="robust.sem");
summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE);
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
(semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")));
mi_tone_num <- modindices(semfit_tone_num);
```

Coding Africa numerically, the model fits the data very well (`r sprintf("*&chi;*^2^(%d)=%.2f, *p*=%.2g; CFI=%.2f, TLI=%.2f, NNFI=%.2f and RFI=%.2f", semfit_tone_num_measures["df"], semfit_tone_num_measures["chisq"], semfit_tone_num_measures["pvalue"], semfit_tone_num_measures["cfi"], semfit_tone_num_measures["tli"], semfit_tone_num_measures["nnfi"], semfit_tone_num_measures["rfi"])`):

```{r fig.cap=capFig("Path analysis model with standardised coefficients and significance stars. Here, macroarea (Africa vs non-Africa) is coded as numeric binary (`Africa_num` with in Africa=1); `ASPM_freq_wavg` is *ASPM*-D and `MCPH1_freq_wavg` is *MCPH1*-D..")}
lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=TRUE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
```


##### Restricted sampling

```{r include=FALSE}
# Repeatedly sample and do the regressions:
if( !file.exists("./cache-results/sem_tc_restr_sampling.RData") ) # computationally expensive
{
  n_samples <- 1000;
  sem_samples_per_fam <- do.call(rbind, pblapply(1:n_samples, function(i)
  {
    # Sample:
    d <- .pick_one_sample_per_family(d_tc);
    
    # Fit the model:
    semfit_tone_num <- NULL;
    try(semfit_tone_num <- sem(sem_tone_num, data=d, se="robust.sem"), silent=TRUE);
    if( is.null(semfit_tone_num) ){ return(NULL); }
    semfit_tone_num_summary <- NULL;
    try(semfit_tone_num_summary <- summary(semfit_tone_num, fit.measures=TRUE, standardize=TRUE, rsquare=TRUE, estimates=TRUE, ci=TRUE), silent=TRUE);
    if( is.null(semfit_tone_num_summary) ){ return (NULL); }
    #lavaanPlot(model=semfit_tone_num, coefs=TRUE, sig=1.00, stand=FALSE, covs=TRUE, stars=c("regress", "latent", "covs"), edge_options=list(color="gray"));
    semfit_tone_num_measures <- NULL;
    try(semfit_tone_num_measures <- fitMeasures(semfit_tone_num, c("chisq", "df", "pvalue", "cfi", "tli", "nnfi", "rfi")), silent=TRUE);
    if( is.null(semfit_tone_num_measures) ){ return (NULL); }

    # Return value:
    tmp <- semfit_tone_num_summary$PE;
    cbind(
      as.data.frame(matrix(semfit_tone_num_measures, nrow=1, dimnames=list("", names(semfit_tone_num_measures)))),
      data.frame(
        "Afr_aspm_b"  =tmp$est[tmp$lhs=="ASPM_freq_wavg"      & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_aspm_p"  =tmp$pvalue[tmp$lhs=="ASPM_freq_wavg"   & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_mcph1_b" =tmp$est[tmp$lhs=="MCPH1_freq_wavg"     & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_mcph1_p" =tmp$pvalue[tmp$lhs=="MCPH1_freq_wavg"  & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "Afr_tone_b"  =tmp$est[tmp$lhs=="n_tones"             & tmp$op=="~" & tmp$rhs=="Africa_num"], 
        "Afr_tone_p"  =tmp$pvalue[tmp$lhs=="n_tones"          & tmp$op=="~" & tmp$rhs=="Africa_num"],
        "aspm_tone_b" =tmp$est[tmp$lhs=="n_tones"             & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],  
        "aspm_tone_p" =tmp$pvalue[tmp$lhs=="n_tones"          & tmp$op=="~" & tmp$rhs=="ASPM_freq_wavg"],
        "mcph1_tone_b"=tmp$est[tmp$lhs=="n_tones"             & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"], 
        "mcph1_tone_p"=tmp$pvalue[tmp$lhs=="n_tones"          & tmp$op=="~" & tmp$rhs=="MCPH1_freq_wavg"],
        row.names=NULL));
  }));#, cl=mclapply_ncores)); # seems to crash if parallelised...
  save(n_samples, sem_samples_per_fam, file="./cache-results/sem_tc_restr_sampling.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/sem_tc_restr_sampling.RData");
}
```

```{r fig.height=2*4, fig.width=2*4, fig.cap=capFig(paste0("Path analysis for ",n_samples," restricted samples (i.e., picking one random language per family). The leftmost row of two plots shows the coefficient estimates and the *p*-values, respectively, for the five paths in the model (see the path plots above). The rightmost plot shows the various fit indices. The black horiontal lines show: 0.0 (solid), 0.05 (dashed) and 1.0 (dotted)."))}
grid.arrange(ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_b", "Afr_mcph1_b", "Afr_tone_b", "aspm_tone_b", "mcph1_tone_b")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.0, color="black", linetype="solid") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_b"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_b"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_b"=expression("Africa " %->% " tone counts"), "aspm_tone_b"=expression("ASPM-D " %->% " tone counts"), "mcph1_tone_b"=expression("MCPH1-D " %->% " tone counts"))) + 
               xlab("Path") + ylab("Coefficient") + ggtitle("Path coeffcients") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("pvalue", "cfi", "tli", "nnfi", "rfi")]),
                    aes(x=variable, y=value, fill=variable)) + ylim(0,NA) + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=c(0.05, 1.0), color="black", linetype=c("dashed", "dotted")) +
               scale_fill_discrete(name="Fit indices", labels=c("pvalue"=expression(chi^2~italic(p)~"-value"), "cfi"="CFI", "tli"="TLI", "nnfi"="NNFI", "rfi"="RFI")) + 
               ylab("Estimate") + xlab("Fit indices") + ggtitle("Fit indices") + theme(legend.position="right"),
             
             ggplot(reshape::melt(sem_samples_per_fam[,c("Afr_aspm_p", "Afr_mcph1_p", "Afr_tone_p", "aspm_tone_p", "mcph1_tone_p")]),
                    aes(x=variable, y=value, fill=variable), color="black") + 
               geom_boxplot(alpha=0.3) + geom_hline(yintercept=0.05, color="black", linetype="dashed") +
               scale_fill_discrete(name="Paths", labels=c("Afr_aspm_p"=expression("Africa " %->% " ASPM-D"), "Afr_mcph1_p"=expression("Africa " %->% " MCPH1-D"), "Afr_tone_p"=expression("Africa " %->% " tone counts"), "aspm_tone_p"=expression("ASPM-D " %->% " tone counts"), "mcph1_tone_p"=expression("MCPH1-D " %->% " tone counts"))) + 
               xlab("Path") + ylab("p-value") + ggtitle("Path p-values") + theme(legend.position="right", axis.text.x=element_text(angle=45, vjust=1.0, hjust=1.0)),
             
             nrow=2);
```

It can be seen that:

- the models fits:
  + `r round(100*sum(sem_samples_per_fam$pvalue >= 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam),1)`% of the *p*-values are not significant
  + mean(CFI) = `r round(mean(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, median(CFI) = `r round(median(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, sd(CFI) = `r round(sd(sem_samples_per_fam$cfi, na.rm=TRUE),2)`, IQR(CFI) = `r round(IQR(sem_samples_per_fam$cfi, na.rm=TRUE),2)`
  + mean(TLI) = `r round(mean(sem_samples_per_fam$tli, na.rm=TRUE),2)`, median(TLI) = `r round(median(sem_samples_per_fam$tli, na.rm=TRUE),2)`, sd(TLI) = `r round(sd(sem_samples_per_fam$tli, na.rm=TRUE),2)`, IQR(TLI) = `r round(IQR(sem_samples_per_fam$tli, na.rm=TRUE),2)`
  + mean(NNFI) = `r round(mean(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, median(NNFI) = `r round(median(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, sd(NNFI) = `r round(sd(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`, IQR(NNFI) = `r round(IQR(sem_samples_per_fam$nnfi, na.rm=TRUE),2)`
  + mean(RFI) = `r round(mean(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, median(RFI) = `r round(median(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, sd(RFI) = `r round(sd(sem_samples_per_fam$rfi, na.rm=TRUE),2)`, IQR(RFI) = `r round(IQR(sem_samples_per_fam$rfi, na.rm=TRUE),2)`

- Africa → *ASPM*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_aspm_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_aspm_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_aspm_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_aspm_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`

- Africa → *MCPH1*-D: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_mcph1_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_mcph1_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_mcph1_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_mcph1_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`

- Africa → tone *counts*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% > 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), median(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$Afr_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$Afr_tone_b > 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$Afr_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$Afr_tone_b, mu=0, alternative="greater"))$parameter, tt$statistic, tt$p.value)`

- *ASPM*-D → tone *counts*: `r sprintf("mean = %.2g, median = %.2g, sd = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), median(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$aspm_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$aspm_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$aspm_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$aspm_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`

- *MCPH1*-D → tone *counts*: `r sprintf("mean = %.2g, median = %.2g, as = %.2g, IQR = %.2g, %.1f%% < 0; %.1f%% significant at *α*-level 0.05; one-sample one-sided *t*-test vs 0: *t*(%d) = %.2g, *p* = %.2g", mean(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), median(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), sd(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), IQR(sem_samples_per_fam$mcph1_tone_b, na.rm=TRUE), 100*sum(sem_samples_per_fam$mcph1_tone_b < 0, na.rm=TRUE)/nrow(sem_samples_per_fam), 100*sum(sem_samples_per_fam$mcph1_tone_p < 0.05, na.rm=TRUE)/nrow(sem_samples_per_fam), (tt <- t.test(sem_samples_per_fam$mcph1_tone_b, mu=0, alternative="less"))$parameter, tt$statistic, tt$p.value)`



## Power analysis

```{r include=FALSE}
library(simr);
if( !file.exists("./cache-results/pwr_aspm.RData") )
{
  pwr_m <- m_tb_aspm_m;
  
  # Observed power for ASPM-D:
  pwr_m_obs <- powerSim(pwr_m, nsim=1000, test=fixed("ASPM_freq_wavg", method="z"), progress=FALSE); 
  pwr_m_obs # ~15%
  
  # Increase number of families:
  pwr_m_fams <- mclapply(c(5,10,25,50,100,200,300,350,400,500), function(i) 
                         list("nfams"=i, 
                              "power"=powerSim(extend(pwr_m, along="family_name", n=i), nsim=1000, test=fixed("ASPM_freq_wavg", method="z"), progress=FALSE)), 
                         mc.cores=brms_ncores);
  pwr_m_fams;
  
  # Increase number of languages:
  pwr_m_lgs <- mclapply(c(1,2,5,10,25,50,100,250,500,750,1000), function(i) 
                        list("nlgs"=i, 
                             "power"=powerSim(extend(pwr_m, within="family_name", n=i), nsim=1000, test=fixed("ASPM_freq_wavg", method="z"), progress=FALSE)), 
                        mc.cores=brms_ncores);
  pwr_m_lgs;
  
  # Increase both:
  tmp <- expand.grid(nfams=c(5,10,25,50,100,200,300,350,400,500), nlgs=c(1,2,5,10,25,50,100,250,500,750,1000));
  pwr_m_both <- mclapply(1:nrow(tmp), function(i) 
                         list("nfams"=tmp$nfams[i], "nlgs"=tmp$nlgs[i], 
                              "power"=powerSim(extend(extend(pwr_m, along="family_name", n=tmp$nfams[i]), within="family_name", n=tmp$nlgs[i]), 
                                              nsim=1000, test=fixed("ASPM_freq_wavg", method="z"), progress=FALSE)), 
                         mc.cores=brms_ncores);
  pwr_m_both_orig <- pwr_m_both;
  s <- sapply(pwr_m_both, function(x) is.null(x$power)); # seems that some fail in parallel: do them sequentially...
  for( i in which(s) )
  {
    cat(i,", ");
    pwr_m_both[[i]] <- list("nfams"=tmp$nfams[i], "nlgs"=tmp$nlgs[i], 
                            "power"=powerSim(extend(extend(pwr_m, along="family_name", n=tmp$nfams[i]), within="family_name", n=tmp$nlgs[i]), 
                                             nsim=1000, test=fixed("ASPM_freq_wavg", method="z"), progress=FALSE));
  }
  pwr_m_both;

  # Save:
  save(pwr_m, pwr_m_obs, pwr_m_fams, pwr_m_lgs, pwr_m_both, file="./cache-results/pwr_aspm.RData", compress="xz", compression_level=9);
} else
{
  load("./cache-results/pwr_aspm.RData"); 
}
```

I use simulations for power analysis (as implemented by package `simr`), focusing on the effect of *ASPM*-D on *tone1* using `glmer`, i.e. logistic regression with *ASPM*-D as fixed effect and controlling for language *family* (as random effect) and *macroarea* as fixed effect.


### Observed power

The observed effect size of *ASPM*-D is *&beta;*~*ASPM*-D~ = `r round(lme4::fixef(pwr_m)["ASPM_freq_wavg"],1)`, *p*~*ASPM*-D~ = `r round(summary(pwr_m)$coefficients["ASPM_freq_wavg", "Pr(>|z|)"],2)`, with an ICC = `r round(performance::icc(pwr_m)$ICC_adjusted*100,1)`% on `r summary(pwr_m)$ngrps` level-2 groups (families) and `r nobs(pwr_m)` observations (languages/samples).
The *observed* (post-hoc) power 1 - *&beta;* = `r round(as.data.frame(summary(pwr_m_obs))[1,"mean"]*100,1)`%, 95%CI = `r sprintf("(%.1f%%, %.1f%%)", as.data.frame(summary(pwr_m_obs))[1,"lower"]*100, as.data.frame(summary(pwr_m_obs))[1,"upper"]*100)`.


### Changing the number of languages

If we keep the families but change the number of languages per family:

```{r fig.cap=capFig("Estimated power (with 95%) when changing the number of languages but keeping everything else constant.")}
d_pwr_lgs <- do.call(rbind, lapply(pwr_m_lgs, function(x) data.frame("n"=x$nlgs, 
                                                                     "pwr"=as.data.frame(summary(x$power))[1,"mean"]*100,
                                                                     "pwr_l"=as.data.frame(summary(x$power))[1,"lower"]*100,
                                                                     "pwr_u"=as.data.frame(summary(x$power))[1,"upper"]*100)));
ggplot(d_pwr_lgs, aes(x=n, y=pwr)) + xlab("Number of languages per family") + ylab("Power") + ylim(c(0,100)) +
  geom_errorbar(aes(ymin=pwr_l, ymax=pwr_u), width=.1, color="gray") +
  geom_line(color="darkgray") + geom_point() + 
  geom_hline(yintercept=80, color="black", linetype="dashed") +
  NULL;
```


### Changing the number of families

If we change the number of families:

```{r fig.cap=capFig("Estimated power (with 95%) when changing the number of language families but keeping everything else constant.")}
d_pwr_fams <- do.call(rbind, lapply(pwr_m_fams, function(x) data.frame("n"=x$nfams, 
                                                                       "pwr"=as.data.frame(summary(x$power))[1,"mean"]*100,
                                                                       "pwr_l"=as.data.frame(summary(x$power))[1,"lower"]*100,
                                                                       "pwr_u"=as.data.frame(summary(x$power))[1,"upper"]*100)));
ggplot(d_pwr_fams, aes(x=n, y=pwr)) + xlab("Number of families") + ylab("Power") + ylim(c(0,100)) +
  geom_errorbar(aes(ymin=pwr_l, ymax=pwr_u), width=.1, color="gray") +
  geom_line(color="darkgray") + geom_point() + 
  geom_hline(yintercept=80, color="black", linetype="dashed") +
  NULL;
```


### Changing the number of families and languages

If we change the number of families and the number of languages per family:

```{r fig.cap=capFig("Estimated power when changing the number of language families and the number of languages per family, but keeping everything else constant. Color is proportional to power and the shape shows if the power is > 80%. The two vertical dotted lines are the approximate number of families in Ethnologue (blue, ~150) and Glottolog (black, ~420). The horizontal dotted lines are summaries of the number of languages in Glottolog: the mean (red, ~20), the median (black, 2) and the median excluding isolates (blue, 5); not shown is the maxmimum (~1400 in Atlantic-Congo).")}
d_pwr_both <- do.call(rbind, lapply(pwr_m_both, function(x) data.frame("nfams"=x$nfams, "nlgs"=x$nlgs,
                                                                       "pwr"=as.data.frame(summary(x$power))[1,"mean"]*100,
                                                                       "pwr_80"=(as.data.frame(summary(x$power))[1,"mean"]*100) >= 80,
                                                                       "pwr_l"=as.data.frame(summary(x$power))[1,"lower"]*100,
                                                                       "pwr_u"=as.data.frame(summary(x$power))[1,"upper"]*100)));
ggplot(d_pwr_both, aes(x=nfams, y=nlgs)) + xlab("Number of families") + ylab("Number of languages per family") +
  geom_point(aes(fill=pwr, shape=pwr_80, color=pwr_80), size=2) +
  scale_fill_viridis_c(direction=1, name="Power (%)") + 
  scale_shape_manual(values=c("TRUE"=21, "FALSE"=23), name="Power > 80%?", labels=c("TRUE"="Yes", "FALSE"="No")) + 
  scale_color_manual(values=c("TRUE"="red", "FALSE"="black"), name="Power > 80%?", labels=c("TRUE"="Yes", "FALSE"="No")) +
  geom_vline(xintercept=c(150, 420), color=c("blue", "black"), linetype="dotted") + # approx number of families in Ethnologue and Glottolog
  geom_hline(yintercept=c(20, 2, 5), color=c("red", "black", "blue"), linetype="dotted") + # approx number of languages in Glottolog: mean, median, median excluding isolates
  NULL;
```


### Summary of power analysis

First, it is clear that with the currently available data, a "standard" maximum-likelihood mixed-effects model approach controlling for family (as a random effect) and for macroarea (as a fixed effect) has a very low power (&approx; 17%) of detecting a weak effect *&beta;* &approx; -2 as estimated for *ASPM*-D.

When keeping the number families constant at the observed 35, we only achieve an 80% power at more than 600 languages per family, and when increasing the number of families (while keeping their structure as observed) we would need between 300 and 350 families to reach 80%.

When varying both independently, the region of at least 80% power requires either too many families or too many languages, with the minimum families and languages required around 100 families with 250 languages each.

For comparison, currently the Ethnologue lists &approx; 150 families and Glottolog &approx; 420 (including language isolates), and the data in the latter gives a maximum of &approx; 1400 languages (for Atlantic-Congo), a mean of &approx; 20, a median of 2 overall and of 5 when excluding the isolates.


# Session information

```{r}
pander::pander(sessionInfo());
```



# References


